[{"title":"aspectj","date":"2017-12-09T05:21:23.000Z","path":"2017/12/09/aspectj/","text":"1.AspectJ简介安装https://www.eclipse.org/aspectj/工具https://www.jetbrains.com/help/idea/aspectj.html文档https://www.eclipse.org/aspectj/doc/released/progguide/index.htmlhttps://www.eclipse.org/aspectj/doc/released/adk15notebook/index.htmlhttps://www.eclipse.org/aspectj/doc/released/devguide/index.html 1.1 简介Join Point SignaturesAspectJ 支持 11 种 join points ：method call, method execution, constructor call, constructor execution, field get, field set, pre-initialization, initialization, static initialization, handler, and advice execution Pointcuts 选择 join points使用 9 种 指示符：call, execution, get, set, preinitialization, initialization, staticinitialization, handler, and adviceexecution Join Point Kind Subject Method call The method picked out by Java as the static target of the method call. Method execution The method that is executing. Constructor call The constructor being called. Constructor execution The constructor executing. Field get The field being accessed. Field set The field being set. https://www.eclipse.org/aspectj/doc/released/devguide/index.html| Initialization | The first constructor executing in this constructor chain. || Static initialization | The type being initialized. || Handler | The declared type of the exception being handled. || Advice execution | The advice being executed. | Pointcuts 使用 patterns 、signature、 modifiers 来匹配，例如 call pointcut call(ModifierPattern TypePattern TypePattern.IdPattern(TypePatternList) ThrowsPattern) modifiers： ModifierPattern ThrowsPatternsignature： TypePattern TypePattern.IdPattern(TypePatternList) Join Point Signatures Join Point Kind Return Type Declaring Type Id Parameter Types Field Type Exception Type Method call + + + + Method execution + + + + Constructor call + + Constructor execution + + Field get + + + Field set + + + Pre-initialization + + Initialization + + Static initialization + Handler + Advice execution + + 注意，虽然 advice excetution 签名包含 declaring type 、 parameter types。 adviceexecution pointcut指示符不支持匹配签名。 除了 field 的 get set, 和 method 的 call execution 切点可以有多个签名, 其他 join point 是明确的。method 的 call 或 execution join point 有相同的 id 和 parameter types ，但 Declaring Type 和 Return Type 可能有多个。field 的 get 或 set join point 有相同的 id 和 field type 但是 declaring type 可能有多个。 Method call join point signatures12345678910111213interface Q &#123; R m(String s);&#125;class P implements Q &#123; R m(String s) &#123;...&#125; &#125;class S extends P &#123; R' m(String s) &#123;...&#125;&#125;class T extends S &#123;&#125; 12T t = new T(); t.m(\"hello\"); &lt;= call join point occurs when this line is executed R(T) T.m(parameter_types) R&apos; S.m(String) R P.m(String) R Q.m(String) Method execution join point signatures1234567891011121314151617interface Q &#123; R m(String s);&#125;class P implements Q &#123; R m(String s) &#123;...&#125; &#125;class S extends P &#123; R' m(String s) &#123;...&#125;&#125;class T extends S &#123; &#125;class U extends T &#123; R' m(String s) &#123;...&#125;&#125; R&apos; U.m(String) R&apos; S.m(String) R P.m(String) R Q.m(String) Field get and set join point signatures123456789class P &#123; F f; &#125;class S extends P &#123; F f;&#125;class T extends S &#123; &#125; F S.f F T.f 注意：没有 F P.f Join Point Modifiers每一个 join point 都有一些 modifiers。包括：java 的 modifiers public, private, static, abstract 等任何 annotationsmethods 和 constructors 的 throws 从句 12345678public class X &#123; @Foo protected void doIt() &#123;...&#125; &#125;public class Y extends X &#123; public void doIt() &#123;...&#125; &#125; 如果调用(Y y) y.doIt(); modifiers 是 public如果调用(X x) x.doIt(); modifiers 是 @Foo,protected Summary of Join Point Matching可以有多个 signatures 限定。只能有一个 modifiers 限定。 当且仅当满足以下条件时，一个Pointcut才匹配特定的连接点：他们是同一kind(9种之一)signature （严格）匹配至少一个连接点的签名modifiers 匹配连接点的主体的修饰符 123456789101112131415interface Q &#123; R m(String s);&#125;class P implements Q &#123; @Foo public R m(String s) &#123;...&#125; &#125;class S extends P &#123; @Bar public R' m(String s) &#123;...&#125;&#125;class T extends S &#123;&#125; 1234567P p = new P();S s = new S();T t = new T();...p.m(\"hello\");s.m(\"hello\"); t.m(\"hello\"); call(@Foo R P.m(String)) signature与modifiers都匹配 s.m(“hello”);call(R’ m(String)) 匹配 t.m(“hello”) s.m(“hello”) 不匹配 p.m(“hello”) AnnotationsAnnotations in Java 5@Inherited@Retention(RetentionPolicy.RUNTIME)@Target(value = {ElementType.METHOD,ElementType.TYPE}) @this,@target and @args 需要 runtime retention@within, @withincode and @annotation 最少需要 class-file retention，如果用于binding形式，必须使用runtime retention。 Annotating AspectsAspectJ 5 支持 annotations 在 aspects, 和 aspects 内部的 method, field, constructor, advice, 和 inter-type declarations 上。不允许在 pointcut declarations 或 declare statements 上。12345678910111213141516171819202122232425262728293031323334353637383940414243@AspectAnnotationpublic abstract aspect ObserverProtocol &#123; @InterfaceAnnotation interface Observer &#123;&#125; @InterfaceAnnotation interface Subject &#123;&#125; @ITDFieldAnnotation private List&lt;Observer&gt; Subject.observers; @ITDMethodAnnotation public void Subject.addObserver(Observer o) &#123; observers.add(o); &#125; @ITDMethodAnnotation public void Subject.removeObserver(Observer o) &#123; observers.remove(o); &#125; @MethodAnnotation private void notifyObservers(Subject subject) &#123; for(Observer o : subject.observers) notifyObserver(o,subject); &#125; /** * Delegate to concrete sub-aspect the actual form of * notification for a given type of Observer. */ @MethodAnnotation protected abstract void notifyObserver(Observer o, Subject s); /* no annotations on pointcuts */ protected abstract pointcut observedEvent(Subject subject); @AdviceAnnotation after(Subject subject) returning : observedEvent(subject) &#123; notifyObservers(subject); &#125; &#125; @SuppressAjWarnings 压制静态匹配为空的advice警告。 Join Point Matching based on AnnotationsAnnotation Patternsannotation 匹配的两种自出形式@, 例如, @Foo, or @org.xyz.Foo.@(), 例如, @(org.xyz..*), or @(Foo || Boo) @ImmutableMatches any annotated element which has an annotation of type Immutable. !@PersistentMatches any annotated element which does not have an annotation of type Persistent. @Foo @GooMatches any annotated element which has both an annotation of type Foo and an annotation of type Goo. @(Foo || Goo)Matches any annotated element which has either an annotation of a type matching the type pattern (Foo || Goo). In other words, an annotated element with either an annotation of type Foo or an annotation of type Goo (or both). (The parenthesis are required in this example). @(org.xyz..)Matches any annotated element which has either an annotation of a type matching the type pattern (org.xyz..). In other words, an annotated element with an annotation that is declared in the org.xyz package or a sub-package. (The parenthesis are required in this example). Type Patterns123456789101112131415161718 TypePattern := SimpleTypePattern | '!' TypePattern | '(' AnnotationPattern? TypePattern ')' TypePattern '&amp;&amp;' TypePattern | TypePattern '||' TypePattern SimpleTypePattern := DottedNamePattern '+'? '[]'* DottedNamePattern := FullyQualifiedName RestOfNamePattern? | '*' NotStarNamePattern?RestOfNamePattern := '..' DottedNamePattern | '*' NotStarNamePattern? NotStarNamePattern := FullyQualifiedName RestOfNamePattern? | '..' DottedNamePattern FullyQualifiedName := JavaIdentifierCharacter+ ('.' JavaIdentifierCharacter+)* The following examples illustrate the use of annotations in type patterns: (@Immutable *)Matches any type with an @Immutable annotation. (!@Immutable *)Matches any type which does not have an @Immutable annotation. (@Immutable (org.xyz. || org.abc.))Matches any type in the org.xyz or org.abc packages with the @Immutable annotation. ((@Immutable Foo+) || Goo)Matches a type Foo or any of its subtypes, which have the @Immutable annotation, or a type Goo. ((@(Immutable || NonPersistent) org.xyz..*)Matches any type in a package beginning with the prefix org.xyz, which has either the @Immutable annotation or the @NonPersistent annotation. (@Immutable @NonPersistent org.xyz..*)Matches any type in a package beginning with the prefix org.xyz, which has both an @Immutable annotation and an @NonPersistent annotation. (@(@Inherited ) org.xyz..)Matches any type in a package beginning with the prefix org.xyz, which has an inheritable annotation. The annotation pattern @(@Inherited ) matches any annotation of a type matching the type pattern @Inherited , which in turn matches any type with the @Inherited annotation. Signature PatternsField Patterns123456789101112 FieldPattern := AnnotationPattern? FieldModifiersPattern? TypePattern (TypePattern DotOrDotDot)? SimpleNamePatternFieldModifiersPattern := '!'? FieldModifier FieldModifiersPattern* FieldModifier := 'public' | 'private' | 'protected' | 'static' | 'transient' | 'final' DotOrDotDot := '.' | '..' SimpleNamePattern := JavaIdentifierChar+ ('*' SimpleNamePattern)? @SensitiveData Matches a field of any type and any name, that has an annotation of type @SensitiveData @SensitiveData List org.xyz...Matches a member field of a type in a package with prefix org.xzy, where the field is of type List, and has an annotation of type @SensitiveData (@SensitiveData ) org.xyz...*Matches a member field of a type in a package with prefix org.xzy, where the field is of a type which has a @SensitiveData annotation. @Foo (@Goo ) (@Hoo ).*Matches a field with an annotation @Foo, of a type with an annotation @Goo, declared in a type with annotation @Hoo. @Persisted @Classified Matches a field with an annotation @Persisted and an annotation @Classified. Method and Constructor PatternsMethodPattern123456789101112131415161718192021 MethodPattern := AnnotationPattern? MethodModifiersPattern? TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern '(' FormalsPattern ')'ThrowsPattern?MethodModifiersPattern := '!'? MethodModifier MethodModifiersPattern*MethodModifier := 'public' | 'private' | 'protected' | 'static' | 'synchronized' | 'final' FormalsPattern := '..' (',' FormalsPatternAfterDotDot)* | OptionalParensTypePattern (',' FormalsPattern)* | TypePattern '...' FormalsPatternAfterDotDot := OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* | TypePattern '...' ThrowsPattern := 'throws' TypePatternListTypePatternList := TypePattern (',' TypePattern)* ConstructorPattern12345678 ConstructorPattern := AnnotationPattern? ConstructorModifiersPattern? (TypePattern DotOrDotDot)? 'new' '(' FormalsPattern ')' ThrowsPattern? ConstructorModifiersPattern := '!'? ConstructorModifier ConstructorModifiersPattern*ConstructorModifier := 'public' | 'private' | 'protected' @Oneway (..)Matches a method with any return type and any name, that has an annotation of type @Oneway. @Transaction (@Persistent org.xyz..).*(..)Matches a method with the @Transaction annotation, declared in a type with the @Persistent annotation, and in a package beginning with the org.xyz prefix. .(@Immutable *,..)Matches any method taking at least one parameter, where the parameter type has an annotation @Immutable. Example Pointcutswithin(@Secure *)Matches any join point where the code executing is declared in a type with an @Secure annotation. The format of the within pointcut designator in AspectJ 5 is ‘within’ ‘(‘ OptionalParensTypePattern ‘)’. staticinitialization(@Persistent *)Matches the staticinitialization join point of any type with the @Persistent annotation. The format of the staticinitialization pointcut designator in AspectJ 5 is ‘staticinitialization’ ‘(‘ OptionalParensTypePattern ‘)’. call(@Oneway (..))Matches a call to a method with a @Oneway annotation. execution(public (@Immutable ) org.xyz...*(..))The execution of any public method in a package with prefix org.xyz, where the method returns an immutable result. set(@Cachable )Matches the set of any cachable field. handler(!@Catastrophic *)Matches the handler join point for the handling of any exception that is not Catastrophic. The format of the handler pointcut designator in AspectJ 5 is ‘handler’ ‘(‘ OptionalParensTypePattern ‘)’. Runtime type matching and context exposureAspectJ 5 支持 “@” pointcut 指示器，用于运行时 annotation 存在校验，和 annotation 环境绑定 ： @args, @this, @target, @within, @withincode, and @annotation。 使用 @this, @target or @args 在编译时如果 annotation 保留策略不是 runtime 的 annotation会报错。12345678910111213141516AtThis := '@this' '(' AnnotationOrIdentifer ')' AtTarget := '@target' '(' AnnotationOrIdentifier ')' AnnotationOrIdentifier := FullyQualifiedName | Identifier AtArgs := '@args' '(' AnnotationsOrIdentifiersPattern ')' AnnotationsOrIdentifiersPattern := '..' (',' AnnotationsOrIdentifiersPatternAfterDotDot)? | AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPattern)* | '*' (',' AnnotationsOrIdentifiersPattern)* AnnotationsOrIdentifiersPatternAfterDotDot := AnnotationOrIdentifier (',' AnnotationsOrIdentifiersPatternAfterDotDot)* | '*' (',' AnnotationsOrIdentifiersPatternAfterDotDot)* @this(Foo)Matches any join point where the object currently bound to ‘this’ has an annotation of type Foo. call( (..)) &amp;&amp; @target(Classified)Matches a call to any object where the target of the call has a @Classified annotation. 123456pointcut callToClassifiedObject(Classified classificationInfo) : call(* *(..)) &amp;&amp; @target(classificationInfo);pointcut txRequiredMethod(Tx transactionAnnotation) : execution(* *(..)) &amp;&amp; @this(transactionAnnotation) &amp;&amp; if(transactionAnnotation.policy() == TxPolicy.REQUIRED); 123456789101112/** * matches any join point with at least one argument, and where the * type of the first argument has the @Classified annotation */pointcut classifiedArgument() : @args(Classified,..);/** * matches any join point with three arguments, where the third * argument has an annotation of type @Untrusted. */pointcut untrustedData(Untrusted untrustedDataSource) : @args(*,*,untrustedDataSource); 除了context绑定，还可以从thisJoinPoint, thisJoinPointStaticPart, and thisEnclosingJoinPointStaticPart中获取AnnotatedElement123Annotation[] thisAnnotations = thisJoinPoint.getThis().getClass().getAnnotations();Annotation[] targetAnnotations = thisJoinPoint.getTarget().getClass().getAnnotations();Annotation[] firstParamAnnotations = thisJoinPoint.getArgs()[0].getClass().getAnnotations(); @within 有指定 annotation 注释的类中。@withincode 有指定 annotation 注释的方法中。12AtWithin := '@within' '(' AnnotationOrIdentifier ')'AtWithinCode := '@withincode' '(' AnnotationOrIdentifier ')' @within(Foo)Matches any join point where the executing code is defined within a type which has an annotation of type Foo. pointcut insideCriticalMethod(Critical c) : @withincode(c);Matches any join point where the executing code is defined in a method or constructor which has an annotation of type @Critical, and exposes the value of the annotation in the parameter c. @annotation 任何 join point 的主题上有给定的类型。可用于context曝光。1AtAnnotation := &apos;@annotation&apos; &apos;(&apos; AnnotationOrIdentifier &apos;)&apos; Package and Parameter Annotations不支持package annotations，未来可能支持。123456789@SomeAnnotation@SomeOtherAnnotationclass AnnotatedType &#123;&#125;class C &#123; public void foo(AnnotatedType a) &#123;&#125; public void goo(@SomeAnnotation String s) &#123;&#125; public void hoo(@SomeAnnotation AnnotatedType a) &#123;&#125;&#125; 123pointcut p(): execution(* *(@SomeAnnotation *)); method foopointcut p(): execution(* *(@SomeAnnotation (*))); method goopointcut p(): execution(* *(@SomeAnnotation (@SomeOtherAnnotation *))); method hoo Annotation Inheritance and pointcut matching1234567891011121314151617class C1 &#123; @SomeAnnotation public void aMethod() &#123;...&#125;&#125;class C2 extends C1 &#123; public void aMethod() &#123;...&#125;&#125;class Main &#123; public static void main(String[] args) &#123; C1 c1 = new C1(); C2 c2 = new C2(); c1.aMethod(); c2.aMethod(); &#125;&#125; 12345678aspect X &#123; pointcut annotatedC2MethodCall() : call(@SomeAnnotation * C2.aMethod()); pointcut annotatedMethodCall() : call(@SomeAnnotation * aMethod());&#125; annotatedC2MethodCall 匹配不到任何属性。因为C2.aMethod方法没有任何注释。annotatedMethodCall 匹配到C1.aMethod() 没有c2.aMethod() Matching based on annotation values123pointcut txRequiredMethod(Tx transactionAnnotation) : execution(* *(..)) &amp;&amp; @this(transactionAnnotation) &amp;&amp; if(transactionAnnotation.policy() == TxPolicy.REQUIRED); Using Annotations with declare statementsDeclare error and declare warning1234567declare warning : withincode(@PerformanceCritical * *(..)) &amp;&amp; call(@ExpensiveOperation * *(..)) : &quot;Expensive operation called from within performance critical section&quot;; declare error : call(* org.xyz.model.*.*(..)) &amp;&amp; !@within(Trusted) : &quot;Untrusted code should not call the model classes directly&quot;; declare parents12declare parents : TypePattern extends Type;declare parents : TypePattern implements TypeList; declare parents : (@Secured *) implements SecuredObject; All types with the @Secured annotation implement the SecuredObject inteface. declare parents : (@Secured BankAccount+) implements SecuredObject; The subset of types drawn from the BankAccount type and any subtype of BankAccount, where the @Secured annotation is present, implement the SecuredObject interface. declare precedence1declare precedence : TypePatList; declare precedence : (@Security ),; All aspects with the @Security annotation take precedence over any other aspects in the system. (Or, more informally, all security-related aspects take precedence). Declare AnnotationAspectJ 5 支持一种新的 declare statement, declare annotation不同的 annotation 接收方，有不同的形式。declare @type for typesdeclare @method for methodsdeclare @constructor for constructorsdeclare @field for fieldsdeclare @package may be supported in a future release. 123456declare @&lt;kind&gt; : ElementPattern : Annotation ; ElementPattern := TypePattern | MethodPattern | ConstructorPattern | FieldPattern declare @type : org.xyz.model..* : @BusinessDomain ;All types defined in a package with the prefix org.xyz.model have the @BusinessDomain annotation. declare @method : public BankAccount+.(..) : @Secured(role=”supervisor”)All public methods in BankAccount and its subtypes have the annotation @Secured(role=”supervisor”). declare @constructor : BankAccount+.new(..) : @Secured(role=”supervisor”)All constructors in BankAccount and its subtypes have the annotation @Secured(role=”supervisor”). declare @field : DAO+. : @Persisted;All fields defined in DAO or its subtypes have the @Persisted annotation. Inter-type Declarationsannotation type 不能作为 inter-type 声明的目标。 GenericsGenerics in AspectJ 5Matching generic and parameterized types in pointcut expressions在 pointcut 中使用泛型和参数化类型最简单的方式是，使用 raw type。例如：List 会匹配 List。这将保证jdk 5以前的兼容性。除非你想明确缩小匹配泛型类型，否则这是建议方法。12345678910111213141516171819public class Utils &#123; /** static generic method */ static &lt;T&gt; T first(List&lt;T&gt; ts) &#123; ... &#125; /** instance generic method */ &lt;T extends Number&gt; T max(T t1, T t2) &#123; ... &#125; &#125;public class G&lt;T&gt; &#123; // field with parameterized type T myData; // method with parameterized return type public List&lt;T&gt; getAllDataItems() &#123;...&#125; &#125; AspectJ 不允许使用type variables进行pointcut类型匹配。Java5 定义泛型擦除如下The erasure of a parameterized type T is |T|. For example, the erasure of List is List.The erasure of a nested type T.C is |T|.C. For example, the erasure of the nested type Foo.Bar is Foo.Bar.The erasure of an array type T[] is |T|[]. For example, the erasure of List[] is List[].The erasure of a type variable is its leftmost bound. For example, the erasure of a type variable P is Object, and the erasure of a type variable N extends Number is Number.The erasure of every other type is the type itself 根据擦除规则。Utils signature 为 static Object Utils.first(List) Number Utils.max(Number, Number)G signature 为 Object G.myData public List G.getAllDataItems() Restricting matching using parameterized types12345678910111213public class Foo &#123; List&lt;String&gt; myStrings; List&lt;Float&gt; myFloats; public List&lt;String&gt; getStrings() &#123; return myStrings; &#125; public List&lt;Float&gt; getFloats() &#123; return myFloats; &#125; public void addStrings(List&lt;String&gt; evenMoreStrings) &#123; myStrings.addAll(evenMoreStrings); &#125; &#125; myStrings 可以被 get(List Foo.myStrings) 和 get(List Foo.myStrings) 匹配。但是不能被get(List ) 匹配。myFloats 可以被 get(List Foo.myFloats) get(List ) 和 get(List *) 匹配。 getStrings() 和 getFloats() 可以被 execution(List get(..)) execution(List&lt;&gt; get(..)) 匹配。getStrings() 可以被 execution(List get(..))getFloats() 可以被 execution(List get*(..)) 注意 type variable 总会被擦除1234567891011121314 class G&lt;T&gt; &#123; List&lt;T&gt; foo(List&lt;String&gt; ls) &#123; return null; &#125; &#125;``` foo() 可以被 execution(List foo(List)), execution(List foo(List&lt;String&gt;&gt;)), and execution(* foo(List&lt;String&lt;)) 但是不能被 execution(List&lt;Object&gt; foo(List&lt;String&gt;&gt;) 匹配。因为 List&lt;T&gt; 被擦除为 List 而非 List&lt;Object&gt;###### Generic wildcards and signature matching```java class C &#123; public void foo(List&lt;? extends Number&gt; listOfSomeNumberType) &#123;&#125; public void bar(List&lt;?&gt; listOfSomeType) &#123;&#125; public void goo(List&lt;Double&gt; listOfDoubles) &#123;&#125; &#125; execution( C.(List))Matches an execution join point for any of the three methods. execution( C.(List&lt;? extends Number&gt;))matches only the execution of foo, and not the execution of goo since List&lt;? extends Number&gt; and List are distinct types. execution( C.(List&lt;?&gt;))matches only the execution of bar. execution( C.(List&lt;? extends Object+&gt;))matches both the execution of foo and the execution of bar since the upper bound of List&lt;?&gt; is implicitly Object. Treatment of bridge methodsRuntime type matching with this(), target() and args()Binding return values in after returning adviceDeclaring pointcuts inside generic typesInter-type DeclarationsDeclare ParentsDeclare SoftGeneric AspectsAutoboxing and UnboxingAutoboxing and Join Point matching in AspectJ 5基于 signatures 匹配的 pointcut 不受影响。Integer 和 int 区分表示。args 受自动封包解包影响：args(Integer) and args(int) are equivalentargs(Float) and args(float) are equivalentargs(Double) and args(double) are equivalentargs(Short) and args(short) are equivalentargs(Byte) and args(byte) are equivalentargs(Long) and args(long) are equivalentargs(Boolean) and args(boolean) are equivalent Inter-type method declarations and method dispatch根据以下算法选择调用的目标方法： 不考虑自动装包解包与可变变量调用，尝试定位匹配的方法 或 inter-type declared 方法 如果没有找到匹配，则尝试使用自动装包解包。 最后同时考虑自动装包解包与可变变量调用。 Covariance12345678class A &#123; public A whoAreYou() &#123;...&#125;&#125;class B extends A &#123; // override A.whoAreYou *and* narrow the return type. public B whoAreYou() &#123;...&#125;&#125; a.whoAreYou() signatures A A.whoAreYou()b.whoAreYou() signatures A A.whoAreYou() B B.whoAreYou() call(* whoAreYou())Matches both calls, (since each call join point has at least one matching signature). call(* A.whoAreYou())Matches both calls, (since each call join point has at least one matching signature). call(A whoAreYou())Matches both calls, (since each call join point has at least one matching signature). call(A B.whoAreYou())Does not match anything - neither of the call join points has a signature matched by this pattern. A lint warning is given for the call a.whoAreYou() (“does not match because declaring type is A, if match required use target(B)”). call(A+ B.whoAreYou())Matches the call to b.whoAreYou() since the signature pattern matches the signature B B.whoAreYou(). A lint warning is given for the call a.whoAreYou() (“does not match because declaring type is A, if match required use target(B)”). call(B A.whoAreYou())Does not match anything since neither join point has a signature matched by this pattern. call(B whoAreYou())Matches the call to b.whoAreYou() only. call(B B.whoAreYou())Matches the call to b.whoAreYou() only. VarargsUsing Variable-length arguments in advice and pointcut expressionsAspectJ 5 允许变长参数声明在 apects内部、inter-type、构造方法 。同样允许通过pointcut表达式匹配和advice绑定。 Matching signatures based on variable length argument types1234567 FormalsPattern := '..' (',' FormalsPatternAfterDotDot)? | OptionalParensTypePattern (',' FormalsPattern)* | TypePattern '...' FormalsPatternAfterDotDot := OptionalParensTypePattern (',' FormalsPatternAfterDotDot)* | TypePattern '...' 用于 call, execution, initialization, preinitialization, and withincode pointcut designators. call( org.xyz..*(int, String…))Matches a call join point for a call to a method defined in the org.xyz package, taking an int and a String vararg. execution( org.xyz..*(Integer…))Matches an execution join point for the execution of a method defined in the org.xyz package, taking an Integer vararg. initialization(org.xyz.*.new((Foo || Goo)…))Matches the initialization join point for the construction of an object in the org.xyz package via a constructor taking either a variable number of Foo parameters or a variable number of Goo parameters. (This example illustrating the use of a type pattern with …). 12void foo(String...);void bar(String[]); execution( .(String…)) 匹配 fooexecution( .(String[])) 比配 bar Exposing variable-length arguments as context in pointcuts and advice不能使用 args(int,String…)，使用args(int,String[]) 代替1234567public void foo(int i, String... strings) &#123; &#125;before(int i, String[] ss) : call(* foo(int,String...)) &amp;&amp; args(i,ss) &#123; // varargs String... argument is accessible in advice body through ss // ...&#125; Enumerated Types构造函数私有，不能被继承，隐性继承 java.lang.Enum Enumerated Types in AspectJ 5AspectJ 有额外限制:You cannot use declare parents to change the super type of an enum.You cannot use declare parents to declare java.lang.Enum as the parent of any type.You cannot make inter-type constructor declarations on an enum.You cannot extend the set of values in an enum via any ITD-like construct.You cannot make inter-type method or field declarations on an enum.You cannot use declare parents to make an enum type implement an interface. 后两个理论上可以支持。但是 AspectJ 遵循枚举类型不能作为 inter-type 声明 与 declare parents。可能在未来的版本中放开。 join point 运行时的每个方法调用都是一个不同的连接点，即使它来自程序中相同的调用表达式。 call vs. execution 1. within 和 withincode 匹配不同 call(void m()) &amp;&amp; withincode(void m()) 表示 m() 的递归调用。execution(void m()) &amp;&amp; withincode(void m()) 等效 execution(void m()) 2. call() 非静态方法的 super() 调用不会捕获执行adivce。 经验是，如果关注方法的执行，使用execution，如果关注具体方法名的调用使用call。 1.1.2 Advice1.1.3 Inter-type declarations1.1.4 Aspectsaspect 由AspectJ 初始化，不能使用Java 的 new 构造方法。默认使用单例模式，所以 aspect 中不需要使用 static 属性来共享状态。 Load-Time WeavingIntroductionAspectJ 编制把 class 文件做为输入，产出class文件作为输出。织入过程可能发生在3个不同时期：compile-time, post-compile time, and load-time。class 文件和表现的行为相同，与织入选择无关， Compile-time weaving：是最简单的方法，当你有应用源码ajc会编译产出class文件。编织调用是ajc编译的一部分。aspects，可以是源码或二进制形式。如果受影响的class在编译期需要aspect。那么你必须在编译期织入。aspects需要的情况例如：其他被编译类引用了 apsect 添加的成员。 Post-compile weaving (also sometimes called binary weaving) ：被用于编织已经存在的 class 和 JAR 文件。与 Comile-time weaving 一样。 aspects 可以是源码或二进制形式，甚至aspects本身就被其他aspects织入了。 Load-time weaving (LTW) ：只是 Post-compile weaving 延时到 classloader 加载 class 文件和定义class 文件到JVM时。为了支持这个特性，一个或多个 weaving class loaders ，在运行环境被明确提供，或需要通过 weaving agent 开启。 你可能听过 “run-time weaving” 。我们定义为，织入已经加载到JVM的 classes 文件（而且无需重新加载他们）。AspectJ 5没有提供对运行时编织的明确支持，虽然简单的编码模式可以支持动态启用和禁用方面的建议。 Weaving class files more than onceAspectJ 5 的切面和植入的 classes 默认是可以重新织入。旧版的ajc编译器需要指定-Xreweavable来支持load-time weaving。这允许AspectJ添加额外的信息到class中用于随后的重织入。 Load-time Weaving Requirementsaspectjweaver.jar 2 开发Aspects1.2.1 Trace1.2.2 打点与Log1.2.3 入参出参校验1.2.4 强制规范（如方法禁止）3 生产Aspects1.3.1 方法/属性Monitoring1.3.2 环境传递（样式）1.3.3 一致的方法行为，如异常处理1.3.4 方法开关1.3.5 alive检测","tags":[]},{"title":"AOP","date":"2017-11-25T13:21:52.000Z","path":"2017/11/25/spring-AOP/","text":"5.1.介绍面向切面编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象编程（OOP）。 OOP中模块化的关键单元是类，而AOP中模块化的单元是aspect。 Aspects可以使关注的模块化，例如跨越多种类型和对象的事务管理。 5.1.1 概念Aspect: 横切多个类的模块。 事务管理是企业Java应用程序中横切关注的一个很好的例子。 在Spring AOP中，切面可以使用类（基于xml的方法）或@Aspect注解（@AspectJ风格）标注的通用类。 Join point: 一个程序的执行，如方法的执行或异常的处理过程中的一个点。 在Spring AOP中，连接点总是代表一个方法的执行。 Advice: 在切面的一个特定采取行动的连接点。 不同类型的建议包括“周围”，“之前”和“之后”的建议。 （建议类型将在下面讨论。）许多AOP框架，包括Spring，都将建议建模为拦截器，在连接点周围维护一个拦截器链。 Pointcut: 一个匹配连接点的判断。 将Advice与Join point用表达式相关联，并在切入点匹配的任何连接点（例如，执行具有特定名称的方法）上运行。 与切入点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切入点表达式语言。 Introduction: 代表类型声明额外方法或字段。 Spring AOP允许您向任何建议的对象引入新的接口（和相应的实现）。 例如，您可以使用 introduction 来使bean实现一个IsModified接口，以简化缓存。 （在AspectJ社区中，introduction被称为一个inter-type declaration。） Target object: 对象被一个或多个方面建议。 也被称为被建议对象。 由于Spring AOP是使用运行时代理实现的，因此该对象将始终是代理对象。 AOP proxy: 一个由AOP框架创建的对象，用于实现切面合约（建议方法执行等等）。 在Spring框架中，AOP代理将是JDK动态代理或CGLIB代理。 Weaving: 链接切面与其他应用程序类型或对象，创建建议的对象。 这可以在编译时（例如使用AspectJ编译器），加载时间或运行时完成。 像其他纯Java AOP框架一样，Spring AOP在运行时执行编织。 advice 类型Before advice: 在连接点之前执行的建议，但无法阻止执行流程继续到连接点（除非抛出异常）。 After returning advice: 连接点正常完成后要执行的建议：例如，如果方法返回而不抛出异常。 After throwing advice: 如果方法通过抛出异常退出，则要执行的建议。 After (finally) advice: 无论加入点退出的方式（正常或异常退回），要执行的建议。 Around advice: 围绕连接点（如方法调用）的建议。 这是最强大的建议。 周围的建议可以在方法调用之前和之后执行自定义行为。 它还负责选择是否继续加入点，还是通过返回自己的返回值或引发异常来缩短建议的方法执行。 建议使用能够实现所需行为的功能最低的 advice 类型.pointcuts 是AOP的关键，能独立于对象继承关系来建议方法。 5.1.2 Spring AOP的功能和目标Spring AOP是用纯Java实现的。 不需要特殊的编译过程。 Spring AOP不需要控制类加载器层次结构，因此适用于Servlet容器或应用程序服务器。 Spring AOP目前仅支持方法执行连接点（建议Spring bean的方法的执行）。 虽然可以在不破坏核心Spring AOP API的情况下添加对属性拦截的支持，但没实现属性拦截。 如果您需要建议属性访问和更新连接点，请考虑使用诸如AspectJ之类的语言。 Spring AOP的AOP方法与其他大多数AOP框架不同。 目标不是提供最完整的AOP实现（尽管Spring AOP是相当有能力的）; 而是提供AOP实现和Spring IoC之间的紧密集成，以帮助解决企业应用程序中的常见问题。 因此，例如，Spring框架的AOP功能通常与Spring IoC容器一起使用。 切面使用正常的bean定义语法进行配置（尽管这允许强大的“自动代理”功能）：这是与其他AOP实现的关键区别。 有些事情你不能用Spring AOP轻松或有效地完成，比如建议非常细粒度的对象（比如域对象）：在这种情况下，AspectJ是最好的选择。 但是，我们的经验是，Spring AOP为适用于AOP的企业Java应用程序中的大多数问题提供了极好的解决方案。 Spring AOP将永远不会与AspectJ竞争提供全面的AOP解决方案。 我们认为像Spring AOP这样的基于代理的框架和像AspectJ这样的全面的框架都是有价值的，而且它们是互补的，而不是竞争。 Spring将Spring AOP和IoC与AspectJ无缝集成，以便在一致的基于Spring的应用程序体系结构中满足AOP的所有用途。 此集成不影响Spring AOP API或AOP Alliance API：Spring AOP保持向后兼容。 有关Spring AOP API的讨论，请参阅以下章节。 5.1.3 AOP代理Spring AOP 代理默认使用标准JDK动态代理。 这使得任何接口（或一组接口）都可以被代理。 Spring AOP也可以使用CGLIB代理。 这是代理 类而不是接口的必要条件。 如果业务对象没有实现接口，则默认使用CGLIB。 面向接口编程而不是类是个好习惯; 业务类通常会实现一个或多个业务接口。 可以强制使用CGLIB，在那些需要建议未在接口中声明的方法的情况下（希望很少），或者需要将代理对象作为具体类型传递给方法的情况。 掌握Spring AOP是基于代理的事实是很重要的。 请参阅了解AOP代理，以彻底检查此实现细节的实际含义。 5.2. @AspectJ supporthttps://www.eclipse.org/aspectj/ 5.2.1 @Configuration @EnableAspectJAutoProxy5.2.2 @Aspect5.2.3 @Pointcutexecution - 用于匹配方法执行的连接点，在使用Spring AOP时，你会使用的主要切入点指示符execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)modifiers-pattern 作用域ret-type-pattern 返回类型(必填) 匹配所有类型。只有当方法返回给定类型时，完全限定类型名称才会匹配。declaring-type-pattern 如果指定类型匹配，需要使用后缀 . 来加入name-pattern。 ..包及子包name-pattern 作为全部或部分方法名称param-pattern ()无参数； (..)任意参数； ()一个任意类型参数； within - 限定匹配某些路径类型的连接点 this - 限定匹配类型的连接点，常用于绑定形式。advice中可以获取 proxy 对象。 target - 限定匹配类型的连接点，常用于绑定形式。advice中可以获取 target 对象。 args - 限定匹配参数类型的连接点，常用于绑定形式。advice中可以获取 方法参数。args(java.io.Serializable) 区别 execution( (java.io.Serializable))。args，只要有参数是Serializable就匹配。execution只有一个参数且是Serializable才匹配。 @target - 限定匹配方法有指定 annotation 的连接点，常用于绑定形式。advice中可以获取 annotation 对象。 @args - 限定匹配参数有 annotation 的连接点，常用于绑定形式。advice中可以获取 annotation 对象。 @within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP) 和 @target 一样 @annotation - 限定匹配方法上有 annotation 的连接点，常用于绑定形式。advice中可以获取 annotation 对象。 bean - 仅在Spring AOP中支持 由于Spring的AOP框架的基于代理的性质，目标对象内的调用根本没有被拦截。对于JDK代理，只有代理上的公共接口方法调用才能被拦截。使用CGLIB，代理上的public和protected方法调用将被拦截，如果需要的话，甚至包package-visible方法。但是，通过代理的常见交互应始终通过 public 签名进行设计。 请注意，pointcut 定义通常与所有截取的方法匹配。如果一个切入点严格意义上的 public-only，即使在可能存在 non-public 交互 CGLIB代理场景中，需要相应地定义。 如果拦截需求包含方法调用，甚至包含目标类中的构造函数，请考虑使用Spring驱动的本机AspectJ编织，而不是Spring的基于代理的AOP框架。这构成了不同特征的AOP使用方式，所以在做出决定之前一定要先熟悉编织。 切入点表达式可以使用’&amp;&amp;’，’||’ 和’!’组合。用更小的命名组件构建更复杂的切入点表达式是一种最佳做法。 当按名称引用切入点时，将应用普通的Java可见性规则（您可以看到相同类型的私有切入点，层次结构中受保护的切入点，任何位置的公共切入点等）。 可见性不影响切入点匹配。 在使用企业应用程序时，您经常要从几个方面参考应用程序的模块和特定的一组操作。 我们建议定义一个“SystemArchitecture”方面来捕获常见的切入点表达式。 pointcuts优化，AspectJ在编译阶段会优化匹配。匹配分为静态匹配和动态匹配。动态匹配只有在代码运行阶段才能判定是否匹配。并以DNF形式进行组织排序，将开销小的评估放在前面。这意味着你无需关心pointcut的排序问题。 pointcuts分三类： kinded 选择一种特定类型的连接点。例如：execution, get, set, call, handler scoping 选择一组感兴趣的连接点（可能有多种）。例如：within, withincode context 匹配（和可选地绑定）基于上下文。 例如：this, target, @annotation一个写得好的切入点应至少包括前两种类型（kinded和scoping），如果希望基于连接点context进行匹配，则可以同事包含上下文标识符，或者将该上下文绑定以用于建议。 只提供一个指定的指示符或仅指定一个上下文指示符将会起作用，但是会由于所有额外的处理和分析而影响编织性能（使用时间和内存）。 范围标识符的匹配速度非常快，而且它们的使用方式意味着AspectJ可以很快地解除不应该进一步处理的连接点组 - 这就是为什么一个好的切入点应该总是包含一个可能的情况。 5.2.4 Declaring advice123@Before(\"execution(* com.xyz.myapp.dao.*.*(..))\")public void doAccessCheck() &#123;&#125; 12345@AfterReturning( pointcut=\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\", returning=\"retVal\")public void doAccessCheck(Object retVal) &#123;&#125; returning与advice方法中的参数类型，一起参与匹配。 12345@AfterThrowing( pointcut=\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\", throwing=\"ex\")public void doRecoveryActions(DataAccessException ex) &#123;&#125; throwing与advice方法中的参数类型，一起参与匹配。 123@After(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation()\")public void doReleaseLock() &#123;&#125; 1234567@Around(\"com.xyz.myapp.SystemArchitecture.businessService()\")public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable &#123; // start stopwatch Object retVal = pjp.proceed(); // stop stopwatch return retVal;&#125; 第一个参数必须是ProceedingJoinPoint类型。Spring AOP 于 AspectJ 的proceed参数绑定不一样。 任何Advice方法的第一个参数都可以是JoinPoint类型（@Around是子类型ProceedingJoinPoint） 1234@Before(\"com.xyz.myapp.SystemArchitecture.dataAccessO peration() &amp;&amp; args(account,..)\")public void validateAccount(Account account) &#123; // ...&#125; 1234567@Pointcut(\"com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)\")private void accountDataAccessOperation(Account account) &#123;&#125;@Before(\"accountDataAccessOperation(account)\")public void validateAccount(Account account) &#123; // ...&#125; 使用args可以绑定参数与参数类型The proxy object ( this), target object ( target), and annotations ( @within, @target, @annotation, @args) 可以用同样的方式绑定 可使用 args 限定泛型 T 类型。但不支持泛型集合Collection。你必须指定Advice中的参数为Collection&lt;?&gt;类型。然后在方法中自己判断。 123456@Before(value=\"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)\", argNames=\"bean,auditable\")public void audit(JoinPoint jp, Object bean, Auditable auditable) &#123; AuditCode code = auditable.value(); // ... use code, bean, and jp&#125; 参数名称绑定。如果有多个参数需要使用argNames来指定参数名称。旧版的java反射无法获取方法中的参数名称。如果第一个参数类型是JoinPoint, ProceedingJoinPoint, JoinPoint.StaticPart。需要跳过第一个参数名称。在jdk1.7及之前编译阶段使用 -g:vars 参数，可以不写argNames属性，可以从.class的变量表中读取参数名。在jdk1.8中编译中加 -parameters 参数。会增加额外的元信息。 1. 代码反向工程容易理解 2. class文件会略微变大 3. 删除不使用的本地变量的优化不会执行。 如果AspectJ编译器（ajc）编译了@AspectJ方面，即使没有调试信息，也不需要添加argNames属性，因为编译器会保留所需的信息。如果代码已经被编译而没有必要的调试信息，那么Spring AOP会尝试推断绑定变量与参数的配对（例如，如果在切入点表达式中只绑定了一个变量，而通知方法只有一个参数， 配对是显而易见的！）。 如果给定可用的信息，变量的绑定是不明确的，那么就会抛出一个AmbiguousBindingException异常。如果上述所有的策略都失败了，那么IllegalArgumentException将被抛出。 优先级越高，before越先执行，after越后执行。org.springframework.core.Ordered @Order 可以指定优先级，value越小优先级越高。 5.2.5 Introductions123456789101112@Aspectpublic class UsageTracking &#123; @DeclareParents(value=\"com.xzy.myapp.service.*+\", defaultImpl=DefaultUsageTracked.class) public static UsageTracked mixin; @Before(\"com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)\") public void recordUsage(UsageTracked usageTracked) &#123; usageTracked.incrementUseCount(); &#125;&#125; 5.2.6 Aspect instantiation modelsperthis - 每一个 join point 创建一个 aspectpertarget - 每一个 target 创建一个 aspectpercflow, percflowbelow, and pertypewithin 目前不支持。 5.4.1 Spring AOP or full AspectJ满足需求的情况下使用最简单的工具。如果，要 advice 非Spring容器管理的bean、属性的getset等非简单方法执行等，需要使用AspectJ。 使用 AspectJ Development Tools 倾向使用 AspectJ language syntax 定义pointcut。否则使用 @AspectJ 并定期使用Java编译，并在构建时加入weaving阶段。 5.4.2 @AspectJ or XML for Spring AOP?XML配置更集中。容易管理。但不符合DRY原则（对系统内的任何知识都应该有一个单一的，明确的，权威的表示。），xml将pointcut声明与advice实现分离。xml不能组合两个 pointcut 组合新的pointcut。 @AspectJ 支持 Aspect instantiation models 和 pointcut 组合。容易移植到 AspectJ 实现上。总的来说，Spring团队只要具有不仅仅是简单的“配置”企业服务的方面，就更喜欢@AspectJ风格。 5.6 Proxying 机制Spring AOP使用JDK动态代理或CGLIB为给定的目标对象创建代理。 （无论何时选择，JDK动态代理都是首选）。 默认，有接口或多个接口使用 JDK 代理所有接口。如果没有接口，用CGLIB代理。强制使用 CGLIB 代理： final 方法不能被重写，不能被 advise 3.2 之后包含了CGLIB jar包在 spring-core 中 4.0 之后可以绕过构造方法传参的JVM 只构造一次。否则构造两次。 proxy-target-class=”true” 在 , or 中只要有，全都生效。 5.6.1 理解 AOP 代理对 Spring 代理的方法调用。通过advice组成的拦截器之后，调用到target对象方法本身。target方法内的调用都是针对this(target对象)的调用。而不是proxy对象的调用。AopContext.currentProxy() 可以获取代理对象。AspectJ 不存在这种自我调用问题，因为AspectJ不是基于代理的AOP。 5.7. 程序创建 @AspectJ Proxies123456789101112// create a factory that can generate a proxy for the given target objectAspectJProxyFactory factory = new AspectJProxyFactory(targetObject);// add an aspect, the class must be an @AspectJ aspect// you can call this as many times as you need with different aspectsfactory.addAspect(SecurityManager.class);// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspectfactory.addAspect(usageTracker);// now get the proxy object...MyInterfaceType proxy = factory.getProxy();","tags":[]},{"title":"JSR107-缓存标准解读","date":"2017-10-23T02:58:38.000Z","path":"2017/10/23/JSR107/","text":"1.概述jsr107是本地缓存标准的API，用于创建、访问、更新、删除缓存中的数据。缓存能显著的提升，从多数据源，网络服务，高计算的性能。部分功能与分布式缓存不相适应。 1.1 JSR107目标 为应用程序提供缓存功能，特别是缓存Java对象的能力 定义一套通用的缓存概念和设施; 最大限度地减少Java开发人员需要学习采用缓存的概念数量 最大化在缓存实现之间使用缓存的应用程序的可移植性 支持进程内和分布式缓存实现 支持通过值缓存和引用缓存Java对象 根据JSR-175：Java编程语言的元数据设施定义运行时高速缓存注释; 以便使用可选提供的注释处理器的Java开发人员可以声明性地指定应用程序缓存要求; 1.2 非JSR107目标 资源和内存约束配置 - 虽然许多高速缓存实现提供了对缓存可以在运行时使用的资源量的限制的支持，但本规范并未定义如何配置或表示此功能。 然而，这个规范确定了一个标准的机制，用于开发人员指定可以使用多长时间缓存的信息。 缓存存储和拓扑 - 此规范不指定缓存实现如何存储或表示缓存的信息。 管理 - 本规范不指定缓存的管理方式。 它确定了通过Java管理扩展（JMX）以编程方式配置缓存并调查高速缓存统计信息的机制。 安全性 - 本规范不规定缓存内容如何得到保护，以及如何控制缓存中的访问和操作。 外部资源同步 - 本规范不规定应用程序或缓存实现如何使缓存和外部资源内容保持同步。 2.基础2.1核心概念 CachingProvider - 定义了建立，配置，获取，管理和控制零个或多个 CacheManager(s) 的机制。 应用程序可以在运行时访问和使用零个或多个CachingProvider。 CacheManager - 定义了在CacheManager的上下文中建立，配置，获取，管理和控制零个或多个唯一命名的 Cache(s) 的机制。 CacheManager由单个CachingProvider拥有。 Cache - 缓存是一个类似 Map 的数据结构，允许临时存储基于键的值，一些像java.util.Map数据结构一样。 缓存由单个CacheManager拥有。 Entry - 是由Cache存储的单个键值对。 ExpiryPolicy - 由缓存存储的每个条目具有定义的持续时间，称为到期时间，在此期间，可以访问，更新和删除它们。 一旦这个持续时间过去，该条目据说已过期。 一旦过期，条目将不再可用于访问，更新或删除，就像它们从不存在于缓存中一样。 Expiry使用ExpiryPolicy设置。 2.2 Cache 和 Map虽然缓存和 Map 共享一些类似的API，但缓存不是 Map 。Map 不是高速缓存。 以下部分概述了主要的相似之处和差异。 相似 通过关联的 key 存储和访问值。 每个 key 只能与缓存中的单个值相关联 如果使用可变对象作为关键字，则必须非常小心。 当 Cache 使用 key 时, 并在操作时修改了 key 的 equal 对比，则Cache的行为是未定义的。 缓存依赖相等的概念来决定，keys和values是否相同。所以key和value类应该定义合适的 Object.hashCode 的实现 不同 缓存键和值不能为空。对于键或值使用null的任何尝试将导致抛出NullPointerException，而不管使用何种。 条目可过期。 条目可驱逐。资源有限，缓存的是数据子集，超出资源大小删除条目称驱逐。驱逐策略 LRU等。 1234规范中没有定义容量的一些原因是：- 实现可以利用多层分层存储结构，并因此定义每层的容量。 在这种情况下，无法定义缓存的总体容量，这样做是不明确的。- 实现可以以字节而不是每个层上的条目计数来定义容量。- 使用的内存条目的相对成本与运行时的条目的实现的内部表示直接相关。 为了支持 compare-and-swap（CAS）操作，那些原子比较和交换值的定制值类应该提供一个适当的Object.equals实现。 实现可能需要按键和值以某种方式可序列化。 可以配置缓存，控制条目的存储方式，使用值缓存或可选地使用引用缓存。 实现可以可选地执行安全限制。 如果发生违规，则必须抛出SecurityException异常。 2.3 一致性一致性是指当多个线程访问高速缓存时，高速缓存的行为和并发缓存突变发生时存在的保证以及突变的可见性。所有实现必须支持如下所述的默认一致性模型。 2.3.1 默认一致性当使用默认一致性模式时，大多数缓存操作的执行方式就像 Cache 中每个 Key 存在锁定机制一样。当缓存操作获取对 key 的排他读写锁时，该 key 的所有后续操作将被阻塞，直到该锁被释放。结果是由线程执行的操作发生在由另一个线程执行的读取或变更操作之前，包括不同Java虚拟机中的线程。这可以被理解为一种悲观的锁定方法。锁定，变更和解锁。 对于某些缓存操作，缓存返回的值被认为是最后一个值。最后一个值可能是旧值或新值，特别是在同时更新条目的情况下。它是依赖于实现的返回。这可以被理解为没有保证一致性的无锁方法。 其他操作遵循不同的约定，因为突变可能仅在条目的当前状态与期望状态匹配时才发生。在这样的操作中，多个线程可以自由竞争来应用这些改变，就像它们共享一个锁一样。这些是： boolean putIfAbsent(K key, V value); boolean remove(K key, V oldValue); boolean replace(K key, V oldValue, V newValue); boolean replace(K key, V value); V getAndReplace(K key, V value); 这可以被理解为乐观的锁定方法; 只有当状态匹配已知状态时，才应用更改，否则失败。 这些类型的操作也称为比较和交换（CAS）操作，在CPU指令也以此方式操作。由于这些方法必须与其他缓存操作相互作用，表现就像它们具有排他锁一样.不装作拥有排它锁，CAS方法不能写入新的值。因此，在默认的一致性的情况下，CAS方法可以允许更高级别的并发性，但它们将被非CAS方法所阻止。 下表显示了适用于每个Cache方法的默认一致性： Method Default Consistency boolean containsKey(K key) last value V get(K key) happen-before Map getAll(Collection&lt;? extends K&gt; keys) happen-before for each key individually but not for the Collection. V getAndPut(K key, V value) happen-before V getAndRemove(K key) happen-before V getAndReplace(K key, V value) happen-before plus compare and swap CacheManager getCacheManager() N/A CacheConfiguration getConfiguration() N/A String getName() N/A Iterator","tags":[]},{"title":"spring 源码解析 BeanPostProcessor","date":"2017-07-21T09:35:29.000Z","path":"2017/07/21/spring-code-BeanPostProcessor/","text":"1. BeanPostProcessorBeanPostProcessor.postProcessAfterInitialization在FactoryBean单例实例化后，Bean单例实例化后，InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation返回实例后，都会调用 1.1 FactoryBean构造Bean时，调用BeanPostProcessor.postProcessAfterInitializationAbstractBeanFactory.doGetBean -&gt;AbstractBeanFactory.getObjectForBeanInstance -&gt;FactoryBeanRegistrySupport.getObjectFromFactoryBean -&gt;FactoryBeanRegistrySupport.postProcessObjectFromFactoryBean@Override AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean -&gt;AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitializationBeanPostProcessor.postProcessAfterInitialization 2. 调用InstantiationAwareBeanPostProcessor2.1 createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiationAbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation -&gt;AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation -&gt;InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation 2.2 createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation之后bean不为空之后，调用BeanPostProcessor.postProcessAfterInitializationAbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation -&gt;AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization -&gt;BeanPostProcessor.postProcessAfterInitialization 3. MergedBeanDefinitionPostProcessor3.1 doCreateBean时，createBeanInstance之后，earlySingletonExposure之前。调用MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition 进行注释融合AbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.doCreateBean -&gt;AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors -&gt;MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition 4. SmartInstantiationAwareBeanPostProcessor4.1 循环引用时，ObjectFactory.getObject获取对象时，调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference，用于提前返回引用，支持单例的循环引用AbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.doCreateBean -&gt;AbstractAutowireCapableBeanFactory.addSingletonFactory -&gt;ObjectFactory.getObject -&gt;AbstractAutowireCapableBeanFactory.getEarlyBeanReference -&gt;SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference 5. InstantiationAwareBeanPostProcessor5.1 populateBean时，在自动装配之前，调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation，用于字段注入，可停止属性填充AbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.doCreateBean -&gt;AbstractAutowireCapableBeanFactory.populateBean -&gt;InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation 6.InstantiationAwareBeanPostProcessor6.1 populateBean时，在装配之后，调用InstantiationAwareBeanPostProcessor.postProcessPropertyValues，用于Required校验，替换属性等AbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.doCreateBean -&gt;AbstractAutowireCapableBeanFactory.populateBean -&gt;InstantiationAwareBeanPostProcessor.postProcessPropertyValues 7 BeanPostProcessor7.1 initializeBean初始化时，invokeInitMethods之前。调用BeanPostProcessor.postProcessBeforeInitialization用于调用 @注释的 初始化方法等。AbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.doCreateBean -&gt;AbstractAutowireCapableBeanFactory.initializeBean -&gt;AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization -&gt;BeanPostProcessor.postProcessBeforeInitialization 7.2 initializeBean初始化时，invokeInitMethods之后。调用BeanPostProcessor.postProcessAfterInitializationAbstractBeanFactory.doGetBean -&gt;DefaultSingletonBeanRegistry.getSingleton -&gt;AbstractAutowireCapableBeanFactory.createBean -&gt;AbstractAutowireCapableBeanFactory.doCreateBean -&gt;AbstractAutowireCapableBeanFactory.initializeBean -&gt;AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization -&gt;BeanPostProcessor.postProcessAfterInitialization 8 BeanFactoryPostProcessorAbstractApplicationContext 9 BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor 在BD扫描读取之后，再扫描其他属性获取BD。9.1.ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware 扫描 @Configuration","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]},{"title":"spring 源码解析 4.BeanFactory","date":"2017-05-29T04:56:59.000Z","path":"2017/05/29/spring-code-beanfactory/","text":"1. 概述BeanFactory为Spring的IoC功能提供了基础，但它直接用于与其他第三方框架的集成，现在大部分Spring用户都具有历史性。 BeanFactory和相关接口（如BeanFactoryAware，InitializingBean，DisposableBean）仍然存在于Spring中，目的是与与Spring集成的大量第三方框架向后兼容。 通常第三方组件不能使用更现代的等同物，例如@PostConstruct或@PreDestroy，以便与JDK 1.4保持兼容，或避免依赖于JSR-250。 2. BeanDefinition2.1 类图 2.2 接口2.2.1 AttributeAccessor123456789101112131415161718192021222324252627/** * 定义一个通用规范的接口，用于附加和访问任意对象的元数据。 */public interface AttributeAccessor &#123; /** * 将&#123;@code name&#125;定义的属性设置为提供的&#123;@code 值&#125;。 如果&#123;@code 值&#125;为&#123;@code null&#125;，则属性为&#123;@link #removeAttribute removed&#125;。 * 一般来说，用户应该注意通过使用完全限定的名称防止与其他元数据属性重叠，也许使用类或包名称作为前缀。 */ void setAttribute(String name, Object value); /** * 获取由&#123;@code name&#125;标识的属性的值。 如果属性不存在，返回&#123;@code null&#125;。 */ Object getAttribute(String name); /** * 删除&#123;@code name&#125;标识的属性并返回其值。 如果找不到&#123;@code name&#125;下的属性，则返回&#123;@code null&#125;。 */ Object removeAttribute(String name); /** * 如果&#123;@code name&#125;标识的属性存在，则返回&#123;@code true&#125;。 否则返回&#123;@code false&#125;。 */ boolean hasAttribute(String name); String[] attributeNames();&#125; 2.2.2 BeanMetadataElement123456789/** * 携带配置源对象的 bean metadata 元素实现的接口。 */public interface BeanMetadataElement &#123; /** * 返回此元数据元素的配置源&#123;@code Object&#125;（可能为&#123;@code null&#125;）。 */ Object getSource();&#125; 2.2.3 BeanDefinition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179/** * BeanDefinition 描述了一个bean实例，它具有属性值，构造函数参数值以及具体实现提供的进一步信息。 * 这只是一个最小的接口：主要目的是允许&#123;@link BeanFactoryPostProcessor&#125;（如&#123;@link PropertyPlaceholderConfigurer&#125;）来内省和修改属性值和其他bean元数据。 */public interface BeanDefinition extends AttributeAccessor, BeanMetadataElement &#123; /** * 标准单例范围的范围标识符：“singleton”。 * 请注意，扩展bean工厂可能会支持更多的范围。 */ String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON; /** * 标准原型范围的范围标识：“prototype”。 * 请注意，扩展bean工厂可能会支持更多的范围。 */ String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE; /** * 角色提示，指出&#123;@code BeanDefinition&#125;是应用程序的主要部分。 通常对应于用户定义的bean。 */ int ROLE_APPLICATION = 0; /** * 角色提示，指出 &#123;@code BeanDefinition&#125; 是一些较大配置的支持部分，通常是外部&#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;。 &#123;@code SUPPORT&#125; bean被认为是重要的，以便在查看特定的&#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;时注意到，但在查看应用程序的整体配置时不会。 */ int ROLE_SUPPORT = 1; /** * 角色提示，指出&#123;@code BeanDefinition&#125;提供了完全的后台角色，与最终用户无关。 当注册完全是&#123;@link org.springframework.beans.factory.parsing.ComponentDefinition&#125;的内部工作的一部分的bean时，使用此提示。 */ int ROLE_INFRASTRUCTURE = 2; // Modifiable attributes /** * 设置此bean定义的父定义的名称（如果有）。 */ void setParentName(String parentName); /** * 返回此bean定义的父定义的名称（如果有）。 */ String getParentName(); /** * 指定此bean定义的bean类名称。 * 可以在bean工厂后处理期间修改类名称，通常用解析变量替换原始类名。 */ void setBeanClassName(String beanClassName); /** * 返回此bean定义的当前bean类名。 * 请注意，这不一定是在运行时使用的实际类名，以便子代定义从其父代替覆盖/继承类名。 * 此外，这可能只是调用的工厂方法类，或者在调用方法的工厂bean引用的情况下甚至可能为空。 * 因此，不要认为这在运行时是确定的bean类型，而是仅在单个bean定义级别使用它来解析目的。 */ String getBeanClassName(); /** * 覆盖此bean的目标范围，指定一个新的范围名称。 */ void setScope(String scope); /** * 返回此bean的当前目标范围的名称，如果尚未知道，则返回&#123;@code null&#125;。 */ String getScope(); /** * 设置这个bean是否应该被懒惰地初始化。 * 如果&#123;@code false&#125;，bean将在启动时由Bean工厂实例化，Bean工厂会执行急速初始化单例。 */ void setLazyInit(boolean lazyInit); /** * 返回这个bean是否应该被懒惰地初始化，也就是说在启动时不是急切地被实例化。 * 只适用于singleton bean。 */ boolean isLazyInit(); /** * 设置该bean依赖于初始化的bean的名称。 * bean工厂将保证这些bean首先被初始化。 */ void setDependsOn(String... dependsOn); /** * 返回该bean依赖的bean名称。 */ String[] getDependsOn(); /** * 设置这个bean是否是自动连线到其他bean的候选项。 * 请注意，此标志仅用于影响基于类类型的自动装配。 * 它不影响名称的显式引用，即使指定的bean未被标记为自动连接候选，它也将被解析。 因此，如果名称匹配，则通过名称自动装配将会注入一个bean。 */ void setAutowireCandidate(boolean autowireCandidate); /** * 返回这个bean是否是自动连线到其他bean的候选项。 */ boolean isAutowireCandidate(); /** * 设置此bean是否是主要的自动连线候选。 * 如果这个值是&#123;@code true&#125;，在多个匹配候选者中只有一个bean，则它将作为一个打破者。 */ void setPrimary(boolean primary); /** * 返回此bean是否是主要的自动装配候选。 */ boolean isPrimary(); /** * 指定要使用的工厂bean（如果有）。 * 这个为指定的工厂方法的bean的名称。 */ void setFactoryBeanName(String factoryBeanName); /** * 返回工厂bean名称，如果有的话。 */ String getFactoryBeanName(); /** * 指定工厂方法（如果有）。 * 该方法将使用构造函数参数进行调用，如果没有指定，则不使用参数。 * 该方法将在指定的工厂bean（如果有）或其他方式在本地bean类上作为静态方法调用。 */ void setFactoryMethodName(String factoryMethodName); /** * 返回工厂方法（如有）。 */ String getFactoryMethodName(); /** * 返回此bean的构造函数参数值。 * 可以在bean工厂post-processing期间修改返回的实例。 */ ConstructorArgumentValues getConstructorArgumentValues(); /** * 返回要应用于bean新实例的属性值。 * 可以在bean工厂post-processing期间修改返回的实例。 */ MutablePropertyValues getPropertyValues(); // Read-only attributes boolean isSingleton(); boolean isPrototype(); boolean isAbstract(); int getRole(); /** * 返回这个bean定义的人类可读描述。 */ String getDescription(); /** * 返回这个bean定义来源的资源的描述（为了在发生错误时显示上下文的目的）。 */ String getResourceDescription(); /** * 返回原始BeanDefinition，否则返回&#123;@code null&#125;。 * 允许检索被装饰的bean定义（如果有）。 * 请注意，此方法返回直接鼻祖。 通过鼻祖链迭代，以查找用户定义的原始BeanDefinition。 */ BeanDefinition getOriginatingBeanDefinition();&#125; 2.2.4 AnnotatedBeanDefinition123456789101112131415/** * 扩展&#123;@link org.springframework.beans.factory.config.BeanDefinition&#125;接口，暴露关于其bean类的&#123;@link org.springframework.core.type.AnnotationMetadata&#125;，而可以不需要加载该类。 */public interface AnnotatedBeanDefinition extends BeanDefinition &#123; /** * 为此bean定义的bean类获取注释元数据（以及基本类元数据）。 */ AnnotationMetadata getMetadata(); /** * 获取此bean定义的工厂方法的元数据（如果有）。 */ MethodMetadata getFactoryMethodMetadata();&#125; 2.3 实现2.3.1 AttributeAccessorSupport12345678/** * &#123;@link AttributeAccessor AttributeAccessors&#125;的支持类，提供所有方法的基本实现。 被子类扩展。 * 如果子类和所有属性值都是&#123;@link Serializable&#125;，则可以使用&#123;@link Serializable&#125;。 */@SuppressWarnings(\"serial\")public abstract class AttributeAccessorSupport implements AttributeAccessor, Serializable &#123; /** Map with String keys and Object values */ private final Map&lt;String, Object&gt; attributes = new LinkedHashMap&lt;&gt;(0); 2.3.2 BeanMetadataAttributeAccessor1234567891011121314151617181920212223242526/** * 扩展&#123;@link org.springframework.core.AttributeAccessorSupport&#125;，将属性保存为&#123;@link BeanMetadataAttribute&#125;对象，以便跟踪定义源。 */@SuppressWarnings(\"serial\")public class BeanMetadataAttributeAccessor extends AttributeAccessorSupport implements BeanMetadataElement &#123; private Object source; public void setSource(Object source) &#123; this.source = source; &#125; /** * 将给定的BeanMetadataAttribute添加到此访问器的一组属性中。 */ public void addMetadataAttribute(BeanMetadataAttribute attribute) &#123; super.setAttribute(attribute.getName(), attribute); &#125; /** * 在这个访问者的属性集中查找给定的BeanMetadataAttribute。 */ public BeanMetadataAttribute getMetadataAttribute(String name) &#123; return (BeanMetadataAttribute) super.getAttribute(name); &#125;&#125; 123456789/** * 持有键值样式属性，是bean定义的一部分。 * 保留键值对之外的跟踪定义源。 */public class BeanMetadataAttribute implements BeanMetadataElement &#123; private final String name; private final Object value; private Object source;&#125; 2.3.3 AbstractBeanDefinition123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132/** * 具体的，完整的&#123;@link BeanDefinition&#125;类的基类，分为&#123;@link GenericBeanDefinition&#125;，&#123;@link RootBeanDefinition&#125;和&#123;@link ChildBeanDefinition&#125;的常用属性。 * * autowire常量与&#123;@link org.springframework.beans.factory.config.AutowireCapableBeanFactory&#125;接口中定义的常量相匹配。 */@SuppressWarnings(\"serial\")public abstract class AbstractBeanDefinition extends BeanMetadataAttributeAccessor implements BeanDefinition, Cloneable &#123; /** * 默认范围名称的常量：&#123;@code \"\"&#125;，相当于单例状态，除非从父bean定义（如果适用）覆盖。 */ public static final String SCOPE_DEFAULT = \"\"; public static final int AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO; public static final int AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME; public static final int AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE; public static final int AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR; @Deprecated public static final int AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT; /** * 根本没有依赖关系。 */ public static final int DEPENDENCY_CHECK_NONE = 0; /** * 对象引用的依赖关系检查。 */ public static final int DEPENDENCY_CHECK_OBJECTS = 1; /** * 依赖关系检查“简单”属性。 */ public static final int DEPENDENCY_CHECK_SIMPLE = 2; /** * 所有属性的依赖关系检查 */ public static final int DEPENDENCY_CHECK_ALL = 3; /** * 常量，表示容器应尝试推断出一个bean的 &#123;@link #setDestroyMethodName destroy method name&#125;，而不是显式指定方法名称。 值&#123;@value&#125;专门设计为在方法名称中包括非法的字符，确保不会与具有相同名称的合法命名方法发生冲突。 * 目前，在destroy方法推断中检测到的方法名称是“close”和“shutdown”，如果存在于特定的bean类上。 */ public static final String INFER_METHOD = \"(inferred)\"; private volatile Object beanClass; private String scope = SCOPE_DEFAULT; private boolean abstractFlag = false; private boolean lazyInit = false; private int autowireMode = AUTOWIRE_NO; private int dependencyCheck = DEPENDENCY_CHECK_NONE; /** * 该bean依赖于初始化的bean的名称。 bean工厂将保证这些bean首先被初始化。 * 请注意，依赖关系通常通过bean属性或构造函数参数来表示。 对于其他类型的依赖关系（* ugh *）或启动时的数据库准备，此属性应该是必需的。 */ private String[] dependsOn; /** * 设置这个bean是否是自动连线到其他bean的候选。 * 请注意，此标志仅用于影响基于类型的自动装配。 它不会影响名称的显式引用，即使指定的bean未标记为自动连接候选，也将得到解析。 因此，如果名称匹配，则通过名称自动装配将会注入一个bean。 */ private boolean autowireCandidate = true; private boolean primary = false; /** * 限定符，用于自动装配候选解决，由限定的类型名称作为key 。 */ private final Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = new LinkedHashMap&lt;&gt;(0); /** * 指定用于创建bean实例的回调，作为声明性指定的工厂方法的替代方法。 * 如果设置了这样的回调，它将覆盖任何其他构造函数或工厂方法元数据。 * 然而，bean属性和潜在注释驱动的注射仍然照常使用。 */ private Supplier&lt;?&gt; instanceSupplier; /** * 指定是否允许访问非公共构造函数和方法，对于指向这些的外部化元数据的情况。 默认值为&#123;@code true&#125;; 将其切换到&#123;@code false&#125;以允许进行公共访问。 * 这适用于构造函数解析，工厂方法解析以及init / destroy方法。 * Bean属性访问器在任何情况下都必须公开，不受此设置的影响。 * 请注意，注释驱动的配置仍将访问非公开成员，只要它们已被注释。 此设置仅适用于此bean定义中的外部化元数据。 */ private boolean nonPublicAccessAllowed = true; /** * 指定是否以宽松模式（&#123;@code true&#125;（默认值为））解析构造函数，或者切换到严格解析 * （如果在转换参数时模糊匹配所有的构造函数时抛出异常，而宽大模式将使用 一个与“最接近”类型匹配）。 */ private boolean lenientConstructorResolution = true; private String factoryBeanName; /** * 指定工厂方法（如果有）。 该方法将使用构造函数参数进行调用，如果没有指定，则不使用参数。 * 该方法将在指定的工厂bean（如果有）否则在本地bean类上作为静态方法调用。 */ private String factoryMethodName; private ConstructorArgumentValues constructorArgumentValues; private MutablePropertyValues propertyValues; private MethodOverrides methodOverrides = new MethodOverrides(); private String initMethodName; private String destroyMethodName; private boolean enforceInitMethod = true; private boolean enforceDestroyMethod = true; /** * 设置此bean定义是否为“合成”，即不由应用程序本身定义（例如，通过&#123;@code &lt;aop：config&gt;&#125;创建的基础架构bean，例如自动代理的帮助器）。 */ private boolean synthetic = false; private int role = BeanDefinition.ROLE_APPLICATION; private String description; /** * 这个bean定义来自的资源。 */ private Resource resource;&#125; 12345678910/** * 确定自动装配候选人的资格。 包含一个或多个此类限定符的bean定义可以对字段或参数上的注释进行精细匹配以进行自动装配。 */public class AutowireCandidateQualifier extends BeanMetadataAttributeAccessor &#123; /** * 将value存在 key 是 VALUE_KEY 的 BeanMetadataAttributeAccessor抽象实现中 */ public static String VALUE_KEY = \"value\"; private final String typeName;&#125; 1234567/** * &#123;@link org.springframework.beans.factory.config.BeanDefinition&#125;的描述性&#123;@link org.springframework.core.io.Resource&#125;包装器。 */class BeanDefinitionResource extends AbstractResource &#123; private final BeanDefinition beanDefinition;&#125; 1234567891011121314151617181920212223/** * 构造函数参数值的持有者，通常作为bean定义的一部分。 * 支持构造函数参数列表中特定索引的值以及类型中的泛型参数匹配。 */public class ConstructorArgumentValues &#123; private final Map&lt;Integer, ValueHolder&gt; indexedArgumentValues = new LinkedHashMap&lt;&gt;(0); private final List&lt;ValueHolder&gt; genericArgumentValues = new LinkedList&lt;&gt;(); /** * Holder for a constructor argument value, with an optional type * attribute indicating the target type of the actual constructor argument. * * 构造函数参数值的持有者，可选的type属性指示实际构造函数参数的目标类型。 */ public static class ValueHolder implements BeanMetadataElement &#123; private Object value; private String type; private String name; private Object source; private boolean converted = false; private Object convertedValue; &#125;&#125; 12345678910/** * &#123;@link PropertyValues&#125;接口的默认实现。 * 允许对属性进行简单的操作，并提供构造函数以支持从Map的深层复制和构造。 */@SuppressWarnings(\"serial\")public class MutablePropertyValues implements PropertyValues, Serializable &#123; private final List&lt;PropertyValue&gt; propertyValueList; private Set&lt;String&gt; processedProperties; private volatile boolean converted = false;&#125; 1234567891011121314/** * 包含一个或多个&#123;@link PropertyValue&#125;对象的Holder，通常包含特定目标bean的一个更新。 */public interface PropertyValues &#123; PropertyValue[] getPropertyValues(); PropertyValue getPropertyValue(String propertyName); /** * 返回自上一个PropertyValues之后的更改。 子类也应该覆盖&#123;@code equals&#125;。 */ PropertyValues changesSince(PropertyValues old); boolean contains(String propertyName); boolean isEmpty();&#125; 12345678910111213141516/** * 对象保存单个bean属性的信息和值。 在这里使用一个对象，而不仅仅是将所有属性存储在按属性名称键入的 map 中，这样可以更有弹性，并以优化的方式处理索引属性等。 * 请注意，该值不需要是最终必需的类型：&#123;@link BeanWrapper&#125;实现应该处理任何必要的转换，因为该对象不知道将要应用的对象的任何内容。 */@SuppressWarnings(\"serial\")public class PropertyValue extends BeanMetadataAttributeAccessor implements Serializable &#123; private final String name; private final Object value; private boolean optional = false; private boolean converted = false; private Object convertedValue; /** Package-visible field that indicates whether conversion is necessary */ volatile Boolean conversionNecessary; /** Package-visible field for caching the resolved property path tokens */ transient volatile Object resolvedTokens;&#125; 12345678910/** * &#123;@code BeanDefinition&#125;属性的简单持有人默认。 */public class BeanDefinitionDefaults &#123; private boolean lazyInit; private int dependencyCheck = AbstractBeanDefinition.DEPENDENCY_CHECK_NONE; private int autowireMode = AbstractBeanDefinition.AUTOWIRE_NO; private String initMethodName; private String destroyMethodName;&#125; 2.3.4 RootBeanDefinition1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889/** * 根bean定义代表在运行时在Spring BeanFactory中备份特定bean的合并的bean定义。 * 它可能已经从多个相互继承原始bean定义创建，通常以&#123;@link GenericBeanDefinition GenericBeanDefinitions&#125;的形式进行创建。 * 根bean定义本质上是运行时的“统一”bean定义视图。 * * 根bean定义也可用于在配置阶段注册各个bean定义。 * 但是，从Spring 2.5，以编程方式注册bean定义的首选方式是&#123;@link GenericBeanDefinition&#125;类。 * GenericBeanDefinition 的优点是允许动态定义父依赖关系，而不是将角色“硬编码”为根bean定义。 * * @author Rod Johnson * @author Juergen Hoeller * @see GenericBeanDefinition * @see ChildBeanDefinition */@SuppressWarnings(\"serial\")public class RootBeanDefinition extends AbstractBeanDefinition &#123; private BeanDefinitionHolder decoratedDefinition; /** * 指定&#123;@link AnnotatedElement&#125;定义限定符，而不是目标类或工厂方法。 */ private AnnotatedElement qualifiedElement; boolean allowCaching = true; boolean isFactoryMethodUnique = false; /** * 如果事先知道，请指定此bean定义的含有泛型的目标类型。 */ volatile ResolvableType targetType; /** Package-visible field for caching the determined Class of a given bean definition * 缓存给定bean定义的确定类 * */ volatile Class&lt;?&gt; resolvedTargetType; /** Package-visible field for caching the return type of a generically typed factory method * 缓存返回类型的一般类型的工厂方法 * */ volatile ResolvableType factoryMethodReturnType; /** Common lock for the four constructor fields below * 以下四个构造函数字段的通用锁 * */ final Object constructorArgumentLock = new Object(); /** Package-visible field for caching the resolved constructor or factory method * 缓存已解决的构造函数或工厂方法 * */ Executable resolvedConstructorOrFactoryMethod; /** Package-visible field that marks the constructor arguments as resolved * 将构造函数的参数标记为已解决 * */ boolean constructorArgumentsResolved = false; /** Package-visible field for caching fully resolved constructor arguments * 缓存完全解析的构造函数参数 * */ Object[] resolvedConstructorArguments; /** Package-visible field for caching partly prepared constructor arguments * 缓存部分准备的构造函数参数 * */ Object[] preparedConstructorArguments; /** Common lock for the two post-processing fields below * 以下两个后处理字段的通用锁 * */ final Object postProcessingLock = new Object(); /** Package-visible field that indicates MergedBeanDefinitionPostProcessor having been applied * 表示已应用MergedBeanDefinitionPostProcessor * */ boolean postProcessed = false; /** Package-visible field that indicates a before-instantiation post-processor having kicked in * 表示已经一个实例化后处理器已经触发 * */ volatile Boolean beforeInstantiationResolved; private Set&lt;Member&gt; externallyManagedConfigMembers; private Set&lt;String&gt; externallyManagedInitMethods; private Set&lt;String&gt; externallyManagedDestroyMethods;&#125; 2.3.5 RootBeanDefinition1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586/** * 根bean定义代表融合的bean定义，运行时在Spring BeanFactory中备份特定bean的。 * 它可能已经从多个相互继承原始bean定义创建，通常以&#123;@link GenericBeanDefinition GenericBeanDefinitions&#125;的形式进行创建。 * 根bean定义本质上是运行时的“统一”bean定义视图。 * * 根bean定义也可用于在配置阶段注册各个bean定义。 * 但是，从Spring 2.5，以编程方式注册bean定义的首选方式是&#123;@link GenericBeanDefinition&#125;类。 * GenericBeanDefinition 的优点是允许动态定义父依赖关系，而不是将角色“硬编码”为根bean定义。 */@SuppressWarnings(\"serial\")public class RootBeanDefinition extends AbstractBeanDefinition &#123; private BeanDefinitionHolder decoratedDefinition; /** * 指定&#123;@link AnnotatedElement&#125;定义限定符，而不是目标类或工厂方法。 */ private AnnotatedElement qualifiedElement; boolean allowCaching = true; boolean isFactoryMethodUnique = false; /** * 如果事先知道，请指定此bean定义的含有泛型的目标类型。 */ volatile ResolvableType targetType; /** * 缓存给定bean定义的确定类 */ volatile Class&lt;?&gt; resolvedTargetType; /** * 缓存返回类型的一般类型的工厂方法 */ volatile ResolvableType factoryMethodReturnType; /** * 以下四个构造函数字段的通用锁 */ final Object constructorArgumentLock = new Object(); /** * 缓存已解析的构造函数或工厂方法 */ Executable resolvedConstructorOrFactoryMethod; /** * 将构造函数的参数标记为已解决 */ boolean constructorArgumentsResolved = false; /** * 缓存完全解析的构造函数参数 */ Object[] resolvedConstructorArguments; /** * 缓存部分准备的构造函数参数 */ Object[] preparedConstructorArguments; /** * 以下两个后处理字段的通用锁 */ final Object postProcessingLock = new Object(); /** * 表示已应用MergedBeanDefinitionPostProcessor */ boolean postProcessed = false; /** * Package-visible field that indicates a before-instantiation post-processor having kicked in * 表示已经一个实例化后处理器已经触发 */ volatile Boolean beforeInstantiationResolved; private Set&lt;Member&gt; externallyManagedConfigMembers; private Set&lt;String&gt; externallyManagedInitMethods; private Set&lt;String&gt; externallyManagedDestroyMethods;&#125; 2.3.6 GenericBeanDefinition123456789101112131415161718192021222324252627282930/** * GenericBeanDefinition is a one-stop shop for standard bean definition purposes. * Like any bean definition, it allows for specifying a class plus optionally * constructor argument values and property values. Additionally, deriving from a * parent bean definition can be flexibly configured through the \"parentName\" property. * * &lt;p&gt;In general, use this &#123;@code GenericBeanDefinition&#125; class for the purpose of * registering user-visible bean definitions (which a post-processor might operate on, * potentially even reconfiguring the parent name). Use &#123;@code RootBeanDefinition&#125; / * &#123;@code ChildBeanDefinition&#125; where parent/child relationships happen to be pre-determined. * * GenericBeanDefinition是标准bean定义的一站式服务。 * 像任何bean定义一样，它允许指定一个类加上可选的构造函数参数值和属性值。 * 另外，可以通过“parentName”属性灵活地配置从父bean定义的派生。 * * 一般来说，使用这个&#123;@code GenericBeanDefinition&#125;类用于注册用户可见bean定义（后处理器可能操作bean定义，甚至可能重新配置父名称）。 * 使用&#123;@code RootBeanDefinition&#125; / &#123;@code ChildBeanDefinition&#125;，其中父/子关系恰好是预先确定的。 * * @author Juergen Hoeller * @since 2.5 * @see #setParentName * @see RootBeanDefinition * @see ChildBeanDefinition */@SuppressWarnings(\"serial\")public class GenericBeanDefinition extends AbstractBeanDefinition &#123; private String parentName;&#125; 2.3.7 ChildBeanDefinition1234567891011121314/** * 继承自父项设置的Bean的Bean定义。 子bean定义与父bean定义有固定的依赖关系。 * * 子bean定义将从父级继承构造函数参数值，属性值和方法覆盖，并添加新值。 * 如果指定了init方法，destroy方法和/或静态工厂方法，它们将覆盖相应的父设置。 * 剩余的设置将始终从子定义中取出：depends on, autowire mode, dependency check, singleton, lazy init。 * * 注意： 由于Spring 2.5，以编程方式注册bean定义的首选方式是&#123;@link GenericBeanDefinition&#125;类，它允许通过&#123;@link GenericBeanDefinition＃setParentName&#125;动态定义父依赖关系， 方法。 * 这有效地取代了大多数用例中的ChildBeanDefinition类。 */public class ChildBeanDefinition extends AbstractBeanDefinition &#123; private String parentName;&#125; 2.3.8 ScannedGenericBeanDefinition1234567/** * 扩展&#123;@link org.springframework.beans.factory.support.GenericBeanDefinition&#125;类，基于ASM ClassReader，支持通过&#123;@link AnnotatedBeanDefinition&#125;接口暴露注释元数据。 * 此类不提早加载bean &#123;@code Class&#125;。 它相当于从“.class”文件本身检索所有相关的元数据，并与ASM ClassReader解析。 它在功能上等同于&#123;@link AnnotatedGenericBeanDefinition#AnnotatedGenericBeanDefinition(AnnotationMetadata)&#125;，但是区分已被扫描的类型bean与以其他方式注册或检测到的那些类型。 */public class ScannedGenericBeanDefinition extends GenericBeanDefinition implements AnnotatedBeanDefinition &#123; private final AnnotationMetadata metadata;&#125; 2.3.9 AnnotatedGenericBeanDefinition123456789101112/** * 扩展&#123;@link org.springframework.beans.factory.support.GenericBeanDefinition&#125;类，添加了通过&#123;@link AnnotatedBeanDefinition&#125;接口暴露注释元数据的支持。 * * 此GenericBeanDefinition变体主要用于测试期望在AnnotatedBeanDefinition上操作的代码，例如Spring组件扫描支持中的策略实现（默认定义类为&#123;@link org.springframework.context.annotation.ScannedGenericBeanDefinition&#125; ，它还实现了AnnotatedBeanDefinition接口）。 */@SuppressWarnings(\"serial\")public class AnnotatedGenericBeanDefinition extends GenericBeanDefinition implements AnnotatedBeanDefinition &#123; private final AnnotationMetadata metadata; private MethodMetadata factoryMethodMetadata;&#125; 3.BeanDefinitionReader3.1 类图3.2 接口3.2.1 BeanDefinitionReader1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 用于bean定义阅读器的简单接口。 * 指定具有 Resource 和 String 位置参数的加载方法。 * * 具体的bean定义读取器当然可以为bean定义添加额外的加载和注册方法，特定于它们的bean定义格式。 * 请注意，bean定义阅读器不必实现此接口。 它仅作为要遵循标准命名约定的bean定义阅读器的建议。 */public interface BeanDefinitionReader &#123; /** * 返回bean工厂注册bean定义。 * 工厂通过BeanDefinitionRegistry接口暴露，封装了与bean定义处理相关的方法。 */ BeanDefinitionRegistry getRegistry(); ResourceLoader getResourceLoader(); /** * 返回类加载器以用于bean类。 * &#123;@code null&#125;建议不要热切地加载bean类，而是仅仅使用类名注册bean定义，相应的类将在稍后（或从不）解析。 */ ClassLoader getBeanClassLoader(); /** * 返回BeanNameGenerator用于匿名bean（未指定明确的bean名称）。 */ BeanNameGenerator getBeanNameGenerator(); /** * 从指定的资源中加载bean定义。 */ int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException; int loadBeanDefinitions(Resource... resources) throws BeanDefinitionStoreException; /** * 从指定的资源位置加载bean定义。 * 该位置也可以是一个位置模式，前提是该bean定义阅读器的ResourceLoader是ResourcePatternResolver。 */ int loadBeanDefinitions(String location) throws BeanDefinitionStoreException; int loadBeanDefinitions(String... locations) throws BeanDefinitionStoreException;&#125; 3.2.2 AbstractBeanDefinitionReader12345678910111213141516171819/** * 实现&#123;@link BeanDefinitionReader&#125;接口的bean定义阅读器的抽象基类。 * 提供常见的属性，如bean工厂工作，类加载器用于加载bean类。 */public abstract class AbstractBeanDefinitionReader implements EnvironmentCapable, BeanDefinitionReader &#123; /** Logger available to subclasses */ protected final Log logger = LogFactory.getLog(getClass()); private final BeanDefinitionRegistry registry; private ResourceLoader resourceLoader; private ClassLoader beanClassLoader; private Environment environment; private BeanNameGenerator beanNameGenerator = new DefaultBeanNameGenerator();&#125; 12345678910111213141516171819/** * 用于保存bean定义的注册表的接口，例如RootBeanDefinition和ChildBeanDefinition实例。 通常由BeanFactories实现，内部使用AbstractBeanDefinition层次结构。 * 这是Spring的bean工厂包中唯一封装Bean定义注册的接口。 标准BeanFactory接口仅涵盖对完全配置的工厂实例的访问。 * Spring的bean定义阅读器期望在此接口的实现上工作。 Spring内核中的已知实现者是DefaultListableBeanFactory和GenericApplicationContext。 */public interface BeanDefinitionRegistry extends AliasRegistry &#123; /** * 使用此注册表注册新的bean定义。 * 必须支持RootBeanDefinition和ChildBeanDefinition。 */ void registerBeanDefinition(String beanName, BeanDefinition beanDefinition) throws BeanDefinitionStoreException; void removeBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; BeanDefinition getBeanDefinition(String beanName) throws NoSuchBeanDefinitionException; boolean containsBeanDefinition(String beanName); String[] getBeanDefinitionNames(); int getBeanDefinitionCount(); boolean isBeanNameInUse(String beanName);&#125; 3.2.3 BeanDefinitionDocumentReader1234567891011121314/** * SPI用于解析包含Spring bean定义的XML文档。 由&#123;@link XmlBeanDefinitionReader&#125;用于实际解析DOM文档。 * * 为每个文档实例化来解析：在执行&#123;@code registerBeanDefinitions&#125;方法时，实现可以在实例变量中保留状态; 例如，为文档中的所有bean定义定义的全局设置。 */public interface BeanDefinitionDocumentReader &#123; /** * 从给定的DOM文档中读取bean定义，并在给定的阅读器上下文中注册它们。 */ void registerBeanDefinitions(Document doc, XmlReaderContext readerContext) throws BeanDefinitionStoreException;&#125; 3.3 实现3.3.1 XmlBeanDefinitionReader123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223/** * 用于XML bean定义的Bean定义阅读器。 * 将实际的XML文档读取委托给&#123;@link BeanDefinitionDocumentReader&#125;接口的实现。 * * 通常应用于&#123;@link org.springframework.beans.factory.support.DefaultListableBeanFactory&#125;或&#123;@link org.springframework.context.support.GenericApplicationContext&#125;。 * * 此类加载DOM文档并将BeanDefinitionDocumentReader应用于该文档。 文档读取器将向给定的bean工厂注册每个bean定义，并与后者的&#123;@link org.springframework.beans.factory.support.BeanDefinitionRegistry&#125;接口的实现进行交互。 */public class XmlBeanDefinitionReader extends AbstractBeanDefinitionReader &#123; public static final int VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE; public static final int VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO; public static final int VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD; public static final int VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD; /** * Constants instance for this class * 此类可用于解析其他类包含定义的 public static final 成员常量 */ private static final Constants constants = new Constants(XmlBeanDefinitionReader.class); private int validationMode = VALIDATION_AUTO; private boolean namespaceAware = false; /** * 负责实际阅读XML bean定义文档的类。 * 为每个文档实例化来解析 */ private Class&lt;?&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.class; /** * 默认实现是&#123;@link org.springframework.beans.factory.parsing.FailFastProblemReporter&#125;，表现出快速行为的失败。 外部工具可以提供一个替代实现，整理错误和警告以在工具UI中显示。 */ private ProblemReporter problemReporter = new FailFastProblemReporter(); /** * EmptyReaderEventListener它丢弃每个事件通知。 外部工具可以提供一个替代实现来监视在BeanFactory中注册的组件。 */ private ReaderEventListener eventListener = new EmptyReaderEventListener(); /** * 默认实现是&#123;@link NullSourceExtractor&#125;，它只返回&#123;@code null&#125;作为源对象。 这意味着 - 在正常运行时执行期间 - 没有额外的源元数据附加到bean配置元数据。 */ private SourceExtractor sourceExtractor = new NullSourceExtractor(); /** * 如果没有指定，将通过 &#123;@link #createDefaultNamespaceHandlerResolver()&#125; 创建一个 DefaultNamespaceHandlerResolver 默认实例。 */ private NamespaceHandlerResolver namespaceHandlerResolver; /** * 使用JAXP加载&#123;@link Document&#125;实例的&#123;@link DefaultDocumentLoader&#125;。 */ private DocumentLoader documentLoader = new DefaultDocumentLoader(); /** * 默认情况下，将使用&#123;@link ResourceEntityResolver&#125;。 可以被自定义实体解析覆盖，例如相对于某些特定的基本路径。 * 用于解决 xsd dtd 资源的网络加载问题 */ private EntityResolver entityResolver; /** * &#123;@code org.xml.sax.ErrorHandler&#125;接口的实现，以便自定义处理XML解析错误和警告。 * 如果未设置，则使用默认的SimpleSaxErrorHandler，它仅使用视图类的记录器实例记录警告，并重新创建错误以停止XML转换。 */ private ErrorHandler errorHandler = new SimpleSaxErrorHandler(logger); /** * 检测XML流是否使用基于DTD或XSD的验证。 */ private final XmlValidationModeDetector validationModeDetector = new XmlValidationModeDetector(); private final ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded = new NamedThreadLocal&lt;&gt;(\"XML bean definition resources currently being loaded\"); @Override public int loadBeanDefinitions(Resource resource) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(new EncodedResource(resource)); &#125; public int loadBeanDefinitions(EncodedResource encodedResource) throws BeanDefinitionStoreException &#123; Assert.notNull(encodedResource, \"EncodedResource must not be null\"); if (logger.isInfoEnabled()) &#123; logger.info(\"Loading XML bean definitions from \" + encodedResource.getResource()); &#125; Set&lt;EncodedResource&gt; currentResources = this.resourcesCurrentlyBeingLoaded.get(); if (currentResources == null) &#123; currentResources = new HashSet&lt;&gt;(4); this.resourcesCurrentlyBeingLoaded.set(currentResources); &#125; if (!currentResources.add(encodedResource)) &#123; throw new BeanDefinitionStoreException( \"Detected cyclic loading of \" + encodedResource + \" - check your import definitions!\"); &#125; try &#123; InputStream inputStream = encodedResource.getResource().getInputStream(); try &#123; InputSource inputSource = new InputSource(inputStream); if (encodedResource.getEncoding() != null) &#123; inputSource.setEncoding(encodedResource.getEncoding()); &#125; return doLoadBeanDefinitions(inputSource, encodedResource.getResource()); &#125; finally &#123; inputStream.close(); &#125; &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException( \"IOException parsing XML document from \" + encodedResource.getResource(), ex); &#125; finally &#123; currentResources.remove(encodedResource); if (currentResources.isEmpty()) &#123; this.resourcesCurrentlyBeingLoaded.remove(); &#125; &#125; &#125; public int loadBeanDefinitions(InputSource inputSource) throws BeanDefinitionStoreException &#123; return loadBeanDefinitions(inputSource, \"resource loaded through SAX InputSource\"); &#125; public int loadBeanDefinitions(InputSource inputSource, String resourceDescription) throws BeanDefinitionStoreException &#123; return doLoadBeanDefinitions(inputSource, new DescriptiveResource(resourceDescription)); &#125; /** * Actually load bean definitions from the specified XML file. * @param inputSource the SAX InputSource to read from * @param resource the resource descriptor for the XML file * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of loading or parsing errors * @see #doLoadDocument * @see #registerBeanDefinitions */ protected int doLoadBeanDefinitions(InputSource inputSource, Resource resource) throws BeanDefinitionStoreException &#123; try &#123; Document doc = doLoadDocument(inputSource, resource); return registerBeanDefinitions(doc, resource); &#125; catch (BeanDefinitionStoreException ex) &#123; throw ex; &#125; catch (SAXParseException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"Line \" + ex.getLineNumber() + \" in XML document from \" + resource + \" is invalid\", ex); &#125; catch (SAXException ex) &#123; throw new XmlBeanDefinitionStoreException(resource.getDescription(), \"XML document from \" + resource + \" is invalid\", ex); &#125; catch (ParserConfigurationException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"Parser configuration exception parsing XML from \" + resource, ex); &#125; catch (IOException ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"IOException parsing XML document from \" + resource, ex); &#125; catch (Throwable ex) &#123; throw new BeanDefinitionStoreException(resource.getDescription(), \"Unexpected exception parsing XML document from \" + resource, ex); &#125; &#125; /** * Actually load the specified document using the configured DocumentLoader. * 实际上使用配置的DocumentLoader加载指定的文档 */ protected Document doLoadDocument(InputSource inputSource, Resource resource) throws Exception &#123; return this.documentLoader.loadDocument(inputSource, getEntityResolver(), this.errorHandler, getValidationModeForResource(resource), isNamespaceAware()); &#125; /** * Register the bean definitions contained in the given DOM document. * Called by &#123;@code loadBeanDefinitions&#125;. * &lt;p&gt;Creates a new instance of the parser class and invokes * &#123;@code registerBeanDefinitions&#125; on it. * * 注册给定的DOM文档中包含的bean定义。 由&#123;@code loadBeanDefinitions&#125;调用。 * 创建解析器类的新实例，并调用&#123;@code registerBeanDefinitions&#125;。 * * @param doc the DOM document * @param resource the resource descriptor (for context information) * @return the number of bean definitions found * @throws BeanDefinitionStoreException in case of parsing errors * @see #loadBeanDefinitions * @see #setDocumentReaderClass * @see BeanDefinitionDocumentReader#registerBeanDefinitions */ public int registerBeanDefinitions(Document doc, Resource resource) throws BeanDefinitionStoreException &#123; BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader(); int countBefore = getRegistry().getBeanDefinitionCount(); documentReader.registerBeanDefinitions(doc, createReaderContext(resource)); return getRegistry().getBeanDefinitionCount() - countBefore; &#125; /** * Create the &#123;@link BeanDefinitionDocumentReader&#125; to use for actually * reading bean definitions from an XML document. * &lt;p&gt;The default implementation instantiates the specified \"documentReaderClass\". * @see #setDocumentReaderClass */ protected BeanDefinitionDocumentReader createBeanDefinitionDocumentReader() &#123; return BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(this.documentReaderClass)); &#125; /** * Create the &#123;@link XmlReaderContext&#125; to pass over to the document reader. */ public XmlReaderContext createReaderContext(Resource resource) &#123; return new XmlReaderContext(resource, this.problemReporter, this.eventListener, this.sourceExtractor, this, getNamespaceHandlerResolver()); &#125;&#125; 3.3.2 DefaultBeanDefinitionDocumentReader","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]},{"title":"spring 源码解析 4.环境与属性解析","date":"2017-05-18T02:26:12.000Z","path":"2017/05/18/spring-code-propertyresolver/","text":"1.概述Environment 是集成在容器中的抽象，用于模拟应用程序环境的两个关键方面：配置文件和属性。 只有给定的配置文件处于活动状态，配置文件才是要向容器注册的一个命名逻辑组的bean定义。 Bean 可以被分配到不管是以XML定义还是通过注释的配置文件。 环境对象与配置文件的关系在于确定哪些配置文件（如果有）当前处于活动状态，哪些配置文件（如果有的话）默认情况下应该处于活动状态。 属性在几乎所有应用程序中起着重要作用，可能来自各种来源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc属性对象，Maps等。 环境对象与属性关系的作用是为用户提供方便的服务接口，用于配置属性源并从中解析属性。 2. PropertyResolver 2.1 属性解析接口2.1.1 PropertyResolver12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152/** * 用于解析任何基础源的属性的接口。 */public interface PropertyResolver &#123; /** * 返回给定的属性键是否可用于解析，即如果给定键的值不是&#123;@code null&#125;。 */ boolean containsProperty(String key); /** * 返回与给定 key 相关联的属性值，如果 key 无法解析，则返回&#123;@code null&#125;。 */ String getProperty(String key); /** * 返回与给定键相关联的属性值，如果键无法解析，则返回&#123;@code defaultValue&#125;。 */ String getProperty(String key, String defaultValue); /** * 返回与给定键相关联的属性值，如果键无法解析，则返回&#123;@code null&#125;。 */ &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType); /** * 返回与给定键相关联的属性值，如果键无法解析，则返回&#123;@code defaultValue&#125;。 */ &lt;T&gt; T getProperty(String key, Class&lt;T&gt; targetType, T defaultValue); /** * 返回与给定键相关联的属性值（从不&#123;@code null&#125;）。 */ String getRequiredProperty(String key) throws IllegalStateException; /** * 返回与给定键相关联的属性值，转换为给定的targetType（从不&#123;@code null&#125;）。 */ &lt;T&gt; T getRequiredProperty(String key, Class&lt;T&gt; targetType) throws IllegalStateException; /** * 解析给定文本中的 $&#123;...&#125; 占位符，用&#123;@link #getProperty&#125;解析的相应属性值替换它们。 * 没有默认值的未解决的占位符将被忽略并通过不变。 */ String resolvePlaceholders(String text); /** * 解析给定文本中的 $&#123;...&#125; 占位符，用&#123;@link #getProperty&#125;解析的相应属性值替换它们。没有默认值的不可解决的占位符将导致抛出IllegalArgumentException。 */ String resolveRequiredPlaceholders(String text) throws IllegalArgumentException;&#125; 2.1.2ConfigurablePropertyResolver1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 配置接口大多数（如果不是全部）由 &#123;@link PropertyResolver&#125; 类型实现。 * 提供访问和自定义将属性值从一种类型转换为另一种时使用的&#123;@link org.springframework.core.convert.ConversionService ConversionService&#125;的功能。 */public interface ConfigurablePropertyResolver extends PropertyResolver &#123; /** * 返回在属性上执行类型转换时使用的&#123;@link ConfigurableConversionService&#125;。 * 返回的转换服务的可配置性质允许方便地添加和删除单个&#123;@code Converter&#125;实例： * * ConfigurableConversionService cs = env.getConversionService(); * cs.addConverter(new FooConverter()); */ ConfigurableConversionService getConversionService(); /** * 设置在属性上执行类型转换时使用的&#123;@link ConfigurableConversionService&#125;。 * 注意：与其完全替换&#123;@code ConversionService&#125;的替代方法，不如考虑通过获取 &#123;@link #getConversionService()&#125; ，并调用方法，如&#123;@code #addConverter&#125;，添加或删除单个 &#123;@code Converter&#125; 实例。 */ void setConversionService(ConfigurableConversionService conversionService); /** * 设置由此解析器替换的占位符的前缀必须以它开头。 */ void setPlaceholderPrefix(String placeholderPrefix); /** * 设置此解析器替换的占位符的后缀必须以其结尾。 */ void setPlaceholderSuffix(String placeholderSuffix); /** * 指定由此解析器替换的占位符与其关联的默认值之间的分隔符，或者，如果没有此类特殊字符作为值分隔符处理，则为&#123;@code null&#125;。 */ void setValueSeparator(String valueSeparator); /** * 设置是否在遇到嵌套在给定属性的值中的未解析占位符时抛出异常。 &#123;@code false&#125;值表示严格的不，即将抛出异常。 &#123;@code true&#125;值表示无法解析的嵌套占位符应以未解析的 $&#123;...&#125; 形式传递。 * &#123;@link #getProperty(String)&#125; 及其变体的实现必须检查此处设置的值，以在属性值包含不可解析占位符时确定正确的行为。 */ void setIgnoreUnresolvableNestedPlaceholders(boolean ignoreUnresolvableNestedPlaceholders); /** * 指定哪些属性必须存在，由 &#123;@link #validateRequiredProperties()&#125; 验证。 */ void setRequiredProperties(String... requiredProperties); /** * 验证 &#123;@link #setRequiredProperties&#125; 指定的每个属性是否存在，并解析为 非&#123;@code null&#125; 值。 */ void validateRequiredProperties() throws MissingRequiredPropertiesException;&#125; 2.2 属性解析实现与抽象类2.2.1 PropertyPlaceholderHelper123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107/** * 使用具有占位符值的Strings的实用程序类。 占位符采用 &#123;@code $&#123;name&#125;&#125; 的形式。 使用 &#123;@code PropertyPlaceholderHelper&#125; 这些占位符可以替代用户提供的值。 * 可以使用 &#123;@link Properties&#125; 实例或使用 &#123;@link PlaceholderResolver&#125; 提供替换值。 */public class PropertyPlaceholderHelper &#123; private static final Log logger = LogFactory.getLog(PropertyPlaceholderHelper.class); private static final Map&lt;String, String&gt; wellKnownSimplePrefixes = new HashMap&lt;&gt;(4); static &#123; wellKnownSimplePrefixes.put(\"&#125;\", \"&#123;\"); wellKnownSimplePrefixes.put(\"]\", \"[\"); wellKnownSimplePrefixes.put(\")\", \"(\"); &#125; private final String placeholderPrefix; private final String placeholderSuffix; private final String simplePrefix; private final String valueSeparator; private final boolean ignoreUnresolvablePlaceholders; public String replacePlaceholders(String value, PlaceholderResolver placeholderResolver) &#123; Assert.notNull(value, \"'value' must not be null\"); return parseStringValue(value, placeholderResolver, new HashSet&lt;&gt;()); &#125; protected String parseStringValue( String value, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders) &#123; StringBuilder result = new StringBuilder(value); int startIndex = value.indexOf(this.placeholderPrefix); while (startIndex != -1) &#123; int endIndex = findPlaceholderEndIndex(result, startIndex); if (endIndex != -1) &#123; String placeholder = result.substring(startIndex + this.placeholderPrefix.length(), endIndex); String originalPlaceholder = placeholder; if (!visitedPlaceholders.add(originalPlaceholder)) &#123; throw new IllegalArgumentException( \"Circular placeholder reference '\" + originalPlaceholder + \"' in property definitions\"); &#125; // Recursive invocation, parsing placeholders contained in the placeholder key. // 递归调用，解析包含在占位符键中的占位符。 placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders); // Now obtain the value for the fully resolved key... // 现在获取完全解析key的值... String propVal = placeholderResolver.resolvePlaceholder(placeholder); if (propVal == null &amp;&amp; this.valueSeparator != null) &#123; int separatorIndex = placeholder.indexOf(this.valueSeparator); if (separatorIndex != -1) &#123; String actualPlaceholder = placeholder.substring(0, separatorIndex); String defaultValue = placeholder.substring(separatorIndex + this.valueSeparator.length()); propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder); if (propVal == null) &#123; propVal = defaultValue; &#125; &#125; &#125; if (propVal != null) &#123; // Recursive invocation, parsing placeholders contained in the // previously resolved placeholder value. // 递归调用，解析先前解析的占位符值中包含的占位符。 propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders); result.replace(startIndex, endIndex + this.placeholderSuffix.length(), propVal); if (logger.isTraceEnabled()) &#123; logger.trace(\"Resolved placeholder '\" + placeholder + \"'\"); &#125; startIndex = result.indexOf(this.placeholderPrefix, startIndex + propVal.length()); &#125; else if (this.ignoreUnresolvablePlaceholders) &#123; // Proceed with unprocessed value. // 继续处理未处理的值。 startIndex = result.indexOf(this.placeholderPrefix, endIndex + this.placeholderSuffix.length()); &#125; else &#123; throw new IllegalArgumentException(\"Could not resolve placeholder '\" + placeholder + \"'\" + \" in value \\\"\" + value + \"\\\"\"); &#125; visitedPlaceholders.remove(originalPlaceholder); &#125; else &#123; startIndex = -1; &#125; &#125; return result.toString(); &#125; /** * 用于解决字符串中包含的占位符替换值的策略界面。 */ @FunctionalInterface public interface PlaceholderResolver &#123; /** * 将提供的占位符名称解析为替换值。 */ String resolvePlaceholder(String placeholderName); &#125;&#125; 2.2.2 AbstractPropertyResolver123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/** * 用于解析任何基础源的属性的抽象基类。 */public abstract class AbstractPropertyResolver implements ConfigurablePropertyResolver &#123; protected final Log logger = LogFactory.getLog(getClass()); private volatile ConfigurableConversionService conversionService; private PropertyPlaceholderHelper nonStrictHelper; private PropertyPlaceholderHelper strictHelper; private boolean ignoreUnresolvableNestedPlaceholders = false; private String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX; private String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX; private String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR; private final Set&lt;String&gt; requiredProperties = new LinkedHashSet&lt;&gt;(); @Override public String resolvePlaceholders(String text) &#123; if (this.nonStrictHelper == null) &#123; this.nonStrictHelper = createPlaceholderHelper(true); &#125; return doResolvePlaceholders(text, this.nonStrictHelper); &#125; private PropertyPlaceholderHelper createPlaceholderHelper(boolean ignoreUnresolvablePlaceholders) &#123; return new PropertyPlaceholderHelper(this.placeholderPrefix, this.placeholderSuffix, this.valueSeparator, ignoreUnresolvablePlaceholders); &#125; private String doResolvePlaceholders(String text, PropertyPlaceholderHelper helper) &#123; return helper.replacePlaceholders(text, new PropertyPlaceholderHelper.PlaceholderResolver() &#123; @Override public String resolvePlaceholder(String placeholderName) &#123; return getPropertyAsRawString(placeholderName); &#125; &#125;); &#125; /** * Retrieve the specified property as a raw String, * i.e. without resolution of nested placeholders. * @param key the property name to resolve * @return the property value or &#123;@code null&#125; if none found */ protected abstract String getPropertyAsRawString(String key);&#125; 2.2.3 PropertySourcesPropertyResolver12345678/** * &#123;@link PropertyResolver&#125; 实现，它根据&#123;@link PropertySources&#125;的底层解析属性值。 */public class PropertySourcesPropertyResolver extends AbstractPropertyResolver &#123; private final PropertySougggtirces propertySources;&#125; 3. PropertySource3.1 PropertySource抽象与实现3.1.1 PropertySource1234567891011121314/** * 表示 name/value 属性对的来源的抽象基类。底层的 &#123;@linkplain #getSource（）source object&#125; 可以任何 &#123;@code T&#125; 类型的封装属性。示例包括 &#123;@link java.util.Properties&#125; 对象，&#123;@link java.util.Map&#125;对象，&#123;@code ServletContext&#125; 和 &#123;@code ServletConfig&#125; 对象（用于访问init参数）。浏览 &#123;@code PropertySource&#125; 类型层次结构以查看提供的实现。 * * 通常不会孤立地使用 &#123;@code PropertySources&#125; 对象，而是通过 &#123;@link PropertySources&#125; 对象来集成属性源，并结合使用 &#123;@link PropertyResolver&#125; 。实现跨越 &#123;@code PropertySources&#125; 集合的基于优先级搜索。 * * &#123;@code PropertySource&#125; 标识不是基于封装属性的内容而是基于 &#123;@code PropertySource&#125; 的 &#123;@link #getName() name&#125;。这对于在集合上下文中操作 &#123;@code PropertySource&#125; 对象很有用。有关详细信息，请参阅 &#123;@link MutablePropertySources&#125; 中的操作以及 &#123;@link #named(String)&#125; 和 &#123;@link #toString()&#125; 方法。 * * 请注意，使用 @&#123;@link * org.springframework.context.annotation.Configuration Configuration&#125; 类时，@&#123;@link org.springframework.context.annotation.PropertySource PropertySource&#125; 注释提供了一种方便和声明性的方式向封闭的 &#123;@code Environment&#125; 添加属性源。 */public abstract class PropertySource&lt;T&gt; &#123; protected final String name; protected final T source;&#125; 3.1.2 EnumerablePropertySource12345678/** * 可询问其底层源对象，来枚举所有可能的属性 name/value对 的&#123;@link PropertySource&#125;抽象类。暴露 &#123;@link #getPropertyNames()&#125; 方法，以允许调用者内省自己的可用属性，而不必访问底层的源对象。这也有助于更有效地实现 &#123;@link #containsProperty(String)&#125;，因为它可以调用 &#123;@link #getPropertyNames()&#125; 并遍历返回的数组，而不是尝试调用 &#123;@link #getProperty(String)&#125;，这可能更昂贵。实现可能会考虑缓存 &#123;@link #getPropertyNames()&#125; 的结果，以充分利用此性能机会。 * * 大多数框架提供的&#123;@code PropertySource&#125;实现是可枚举的;一个反例是&#123;@code JndiPropertySource&#125;，由于JNDI的性质，在任何给定时间都不可能确定所有可能的属性名称;而只能尝试访问一个属性（通过&#123;@link #getProperty（String）&#125;）来评估它是否存在。 */public abstract class EnumerablePropertySource&lt;T&gt; extends PropertySource&lt;T&gt; &#123; public abstract String[] getPropertyNames();&#125; 3.1.3 MapPropertySource12345/** * &#123;@link PropertySource&#125;从&#123;@code Map&#125;对象读取 keys 和 values 。 */public class MapPropertySource extends EnumerablePropertySource&lt;Map&lt;String, Object&gt;&gt; &#123;&#125; 3.1.4 SystemEnvironmentPropertySource123456789101112131415161718192021222324/** * 专为 &#123;@linkplain AbstractEnvironment#getSystemEnvironment() system environment variables&#125; 使用而设计的特殊&#123;@link MapPropertySource&#125; 。补偿Bash和其他shell中的约束，不允许包含句点字符和/或连字符的变量;同样允许shell更常用的使用的大写属性名称变体。 * * 例如，调用 &#123;@code getProperty(\"foo.bar\")&#125; 将尝试找到原始属性或任何“等效”属性的值，返回首次找到的值： * &#123;@code foo.bar&#125; - 原始名称 * &#123;@code foo_bar&#125; - 句点转下划线（如果有） * &#123;@code FOO.BAR&#125; - 原件，大写 * &#123;@code FOO_BAR&#125; - 带下划线和大写 * 上述任何连字符变体也可以工作，甚至混合点/连字符变体。 * * 同样适用于 &#123;@link #containsProperty(String)&#125; 的调用，如果存在任何上述属性，则返回&#123;@code true&#125;，否则&#123;@code false&#125;。 * * 将活动或默认配置文件指定为环境变量时，此功能特别有用。 Bash下是不允许的： * spring.profiles.active=p1 java -classpath ... MyApp * * 但是，以下语法是允许的，也是更常规的： * SPRING_PROFILES_ACTIVE=p1 java -classpath ... MyApp * * 为此类（或包）启用调试或跟踪级别日志记录，以解释何时发生这些“属性名称解析”。 * * 此属性源默认包含在 &#123;@link StandardEnvironment&#125; 及其所有子类中。 */public class SystemEnvironmentPropertySource extends MapPropertySource &#123;&#125; 3.1.5 PropertiesPropertySource123456/** * &#123;@link PropertySource&#125; 实现，从 &#123;@link java.util.Properties&#125; 对象中提取属性。 * 请注意，由于 &#123;@code Properties&#125; 对象在技术上是 &#123;@code &lt;Object，Object&gt;&#125; &#123;@link java.util.Hashtable Hashtable&#125;，可能包含非&#123;@code String&#125;键或值。 然而，这种实现仅限于访问 &#123;@code String&#125; 的键和值，与&#123;@link Properties＃getProperty&#125;和&#123;@link Properties＃setProperty&#125;的方式相同。 */public class PropertiesPropertySource extends MapPropertySource &#123;&#125; 3.1.6 CommandLinePropertySource123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114/** * 由命令行参数支持的&#123;@link PropertySource&#125;实现的抽象基类。 参数化类型&#123;@code T&#125;表示命令行选项的基础源。 在&#123;@link SimpleCommandLinePropertySource&#125;的情况下，这可能与String数组一样简单，或者在&#123;@link JOptCommandLinePropertySource&#125;的情况下特定于特定的API，例如JOpt的&#123;@code OptionSet&#125;。 * * * 目的和一般用法 * 用于独立的基于Spring的应用程序，即通过传统&#123;@code main&#125;方法从命令行接受参数的 &#123;@code String[]&#125; 引导的应用程序。 在许多情况下，直接在&#123;@code main&#125;方法中处理命令行参数可能就足够了，但在其他情况下，可能需要将参数作为值注入Spring bean。 这是后一种情况，&#123;@code CommandLinePropertySource&#125;变得有用。 通常将 &#123;@code CommandLinePropertySource&#125; 添加到Spring &#123;@code ApplicationContext&#125; 的 &#123;@link Environment&#125; 中，此时所有命令行参数可通过 &#123;@link Environment#getProperty(String)&#125; 方法获得。 例如： * * public static void main(String[] args) &#123; * CommandLinePropertySource clps = ...; * AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); * ctx.getEnvironment().getPropertySources().addFirst(clps); * ctx.register(AppConfig.class); * ctx.refresh(); * &#125; * * 通过上面的引导逻辑，&#123;@code AppConfig&#125; 类可以 &#123;@code @Inject&#125; Spring &#123;@code Environment&#125;并直接查询属性： * * @Configuration * public class AppConfig &#123; * * @Inject Environment env; * * @Bean * public void DataSource dataSource() &#123; * MyVendorDataSource dataSource = new MyVendorDataSource(); * dataSource.setHostname(env.getProperty(\"db.hostname\", \"localhost\")); * dataSource.setUsername(env.getRequiredProperty(\"db.username\")); * dataSource.setPassword(env.getRequiredProperty(\"db.password\")); * // ... * return dataSource; * &#125; * &#125; * * * 由于 &#123;@code CommandLinePropertySource&#125; 已使用 &#123;@code #addFirst&#125; 方法添加到 &#123;@code Environment&#125; 的 &#123;@link MutablePropertySources&#125; 集合中，因此具有最高的搜索优先级，这意味着 “db.hostname” 或可能存在于其他属性源（如系统环境变量）的属性中，它将首先从命令行属性源中选择。 这是一个合理的方法，因为在命令行上指定的参数自然比指定为环境变量的参数更具体。 * 作为注入 &#123;@code Environment&#125; 的替代方法，Spring的 &#123;@code @Value&#125; 注释可以用于注入这些属性，因为已经注册了 &#123;@link PropertySourcesPropertyResolver&#125; bean，直接或通过使用 &#123;@code &lt;context：property-placeholder&gt;&#125; 元素。 例如： * @Component * public class MyComponent &#123; * * @Value(\"my.property:defaultVal\") * private String myProperty; * * public void getMyProperty() &#123; * return this.myProperty; * &#125; * * // ... * &#125; * * * 使用选项参数 * 单个命令行参数通过通常的 &#123;@link PropertySource#getProperty(String)&#125; 和 &#123;@link PropertySource#containsProperty(String)&#125; 方法表示为属性。 例如，给出以下命令行: * --o1=v1 --o2 * 'o1' 和 'o2' 被视为“选项参数”，并且以下断言将评估为true： * * CommandLinePropertySource&lt;?&gt; ps = ... * assert ps.containsProperty(\"o1\") == true; * assert ps.containsProperty(\"o2\") == true; * assert ps.containsProperty(\"o3\") == false; * assert ps.getProperty(\"o1\").equals(\"v1\"); * assert ps.getProperty(\"o2\").equals(\"\"); * assert ps.getProperty(\"o3\") == null; * * 请注意，'o2'选项没有参数，但&#123;@code getProperty（“o2”）&#125;解析为空字符串 (&#123;@code \"\"&#125;) 而不是&#123;@code null&#125;，而&#123;@code getProperty “o3”）&#125;解析为&#123;@code null&#125;，因为没有指定。 此行为与所有&#123;@code PropertySource&#125;实现所遵循的一般约定一致。 * * 另请注意，虽然在上述示例中使用 \"--\" 来表示一个选项参数，但是这种语法可能会在单独的命令行参数库中有所不同。 例如，基于JOpt或Commons CLI的实现可能允许单个破折号 (\"-\") “短”选项参数等。 * * * 使用非选项参数 * * 这种抽象也支持非选项参数。 任何没有选项样式前缀（如 \"-\" 或 \"--\" ）提供的参数都被视为“非选项参数”，通过特殊的 &#123;@linkplain * #DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME \"nonOptionArgs\"&#125; 属性可以使用。 如果指定了多个非选项参数，则此属性的值将是包含所有参数的以逗号分隔的字符串。 这种方法确保来自 &#123;@code * CommandLinePropertySource&#125; 的所有属性的简单且一致的返回类型（String），同时适用于与Spring &#123;@link Environment&#125; 及其内置 &#123;@code ConversionService&#125;。 请考虑以下示例： * * --o1=v1 --o2=v2 /path/to/file1 /path/to/file2 * * 在本示例中，“o1”和“o2”将被视为“选项参数”，而两个文件系统路径将被视为“非选项参数”。 因此，以下断言将评估为真： * * CommandLinePropertySource&lt;?&gt; ps = ... * assert ps.containsProperty(\"o1\") == true; * assert ps.containsProperty(\"o2\") == true; * assert ps.containsProperty(\"nonOptionArgs\") == true; * assert ps.getProperty(\"o1\").equals(\"v1\"); * assert ps.getProperty(\"o2\").equals(\"v2\"); * assert ps.getProperty(\"nonOptionArgs\").equals(\"/path/to/file1,/path/to/file2\"); * * 如上所述，当与Spring &#123;@code Environment&#125;抽象结合使用时，逗号分隔的字符串可能很容易转换为String数组或列表： * * Environment env = applicationContext.getEnvironment(); * String[] nonOptionArgs = env.getProperty(\"nonOptionArgs\", String[].class); * assert nonOptionArgs[0].equals(\"/path/to/file1\"); * assert nonOptionArgs[1].equals(\"/path/to/file2\"); * * 可以通过 &#123;@link #setNonOptionArgsPropertyName(String)&#125; 方法定制特殊“非选项参数”属性的名称。 建议这样做，因为它为非选项参数赋予正确的语义值。 例如，如果将文件系统路径指定为非选项参数，则可能将其称为“file.locations”类似于“nonOptionArgs”的默认值： * * public static void main(String[] args) &#123; * CommandLinePropertySource clps = ...; * clps.setNonOptionArgsPropertyName(\"file.locations\"); * * AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); * ctx.getEnvironment().getPropertySources().addFirst(clps); * ctx.register(AppConfig.class); * ctx.refresh(); * &#125; * * * 限制 * 这种抽象不是为了暴露基础命令行解析API（如JOpt或Commons CLI）的全部功能。 它的意图恰恰相反：提供最简单的可能的抽象，以便在命令行参数解析之后访问。 解析主方法中的参数的&#123;@code String []&#125;，然后简单地将解析结果提供给&#123;@code CommandLinePropertySource&#125;的实现。 在这一点上，所有参数都可以被认为是“选项”或“非选项”参数，如上所述可以通过普通的&#123;@code PropertySource&#125;和&#123;@code Environment&#125; API来访问。 */public abstract class CommandLinePropertySource&lt;T&gt; extends EnumerablePropertySource&lt;T&gt; &#123; public static final String COMMAND_LINE_PROPERTY_SOURCE_NAME = \"commandLineArgs\"; public static final String DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME = \"nonOptionArgs\"; private String nonOptionArgsPropertyName = DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME;&#125; 3.1.7 SimpleCommandLinePropertySource1234567891011121314151617181920212223242526272829303132333435363738394041/** * &#123;@link CommandLinePropertySource&#125;实现，由一个简单的String数组支持 * * * 目的 * 此&#123;@code CommandLinePropertySource&#125;实现旨在提供解析命令行参数的最简单的方法。 与所有 &#123;@code CommandLinePropertySource&#125; 实现一样，命令行参数分为两个不同的组： 选项参数 和 非选项参数 ，如下所述 从Javadoc为&#123;@link SimpleCommandLineArgsParser&#125;复制的部分） ： * * * 使用选项参数 * 选项参数必须遵守确切的语法： * --optName[=optValue] * 也就是说，选项必须以\"&#123;@code --&#125;\"为前缀，并且可以指定或不指定值。 如果指定了一个值，则必须使用等号（“=”）分隔不带空格的名称和值。 * 选项参数的有效示例 * --foo * --foo=bar * --foo=\"bar then baz\" * --foo=bar,baz,biz * 无效的选项参数示例 * -foo * --foo bar * --foo = bar * --foo=bar --foo=baz --foo=biz * * * 使用非选项参数 * 在没有 \"&#123;@code --&#125;\" 选项前缀的命令行中指定的任何和所有参数将被视为“非选项参数”，并通过 &#123;@link #getNonOptionArgs()&#125; 方法提供。 * * * 典型用法 * public static void main(String[] args) &#123; * PropertySource&lt;?&gt; ps = new SimpleCommandLinePropertySource(args); * // ... * &#125; * 有关完整的一般用法示例，请参阅&#123;@link CommandLinePropertySource&#125;。 * * * 基础以外 * 当需要更全面的命令行解析时，请考虑使用提供的&#123;@link JOptCommandLinePropertySource&#125;，或者根据您选择的命令行解析库实现您自己的&#123;@code CommandLinePropertySource&#125; */public class SimpleCommandLinePropertySource extends CommandLinePropertySource&lt;CommandLineArgs&gt; &#123;&#125; 1234class CommandLineArgs &#123; private final Map&lt;String, List&lt;String&gt;&gt; optionArgs = new HashMap&lt;&gt;(); private final List&lt;String&gt; nonOptionArgs = new ArrayList&lt;&gt;();&#125; 3.1.8 CompositePropertySource12345678/** * 复合 &#123;@link PropertySource&#125; 实现，迭代一组&#123;@link PropertySource&#125;实例。在多个资源共享同一个名称的情况下，是必要的。例如当 &#123;@code @PropertySource&#125; 提供多个值时。 * * 从Spring 4.1.2开始，该类扩展了&#123;@link EnumerablePropertySource&#125;，而不是纯&#123;@link PropertySource&#125;，根据所有包含的源的累积属性名称展开 &#123;@link #getPropertyNames()&#125; （尽最大可能） ）。 */public class CompositePropertySource extends EnumerablePropertySource&lt;Object&gt; &#123; private final Set&lt;PropertySource&lt;?&gt;&gt; propertySources = new LinkedHashSet&lt;&gt;();&#125; 3.2 PropertySource集合3.2.1 PropertySources1234public interface PropertySources extends Iterable&lt;PropertySource&lt;?&gt;&gt; &#123; boolean contains(String name); PropertySource&lt;?&gt; get(String name);&#125; 3.2.2 MutablePropertySources1234567/** * &#123;@link PropertySources&#125;接口的默认实现。 允许处理包含的多属性源，并提供一个构造函数来复制现有的&#123;@code PropertySources&#125;实例。 * 在 &#123;@link #addFirst&#125; 和 &#123;@link #addLast&#125; 等方法中提及 优先级 的地方，这是关于在使用&#123;@link PropertyResolver&#125;解析给定属性时，搜索属性源的顺序。 */public class MutablePropertySources implements PropertySources &#123; private final List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = new CopyOnWriteArrayList&lt;&gt;();&#125; 4. Environment 4.1 接口4.1.1 Environment12345678910111213141516171819202122232425262728293031/** * 表示当前应用程序正在运行的环境的接口。 模拟应用程序环境的两个关键方面：profiles 和 properties 。 与属性访问相关的方法通过 &#123;@link PropertyResolver&#125; 父接口暴露。 * 只有在给定的 profile 活动时，profile才是一个有名字的、注册在容器上的bean定义逻辑组。 bean可以被分配到不管是以XML定义还是以注释的profile; 有关语法详细信息，请参阅spring-beans 3.1 schema 或 &#123;@link org.springframework.context.annotation.Profile @Profile&#125;注释。 &#123;@code Environment&#125;对象与 profiles 的关系在于确定当前中哪些配置文件（如果有的话）&#123;@linkplain #getActiveProfiles active&#125; 活动 ，哪些配置文件（如果有的话）应该是&#123;@linkplain #getDefaultProfiles 在默认情况下处于活动状态&#125;。 * Properties 在几乎所有的应用程序中起着重要的作用，可能来自各种来源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc 属性对象，地图等。 环境对象与属性关系的作用是为用户提供方便的服务接口，用于配置属性源并从中解析属性。 * 在&#123;@code ApplicationContext&#125;中管理的Bean可以注册为 &#123;@link org.springframework.context.EnvironmentAware EnvironmentAware&#125; 或 &#123;@code @Inject&#125; &#123;@code Environment&#125;，以便直接查询配置文件状态或解析属性。 * 然而，在大多数情况下，应用级别的bean不需要直接与&#123;@code Environment&#125;进行交互，而是可能必须将 &#123;@code $&#123;...&#125;&#125; 属性值替换为属性占位符配置。例如，&#123;@link org.springframework.context.support.PropertySourcesPlaceholderConfigurer PropertySourcesPlaceholderConfigurer&#125;）本身就是&#123;@code EnvironmentAware&#125;，并且在Spring 3.1之前，使用 &#123;@code getEnvironment()&#125; 时，默认被注册。 * 环境对象的配置必须通过从 &#123;@code AbstractApplicationContext&#125; 子类 &#123;@code getEnvironment()&#125; 方法返回的&#123;@code ConfigurableEnvironment&#125;接口完成。有关使用示例的示例，请参阅&#123;@link ConfigurableEnvironment&#125; Javadoc，演示在应用程序上下文&#123;@code refresh()&#125;之前操纵属性源。 */public interface Environment extends PropertyResolver &#123; /** * 返回显示为此环境激活的配置文件集。 配置文件用于创建有条件注册的bean定义的逻辑分组，例如基于部署环境。 可以通过将&#123;@linkplain AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME \"spring.profiles.active\"&#125; 设置为系统属性或调用 &#123;@link ConfigurableEnvironment#setActiveProfiles(String...)&#125; 来激活配置文件。 * 如果没有将配置文件明确指定为活动的，那么任何&#123;@linkplain #getDefaultProfiles() 默认配置文件&#125;将自动被激活。 */ String[] getActiveProfiles(); /** * 当没有显式设置活动的配置文件时，默认情况下返回一组配置文件。 */ String[] getDefaultProfiles(); /** * 返回一个或多个给定的配置文件是否处于活动状态，或者在没有显式活动配置文件的情况下，是否将一个或多个给定配置文件包含在默认配置文件集中。 * 如果配置文件以 '!' 开头 逻辑被反转，即如果给定的配置文件不是 活动，该方法将返回true。 * 例如，如果配置文件“p1”处于活动状态或“p2”不活动，则 * env.acceptsProfiles(\"p1\", \"!p2\") * 将返回&#123;@code true&#125; */ boolean acceptsProfiles(String... profiles);&#125; 5.1.2 ConfigurableEnvironment1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374/** * 配置接口由大多数（如果不是全部）&#123;@link Environment&#125;类型实现。 * 提供设置活动和默认配置文件以及操纵底层属性源的功能。 * 允许客户端通过&#123;@link ConfigurablePropertyResolver&#125;父接口，来设置和验证所需的属性，自定义转换服务等等。 * * 操纵属性来源 * 属性来源可被删除，重新排序或替换; 并且可以使用从 &#123;@link #getPropertySources()&#125; 返回的 &#123;@link MutablePropertySources&#125; 实例添加其他属性源。 * 以下示例针对&#123;@code ConfigurableEnvironment&#125;的实现&#123;@link StandardEnvironment&#125;，但通常适用于任何实现，尽管特定的默认属性来源可能不同。 * * 示例：添加具有最高搜索优先级的新属性源 * ConfigurableEnvironment environment = new StandardEnvironment(); * MutablePropertySources propertySources = environment.getPropertySources(); * Map&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;(); * myMap.put(\"xyz\", \"myValue\"); * propertySources.addFirst(new MapPropertySource(\"MY_MAP\", myMap)); * * 示例：删除默认的系统属性属性源 * MutablePropertySources propertySources = environment.getPropertySources(); * propertySources.remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME) * * 示例：mock系统环境进行测试 * MutablePropertySources propertySources = environment.getPropertySources(); * MockPropertySource mockEnvVars = new MockPropertySource().withProperty(\"xyz\", \"myValue\"); * propertySources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, mockEnvVars); * * 当&#123;@code ApplicationContext&#125;正在使用&#123;@link Environment&#125;时，在上下文的&#123;@link * org.springframework.context.support.AbstractApplicationContext#refresh() refresh()&#125;方法被调用之前执行任何这样的&#123;@code PropertySource&#125;操作非常重要。 * 这确保了所有属性源在容器引导过程中可用，包括被&#123;@linkplain org.springframework.context.support.PropertySourcesPlaceholderConfigurer property placeholder configurers&#125;使用。 */public interface ConfigurableEnvironment extends Environment, ConfigurablePropertyResolver &#123; /** * 为 &#123;@code Environment&#125; 指定一组活动的配置文件。在容器引导期间评估配置文件，以确定bean定义是否应该向容器注册。 * 任何现有的活动配置文件将被替换为给定的参数; 零参数调用来清除活动配置文件的当前集合。 * 使用&#123;@link #addActiveProfile&#125;添加配置文件同时保留现有集。 */ void setActiveProfiles(String... profiles); /** * 将配置文件添加到当前活动配置文件集中。 */ void addActiveProfile(String profile); /** * 如果没有其他配置文件通过&#123;@link #setActiveProfiles&#125;显式生效，则默认指定要设置为活动的配置文件集。 */ void setDefaultProfiles(String... profiles); MutablePropertySources getPropertySources(); /** * 如果当前&#123;@link SecurityManager&#125;允许，返回 &#123;@link System#getenv()&#125; 的值，否则返回一个map实现，它将尝试通过调用 &#123;@link System#getenv(String)&#125; 访问各个键。 * 请注意，大多数&#123;@link Environment&#125;实现将将此系统环境映射作为默认&#123;@link PropertySource&#125;进行搜索。 因此，建议不要直接使用此方法，除非明确地意图绕过其他属性来源。 * 在返回的Map上调用 &#123;@link Map#get(Object)&#125; 将永远不会抛出&#123;@link IllegalAccessException&#125;; 在SecurityManager禁止访问属性的情况下，将返回&#123;@code null&#125;，并将发出INFO级日志消息，注明异常。 */ Map&lt;String, Object&gt; getSystemEnvironment(); /** * 如果当前的 &#123;@link SecurityManager&#125; 允许，返回 &#123;@link System#getProperties()&#125; 的值，否则返回一个映射实现，它将尝试使用对 &#123;@link System#getProperty(String)&#125; 的调用访问各个键。 * 请注意，大多数&#123;@code Environment&#125;实现将将此系统属性映射作为默认&#123;@link PropertySource&#125;进行搜索。 因此，建议不要直接使用此方法，除非明确地意图绕过其他属性来源。 * 在返回的Map上调用 &#123;@link Map#get(Object)&#125; 将永远不会抛出&#123;@link IllegalAccessException&#125;; 在SecurityManager禁止访问属性的情况下，将返回&#123;@code null&#125;，并将发出INFO级日志消息，注明异常。 */ Map&lt;String, Object&gt; getSystemProperties(); /** * 追加给定的父环境的活动配置文件，默认配置文件和属性源附加到此（子）环境各自的集合中。 * 对于存在于父项和子节点的任何同名命名的&#123;@code PropertySource&#125;实例，子实例将被保留并且父实例被丢弃。 这具有允许子级覆盖属性源的作用，并且避免通过公共属性源类型的冗余搜索， * 例如 系统环境和系统属性。 * 活动和默认配置文件名称也被重复过滤，以避免混淆和冗余存储。 * 在任何情况下，父环境都未修改。 请注意，调用&#123;@code merge&#125;之后发生的父环境的任何更改都不会反映在该子环境中。 因此，在调用&#123;@code merge&#125;之前，应该小心配置父属性源和配置文件信息。 */ void merge(ConfigurableEnvironment parent);&#125; 5.2 抽象与实现5.2.1 AbstractEnvironment12345678910111213141516171819202122232425262728293031323334353637383940/** * &#123;@link Environment&#125; 实现的抽象基类。 支持保留默认配置文件名称的概念，并通过 &#123;@link #ACTIVE_PROFILES_PROPERTY_NAME&#125; 和 &#123;@link #DEFAULT_PROFILES_PROPERTY_NAME&#125; 属性开启指定活动和默认配置文件。 * * 具体的子类区别主要在于默认添加的 &#123;@link PropertySource&#125; 对象。 &#123;@code AbstractEnvironment&#125; 没有添加。 子类应通过受保护的&#123;@link #customizePropertySources（MutablePropertySources）&#125;钩子来提供属性源，而客户端应使用&#123;@link ConfigurableEnvironment#getPropertySources()&#125;进行自定义，并使用&#123;@link MutablePropertySources&#125; API。 有关使用示例，请参阅&#123;@link ConfigurableEnvironment&#125; javadoc。 */public abstract class AbstractEnvironment implements ConfigurableEnvironment &#123; /** * 系统属性指示Spring忽略系统环境变量，即永远不 会通过&#123;@link System#getenv()&#125;检索这样一个变量。 * 默认值为“false”，返回到系统环境变量，检查Spring环境属性（例如，配置字符串中的占位符）是否不可解析。 如果您遇到来自Spring的&#123;@code getenv&#125;呼叫的日志警告，请考虑将此标志切换为“true”，例如。 在WebSphere上使用严格的SecurityManager设置和AccessControlExceptions警告。... */ public static final String IGNORE_GETENV_PROPERTY_NAME = \"spring.getenv.ignore\"; /** * 要设置为指定活动配置文件的属性名称：&#123;@value&#125;。 值可以以逗号分隔。 * 请注意，某些shell环境（如Bash）不允许在变量名称中使用句点字符。 假设Spring的&#123;@link SystemEnvironmentPropertySource&#125;正在使用中，此属性可能被指定为环境变量&#123;@code SPRING_PROFILES_ACTIVE&#125;。 */ public static final String ACTIVE_PROFILES_PROPERTY_NAME = \"spring.profiles.active\"; /** * 要设置的属性名称，以指定默认情况下活动的配置文件：&#123;@value&#125;。 值可以以逗号分隔。 * 请注意，某些shell环境（如Bash）不允许在变量名称中使用句点字符。 假设Spring的&#123;@link SystemEnvironmentPropertySource&#125;正在使用，该属性可能被指定为环境变量&#123;@code SPRING_PROFILES_DEFAULT&#125;。 */ public static final String DEFAULT_PROFILES_PROPERTY_NAME = \"spring.profiles.default\"; /** * 保留的默认配置文件名称名称：&#123;@value&#125;。 如果没有明确的默认配置文件名称，并且没有显式设置活动配置文件名称，默认情况下将自动激活此配置文件。 */ protected static final String RESERVED_DEFAULT_PROFILE_NAME = \"default\"; private final Set&lt;String&gt; activeProfiles = new LinkedHashSet&lt;&gt;(); private final Set&lt;String&gt; defaultProfiles = new LinkedHashSet&lt;&gt;(getReservedDefaultProfiles()); private final MutablePropertySources propertySources = new MutablePropertySources(this.logger); private final ConfigurablePropertyResolver propertyResolver = new PropertySourcesPropertyResolver(this.propertySources);&#125; 5.2.2 StandardEnvironment123456789101112131415/** * &#123;@link Environment&#125; 实现适用于“标准”（即非Web）应用程序。 * 除了属性解析和配置文件相关操作之类的&#123;@link ConfigurableEnvironment&#125;的常规功能外，此实现还将配置两个默认属性源，以下列顺序进行搜索： * &#123;@linkplain AbstractEnvironment#getSystemProperties() system properties&#125; * &#123;@linkplain AbstractEnvironment#getSystemEnvironment() system environment variables&#125; * 也就是说，如果JVM系统属性和当前进程的一组环境变量中都存在密钥“xyz”，系统属性中的“xyz”键值将从一个调用返回到 &#123;@code environment.getProperty(\"xyz\")&#125;。 默认情况下选择此排序，因为系统属性是每个JVM，而给定系统上的许多JVM的环境变量可能相同。 给予系统属性优先级允许在每个JVM的基础上覆盖环境变量。 * 这些默认属性源可能会被删除，重新排序或替换; 并且可以使用 &#123;@link #getPropertySources()&#125; 中提供的 &#123;@link MutablePropertySources&#125; 实例添加其他属性来源。 有关使用示例，请参阅&#123;@link ConfigurableEnvironment&#125; Javadoc。 * * 请参阅&#123;@link SystemEnvironmentPropertySource&#125; javadoc，了解在shell环境（例如Bash）中特殊处理属性名称的详细信息，该属性名称不允许变量名称中的句点字符。 */public class StandardEnvironment extends AbstractEnvironment &#123; public static final String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = \"systemEnvironment\"; public static final String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = \"systemProperties\";&#125;","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]},{"title":"spring 源码解析 3.类型体系","date":"2017-05-14T07:01:48.000Z","path":"2017/05/14/spring-code-type/","text":"1.Java反射，类型 2.Spring类型解析 2.1ResolvableType1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * 封装Java &#123;@link java.lang.reflect.Type&#125;，提供访问&#123;@link #getSuperType() supertypes&#125;，&#123;@link #getInterfaces() interfaces&#125; 和 &#123;@link #getGeneric(int...) generic parameters&#125; 以及最终&#123;@link #resolve() resolve&#125; 到 &#123;@link java.lang.Class&#125;的能力。 * 可以从 &#123;@link #forField(Field) fields&#125; ，&#123;@link #forMethodParameter(Method, int) method parameters&#125; ，&#123;@link #forMethodReturnType(Method) method returns&#125; 或 &#123;@link #forClass(Class) classes&#125; 中获取 &#123;@code ResolvableTypes&#125;。 * 这个类上的大多数方法都将返回&#123;@link ResolvableType&#125;，方便导航。 例如： * * * private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap; * * public void example() &#123; * ResolvableType t = ResolvableType.forField(getClass().getDeclaredField(\"myMap\")); * t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt; * t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt; * t.getGeneric(0).resolve(); // Integer * t.getGeneric(1).resolve(); // List * t.getGeneric(1); // List&lt;String&gt; * t.resolveGeneric(1, 0); // String * &#125; */@SuppressWarnings(\"serial\")public class ResolvableType implements Serializable &#123; /** * 没有值可用时返回&#123;@code ResolvableType&#125;。 &#123;@code NONE&#125;优先于&#123;@code null&#125;，以便可以安全地链接多个方法调用。 */ public static final ResolvableType NONE = new ResolvableType(null, null, null, 0); private static final ResolvableType[] EMPTY_TYPES_ARRAY = new ResolvableType[0]; private static final ConcurrentReferenceHashMap&lt;ResolvableType, ResolvableType&gt; cache = new ConcurrentReferenceHashMap&lt;&gt;(256); /** * 正在管理的底层Java类型（只有&#123;@code null&#125;，转化为&#123;@link #NONE&#125;）。 */ private final Type type; /** * 该类型的可选提供程序。 */ private final TypeProvider typeProvider; /** * 如果没有解析器可用，则使用&#123;@code VariableResolver&#125;或&#123;@code null&#125;。 */ private final VariableResolver variableResolver; /** * 数组的组件类型或&#123;@code null&#125;，如果该类型应被推导出来。 */ private final ResolvableType componentType; /** * Copy of the resolved value. * 解析值的复制 */ private final Class&lt;?&gt; resolved; private final Integer hash; private ResolvableType superType; private ResolvableType[] interfaces; private ResolvableType[] generics;&#125; TypeDescriptor123456789101112131415161718192021/** * 关于要转换的类型的上下文。 */@SuppressWarnings(\"serial\")public class TypeDescriptor implements Serializable &#123; static final Annotation[] EMPTY_ANNOTATION_ARRAY = new Annotation[0]; private static final Map&lt;Class&lt;?&gt;, TypeDescriptor&gt; commonTypesCache = new HashMap&lt;&gt;(18); private static final Class&lt;?&gt;[] CACHED_COMMON_TYPES = &#123; boolean.class, Boolean.class, byte.class, Byte.class, char.class, Character.class, double.class, Double.class, int.class, Integer.class, long.class, Long.class, float.class, Float.class, short.class, Short.class, String.class, Object.class&#125;; private final Class&lt;?&gt; type; private final ResolvableType resolvableType; private final AnnotatedElementAdapter annotatedElement;&#125;","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]},{"title":"spring 源码解析 4.类型转换Convert","date":"2017-05-11T16:32:09.000Z","path":"2017/05/12/spring-code-convert/","text":"1.概述Spring 3引入了一个提供通用类型转换系统的core.convert包。 该系统定义了一个SPI来实现类型转换逻辑，以及一个在运行时执行类型转换的API。 在Spring容器中，该系统可以用作PropertyEditor的替代方法，将外部化的bean属性值字符串转换为必需的属性类型。 公共API也可以在需要类型转换的应用程序的任何地方使用。 2.类图 3.convertor3.1 接口3.1.1 ConditionalConverter1234567891011/** * 允许 &#123;@link Converter&#125;，&#123;@link GenericConverter&#125;或&#123;@link ConverterFactory&#125;根据&#123;@code source&#125;和&#123;@code target&#125; &#123;@link TypeDescriptor&#125;的属性有条件地执行。 * 通常用于根据字段或类级特征（如注释或方法）的存在选择性地匹配自定义转换逻辑。 例如，当从String字段转换为Date字段时，如果目标字段也已使用&#123;@code @DateTimeFormat&#125;注释，则实现可能返回&#123;@code true&#125;。 * 另一个例子是，当从String字段转换为&#123;@code Account&#125;字段时，如果目标Account类定义了&#123;@code public static findAccount（String）&#125;方法，那么实现可能返回&#123;@code true&#125;。 */public interface ConditionalConverter &#123; /** * 当前&#123;@code sourceType&#125;到&#123;@code targetType&#125;的转换是否应当选择被选中？ */ boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType);&#125; 3.1.2 Converter123456789101112/** * 转换器将类型为&#123;@code S&#125;的 source 对象转换为类型为&#123;@code T&#125;的 target。 * 此接口的实现是线程安全的，可以共享。 * 实现可以同时实现&#123;@link ConditionalConverter&#125;。 */@FunctionalInterfacepublic interface Converter&lt;S, T&gt; &#123; /** * 将类型为&#123;@code S&#125;的 source 对象转换为类型&#123;@code T&#125; target。 */ T convert(S source);&#125; 3.1.3 ConverterFactory12345678910/** * 一个可以将对象从 S 转换成 R 的子类型的“范围”转换器的工厂。 * 实现可以同时实现&#123;@link ConditionalConverter&#125;。 */public interface ConverterFactory&lt;S, R&gt; &#123; /** * 获取转换器从S转换为目标类型T，其中T也是R的实例。 */ &lt;T extends R&gt; Converter&lt;S, T&gt; getConverter(Class&lt;T&gt; targetType);&#125; 3.1.4 GenericConverter12345678910111213141516171819202122232425/** * 用于在两种或多种类型之间转换的通用转换器接口。 * 这是转换器SPI接口中最灵活的，也是最复杂的。 它是灵活的，因为GenericConverter可以支持在多个 source/target 类型对之间进行转换（参见&#123;@link #getConvertibleTypes()&#125;）。此外，GenericConverter实现在类型转换期间可以访问 source / target &#123;@link TypeDescriptor field context&#125; 这可以解决 source 和 target 字段元数据，如 annotations 和泛型信息，可用于影响转换逻辑。 * 当简单的&#123;@link Converter&#125;或&#123;@link ConverterFactory&#125;接口就足够时，通常不会使用该接口。 * 实现可以同时实现&#123;@link ConditionalConverter&#125;。 */public interface GenericConverter &#123; /** * 返回 source 和 target 的类型对，用于此转换器在类型之间转换。 * 每个条目都是可转换的源到目标类型对。 * 对于&#123;@link ConditionalConverter conditional converters&#125;，此方法可能会返回&#123;@code null&#125;以指示应考虑所有源对目标对。 */ Set&lt;ConvertiblePair&gt; getConvertibleTypes(); /** * 将源对象转换为&#123;@code TypeDescriptor&#125;描述的targetType。 */ Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType); final class ConvertiblePair &#123; private final Class&lt;?&gt; sourceType; private final Class&lt;?&gt; targetType; &#125;&#125; 3.1.5 ConverterAdapter12345678/** * 将 &#123;@link Converter&#125; 适配到 &#123;@link GenericConverter&#125;。 */private final class ConverterAdapter implements ConditionalGenericConverter &#123; private final Converter&lt;Object, Object&gt; converter; private final ConvertiblePair typeInfo; private final ResolvableType targetType;&#125; 3.1.6 ConverterFactoryAdapter1234567/** * 将 &#123;@link ConverterFactory&#125; 适配到 &#123;@link GenericConverter&#125; 。 */private final class ConverterFactoryAdapter implements ConditionalGenericConverter &#123; private final ConverterFactory&lt;Object, Object&gt; converterFactory; private final ConvertiblePair typeInfo;&#125; 3.1.7 Converters1234567/** * 管理注册服务的所有转换器。 */private static class Converters &#123; private final Set&lt;GenericConverter&gt; globalConverters = new LinkedHashSet&lt;&gt;(); private final Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = new LinkedHashMap&lt;&gt;(36);&#125; 4. Service4.1 接口4.1.1 ConversionService12345678910111213141516171819202122232425262728293031323334/** * 用于类型转换的服务接口。这是转换系统的切入点。 * 调用 &#123;@link #convert(Object, Class)&#125; 以使用此系统执行线程安全类型转换。 */public interface ConversionService &#123; /** * 如果 &#123;@code sourceType&#125; 的对象可以转换为 &#123;@code targetType&#125; ，返回 &#123;@code true&#125;。 * 如果此方法返回&#123;@code true&#125;，则表示 &#123;@link #convert(Object, Class)&#125; 能够将 &#123;@code sourceType&#125; 的实例转换为 &#123;@code targetType&#125;。 * collections，arrays 和 map 类型的特别说明： * 对于collections，arrays 和 map类型之间的转换，即使转换调用此方法将返回&#123;@code true&#125;，如果基础元素不可转换，仍然可能会生成&#123;@link ConversionException&#125;。 在使用 collections 和 maps 时，调用方应该处理这种特殊情况。 */ boolean canConvert(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType); /** * 如果&#123;@code sourceType&#125;的对象可以转换为&#123;@code targetType&#125;，返回&#123;@code true&#125;。 * TypeDescriptors提供了关于 source 和 target 转换发生的位置的附加上下文，通常是对象字段或属性位置。 * 如果此方法返回&#123;@code true&#125;，则表示 &#123;@link #convert(Object, TypeDescriptor, TypeDescriptor)&#125; 能够将 &#123;@code sourceType&#125; 的实例转换为&#123;@code targetType&#125;。 * collections，arrays 和 map 类型的特别说明： * 对于collections，arrays 和 map类型之间的转换，即使转换调用此方法将返回&#123;@code true&#125;，如果基础元素不可转换，仍然可能会生成&#123;@link ConversionException&#125;。 在使用 collections 和 maps 时，调用方应该处理这种特殊情况。 */ boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType); /** * 将给定的&#123;@code source&#125;转换为指定的&#123;@code targetType&#125;。 */ &lt;T&gt; T convert(Object source, Class&lt;T&gt; targetType); /** * 将给定的&#123;@code source&#125;转换为指定的&#123;@code targetType&#125;。 * TypeDescriptors提供了关于 source 和 target 转换发生的位置的附加上下文，通常是对象字段或属性位置。 */ Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType);&#125; 4.1.2 ConverterRegistry12345678910111213141516171819202122232425262728293031323334/** * 用于注册类型转换系统的转换器 */public interface ConverterRegistry &#123; /** * 将一个普通转换器添加到此注册表。 * 可转换的 source/target 类型对，派生自转 Converter 的参数化类型。 */ void addConverter(Converter&lt;?, ?&gt; converter); /** * 将一个普通转换器添加到此注册表。 * 明确指定可转换 source/target 类型对。 * 允许将转换器重用于多个不同的对，而无需为每对创建一个Converter类。 */ &lt;S, T&gt; void addConverter(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? super S, ? extends T&gt; converter); /** * 将通用转换器添加到此注册表。 */ void addConverter(GenericConverter converter); /** * 向此注册表添加一个远程转换器工厂。 * 可转换 source/target 类型对，派生自ConverterFactory的参数化类型。 */ void addConverterFactory(ConverterFactory&lt;?, ?&gt; factory); /** * 将任何从&#123;@code sourceType&#125;到&#123;@code targetType&#125;转换器移除 */ void removeConvertible(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType);&#125; 4.1.3 ConfigurableConversionService12345/** * 配置接口大多数（如果不是全部）由&#123;@link ConversionService&#125;类型实现。 整合&#123;@link ConversionService&#125;公开的只读操作以及&#123;@link ConverterRegistry&#125;的变异操作，以便于方便的点对点添加和删除&#123;@link org.springframework.core.convert.converter.Converter Converters&#125;。 后者在ApplicationContext引导代码中的&#123;@link org.springframework.core.env.ConfigurableEnvironment ConfigurableEnvironment&#125;实例时特别有用。 */public interface ConfigurableConversionService extends ConversionService, ConverterRegistry &#123;&#125; 4.2 实现4.2.1GenericConversionService1234567891011121314151617181920/** * 基于 &#123;@link ConversionService&#125; 的实现，适用于大多数环境。 * 通过 &#123;@link ConfigurableConversionService&#125; 接口间接实现 &#123;@link ConverterRegistry&#125; 作为注册API。 */public class GenericConversionService implements ConfigurableConversionService &#123; /** * 不需要转换时使用的一般NO-OP转换器。 */ private static final GenericConverter NO_OP_CONVERTER = new NoOpConverter(\"NO_OP\"); /** * 当没有转换器可用时用作缓存条目。 * 此转换器从不返回。 */ private static final GenericConverter NO_MATCH = new NoOpConverter(\"NO_MATCH\"); private final Converters converters = new Converters(); private final Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = new ConcurrentReferenceHashMap&lt;&gt;(64);&#125;","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]},{"title":"spring 源码解析 2.统一io ResourceLoader","date":"2017-05-06T13:04:01.000Z","path":"2017/05/06/spring-code-resourceloader/","text":"ResourceLoader参考文档：http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources-resourceloader 1.概述ResourceLoader接口的实现旨在返回（加载）Resource 实例。 2.类图 3.接口3.1 ResourceLoader123456789101112131415161718192021222324252627282930/** * 加载资源的策略接口（e ..类路径或文件系统资源）。 * 需要一个&#123;@link org.springframework.context.ApplicationContext&#125;来提供此功能，以及扩展的&#123;@link org.springframework.core.io.support.ResourcePatternResolver&#125;支持。 * &#123;@link DefaultResourceLoader&#125;是一个独立的实现，可以在ApplicationContext之外使用，也由&#123;@link ResourceEditor&#125;使用。 * 在ApplicationContext中运行时，可以使用特定上下文的资源加载策略，从字符串填充Resource类型的Bean属性和Resource数组。 */public interface ResourceLoader &#123; /** * 从类路径加载的伪URL前缀：\"classpath:\" */ String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX; /** * 返回指定资源位置的Resource句柄。 * 句柄应该始终是可重用的资源描述符，允许多个&#123;@link Resource#getInputStream()&#125;调用。 * 必须支持完全限定的URLs，例如 \"file:C:/test.dat\"。 * 必须支持类路径伪URL，例如 \"classpath:test.dat\"。 * 应该支持相对文件路径，例如 \"WEB-INF/test.dat\"。 *（这将是实现特定的，通常由ApplicationContext实现提供） * 请注意，Resource句柄并不表示资源存在; 您需要调用 &#123;@link Resource#exists&#125; 来检查是否存在。 */ Resource getResource(String location); /** * 暴露此ResourceLoader使用的ClassLoader。 * 需要直接访问ClassLoader的客户端可以使用ResourceLoader以统一的方式执行，而不是依赖线程上下文ClassLoader。 */ ClassLoader getClassLoader();&#125; 3.2 ResourcePatternResolver1234567891011121314151617181920212223/** * 用于将位置格式（例如，Ant样式路径格式）解析为Resource对象的策略接口。 * 这是&#123;@link org.springframework.core.io.ResourceLoader&#125;接口的扩展。可以检查传递的ResourceLoader是否实现此扩展接口（例如，在上下文中运行时通过&#123;@link org.springframework.context.ResourceLoaderAware&#125;传递的&#123;@link org.springframework.context.ApplicationContext&#125;）。 * &#123;@link PathMatchingResourcePatternResolver&#125;是一个独立的实现，可在ApplicationContext外部使用，也由&#123;@link ResourceArrayPropertyEditor&#125;用于填充资源阵列bean属性。 * 可以与任何种类的位置模板一起使用（例如“/WEB-INF/*-context.xml”）：输入模板必须与策略实现相匹配。该接口只是指定转换方法而不是特定的模板格式。 * 此接口还为类路径中的所有匹配资源建议一个新的资源前缀 \"classpath*:\"。 * 请注意，在这种情况下，资源位置预计是没有占位符的路径（例如“/beans.xml”）;JAR文件或类目录可以包含同名的多个文件。 */public interface ResourcePatternResolver extends ResourceLoader &#123; /** * 来自类路径的所有匹配资源的伪URL前缀：\"classpath*:\" * 与ResourceLoader的类路径URL前缀不同之处在于它检索给定名称的所有匹配资源（例如“/beans.xml”），例如在所有已部署的JAR文件的根目录中。 */ String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\"; /** * 将给定的位置模板解析为资源对象。 * 应尽可能避免重叠指向相同物理资源的资源条目。结果应该设置语义。 */ Resource[] getResources(String locationPattern) throws IOException;&#125; 4. 抽象类、实现4.1 DefaultResourceLoader12345678910/** * &#123;@link ResourceLoader&#125;接口的默认实现。 * 由&#123;@link ResourceEditor&#125;使用，并作为&#123;@link org.springframework.context.support.AbstractApplicationContext&#125;的基类。 也可以独立使用。 * 如果位置值是URL，则返回&#123;@link UrlResource&#125;，如果它是非URL路径或 \"classpath:\" 伪URL，则返回&#123;@link ClassPathResource&#125;。 */public class DefaultResourceLoader implements ResourceLoader &#123; private ClassLoader classLoader; private final Set&lt;ProtocolResolver&gt; protocolResolvers = new LinkedHashSet&lt;&gt;(4); private final Map&lt;Class&lt;?&gt;, Map&lt;Resource, ?&gt;&gt; resourceCaches = new ConcurrentHashMap&lt;&gt;(4);&#125; 1234567891011/** * 协议特定资源句柄的解析策略。 * 用作&#123;@link DefaultResourceLoader&#125;的SPI，允许在不对载入程序实现（或应用程序上下文实现）创建子类的情况下处理自定义协议。 */@FunctionalInterfacepublic interface ProtocolResolver &#123; /** * 如果此实现的协议匹配，则针对给定的资源加载器解析给定位置。 */ Resource resolve(String location, ResourceLoader resourceLoader);&#125; 4.2 ClassRelativeResourceLoader123456/** * &#123;@link ResourceLoader&#125;实现，将普通资源路径解释为相对于给定的&#123;@code java.lang.Class&#125;。 */public class ClassRelativeResourceLoader extends DefaultResourceLoader &#123; private final Class&lt;?&gt; clazz;&#125; 4.3 FileSystemResourceLoader12345678/** * &#123;@link ResourceLoader&#125;实现，它将简单路径解析为文件系统资源，而不是类路径资源（后者是&#123;@link DefaultResourceLoader&#125;的默认策略））。 * 注意： 即使以斜线开始，平滑路径将始终被解释为相对于当前VM工作目录。 （这与Servlet容器中的语义一致。） * 使用显式的\"file:\"前缀强制执行绝对文件路径。 * &#123;@link org.springframework.context.support.FileSystemXmlApplicationContext&#125;是一个完整的ApplicationContext实现，提供相同的资源路径解析策略。 */public class FileSystemResourceLoader extends DefaultResourceLoader &#123;&#125; 4.4 PathMatchingResourcePatternResolver123456789101112131415161718192021222324252627282930313233343536373839404142/** * 一个&#123;@link ResourcePatternResolver&#125;实现，能够将指定的资源位置路径解析为一个或多个匹配的资源。 * 源路径可以是一个简单的路径，它具有与目标&#123;@link org.springframework.core.io.Resource&#125;的一对一映射，或者可以包含特殊的\"&#123;@code classpath*:&#125;\"前缀 和/或 内部Ant风格的正则表达式（使用Spring的&#123;@link org.springframework.util.AntPathMatcher&#125;实用程序进行匹配）。后两者都是有效的通配符。 * * 没有通配符： * 在简单的情况下，如果指定的位置路径不以&#123;@code \"classpath*:&#125;\"前缀开头，并且不包含PathMatcher模式，则此解析器将简单地通过&#123;@code getResource()&#125;调用底层的&#123;@code ResourceLoader&#125;。 * 示例：真实的URL，例如\"&#123;@code file:C:/context.xml&#125;\"，伪URL（例如\"&#123;@code classpath:/context.xml&#125;\"）和简单的无前缀路径，如\"&#123;@code /WEB-INF/context.xml&#125;\"。 * 后者将以针对&#123;@code ResourceLoader&#125;的特定方式解析（例如&#123;@code WebApplicationContext&#125;的&#123;@code ServletContextResource&#125;）。 * * Ant风格模式： * 当路径位置包含Ant样式模式时，例如： * /WEB-INF/*-context.xml * com/mycompany/** /applicationContext.xml * file:C:/some/path/*-context.xml * classpath:com/mycompany/** /applicationContext.xml * 解析器遵循更复杂但定义的过程来尝试解决通配符。 它为最后一个非通配符段的路径生成一个&#123;@code Resource&#125; ，并从中获取一个&#123;@code URL&#125;。 如果此URL不“&#123;@code jar：&#125;”URL或容器中的特定变体（例如：WebLogic中的&#123;@code zip：&#125;，WebSphere中的&#123;@code wsjar&#125;等），则从它获取&#123;@code java.io.File&#125;，并用于通过走文件系统来解析通配符。 * 在一个jar URL的情况下，解析器从它获取一个&#123;@code java.net.JarURLConnection&#125; 或手动解析jar URL，然后遍历jar文件的内容，以解决通配符。 * * 对可移植性的影响： * 如果指定的路径已经是文件URL（明确地或隐含地），因为基本的&#123;@code ResourceLoader&#125;是一个文件系统的路径，那么通配符将保证以完全可移植的方式工作。 * 如果指定的路径是类路径位置，则解析器必须通过&#123;@code Classloader.getResource()&#125;调用获取最后一个非通配符路径段URL。由于这只是路径的一个节点（而不是最后的文件），在这种情况下，它实际上是未定义的（在ClassLoader Javadocs中）返回的是什么样的URL。实际上，它通常是一个&#123;@code java.io.File&#125;，表示类路径资源解析为文件系统位置的目录，或某个类别的jar URL其中类路径资源解析为一个jar位置。尽管如此，这种操作仍然存在可移植性问题。 * 如果为最后一个非通配符段获取了一个jar URL，解析器必须能够从中获取一个&#123;@code java.net.JarURLConnection&#125;，或者手动解析jar URL，以便能够便利该jar的内容，并解决通配符。这将在大多数环境中工作，但在其他环境中将会失败，并且强烈建议您在依赖它之前，彻底地在您的特定环境中彻底测试来自jar的资源的通配符解析。 * * * &#123;@code classpath*:&#125;前缀： * 通过\"&#123;@code classpath*:&#125;\"前缀，可以检索具有相同名称的多个类路径资源。 * 例如，“&#123;@code classpath *：META-INF / beans.xml&#125;”将在类路径中找到所有“beans.xml”文件，无论是在“classes”目录还是在JAR文件中。这对于在每个jar文件中的同一位置自动检测同名的配置文件特别有用。在内部，这是通过&#123;@code ClassLoader.getResources()&#125;调用发生的，并且是完全可移植的。 * \"classpath*:\"前缀也可以与其他位置路径中的PathMatcher模式相结合，例如\"classpath*:META-INF/*-beans.xml\"。在这种情况下，分辨率策略相当简单：在最后一个非通配符路径段上使用&#123;@code ClassLoader.getResources()&#125;调用，以获取类加载器层次结构中的所有匹配资源，然后便利每个资源上面描述的相同的PathMatcher分辨率策略用于通配符子路径。 * * 其他注意： * 警告：请注意，与匹配模式启动相结合时，\"&#123;@code classpath*:&#125;\" 只能与模式启动前的至少一个根目录一起工作，除非实际的目标 文件驻留在文件系统中。 这意味着像 \"&#123;@code classpath*:*.xml&#125;\" 这样的模式将不会从jar文件的根目录中检索文件，而只能从扩展目录的根目录中获取文件。 这源于JDK的&#123;@code ClassLoader.getResources()&#125;方法中的限制，该方法传入的空String仅返回文件系统位置（指示潜在的搜索根）。此&#123;@code ResourcePatternResolver&#125;实现是通过&#123;@link URLClassLoader&#125;内省和“java.class.path”清单评估来减轻jar根查找限制; 然而，没有可移植性的保证。 * * 警告： 如果要搜索的根包存在多个类路径位置，则不能保证具有 \"classpath:\" 资源的Ant样式模式可以找到匹配的资源。 * 这是因为一个资源，如com/mycompany/package1/service-context.xml 可能只在一个位置，但是当一个路径如 classpath:com/mycompany/** /service-context.xml * 用于尝试解决它，解析器将解决 &#123;@code getResource(\"com/mycompany\");&#125; 返回的（第一个）URL。 如果此基本包节点存在于多个类加载器位置中，则实际的最终资源可能不在下面。 * 因此，在这种情况下，最好使用具有相同Ant样式模式的“&#123;@code classpath *：&#125;”，这将搜索包含根包的所有类路径位置。 */public class PathMatchingResourcePatternResolver implements ResourcePatternResolver &#123; private static final Log logger = LogFactory.getLog(PathMatchingResourcePatternResolver.class); private final ResourceLoader resourceLoader; private PathMatcher pathMatcher = new AntPathMatcher();&#125;","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]},{"title":"spring 源码解析 2.统一io Resource","date":"2017-04-30T06:05:40.000Z","path":"2017/04/30/spring-code-resource/","text":"Resource参考文档：http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources 1.概述Java的标准java.net.URL类和各种URL前缀的标准处理程序不足以满足对低级资源的所有访问。 例如，没有可用于访问需要从类路径或相对于ServletContext获取的资源的标准化URL实现。 虽然可以为专门的URL前缀注册新的处理程序（类似于前缀如http :)的现有处理程序，但这通常是相当复杂的，并且URL接口仍然缺少一些所需的功能，例如检查存在的方法 的资源。 基于以上原因，spring 提供了 ： Resource - 统一资源，规范化操作 ResourceLoader - 统一资源加载操作，屏蔽加载具体实现 2.Resource 2.1 接口 InputStreamSource - 用于获取InputStream，每次都是新的InputStream Resource - 用于获取资源描述，判断资源状态 WritableResource - 可写入资源，用于获取 OutputStream ContextResource - 用于获取封闭上下文的相对路径 2.1.1 InputStreamSource123456789101112131415161718192021package org.springframework.core.io;import java.io.IOException;import java.io.InputStream;/** * 获取 &#123;@link InputStream&#125; 对象的简单接口。 * 是 &#123;@link Resource&#125; 的父接口。 * 对于一次性流，可以使用 &#123;@link InputStreamResource&#125; 提供任何给定的 &#123;@code InputStream&#125; 。 * &#123;@link ByteArrayResource&#125; 或任何基于 &#123;@code Resource&#125; 的实现可以当做实体化的实例使用，允许人们多次读取底层内容流。 * 这使得该接口可用作，例如：邮件附件的抽象内容源。 */public interface InputStreamSource &#123; /** * 返回一个 InputStream 。预期每个调用都会创建一个新的流。 * 当您考虑如JavaMail等的API，在创建邮件附件时，需要多次读取流时，这一需求尤为重要。 * 对于这种用例，需要每个getInputStream（）调用返回一个新的流。 */ InputStream getInputStream() throws IOException;&#125; 2.1.2 Resource123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106package org.springframework.core.io;import java.io.File;import java.io.IOException;import java.io.InputStream;import java.net.URI;import java.net.URL;import java.nio.channels.Channels;import java.nio.channels.ReadableByteChannel;/** * 资源描述符的接口，从基础资源的实际类型（例如文件或类路径资源）抽象。 * 如果每个资源以物理形式存在，则可以打开InputStream。 * 但只能为某些资源返回URL或File句柄。 实际行为是根据具体实现。 */public interface Resource extends InputStreamSource &#123; /** * 判断此资源是否以物理形式存在。 * 该方法执行确定的存在检查。 * 而Resource句柄的存在仅保证有效的描述符句柄。 */ boolean exists(); /** * 指示是否可以通过 getInputStream() 读取此资源的内容。 * 典型资源描述符将为 true ; * 请注意，尝试时实际内容读取可能仍然失败。 * 但是， false 的值是无法读取资源内容的明确指示。 */ default boolean isReadable() &#123; return true; &#125; /** * 指示此资源是否表示具有开放流的句柄。 * 如果 true ，InputStream不能被多次读取，并且必须读取和关闭以避免资源泄漏。 * 对于典型的资源描述符，将是 false 。 */ default boolean isOpen() &#123; return false; &#125; /** * 确定此资源是否表示文件系统中的文件。 * 值&#123;@code true&#125;强烈建议（但不能保证）&#123;@link #getFile（）&#125;调用将成功。 * 默认情况下，是保守的&#123;@code false&#125;。 * @since 5.0 */ default boolean isFile() &#123; return false; &#125; /** * 返回此资源的URL句柄。 */ URL getURL() throws IOException; /** * 返回此资源的URI句柄. */ URI getURI() throws IOException; /** * 返回此资源的文件句柄. */ File getFile() throws IOException; /** * 返回&#123;@link ReadableByteChannel&#125;。 * 预计每个调用都会创建一个新的channel。 * 默认实现返回&#123;@link Channels＃newChannel(InputStream)&#125;，使用&#123;@link #getInputStream()&#125;的结果&#125;）。 * @since 5.0 */ default ReadableByteChannel readableChannel() throws IOException &#123; return Channels.newChannel(getInputStream()); &#125; /** * 确定此资源的内容长度 */ long contentLength() throws IOException; /** * 确定此资源的最后修改的时间戳. */ long lastModified() throws IOException; /** * 创建相对于此资源的资源 */ Resource createRelative(String relativePath) throws IOException; /** * 确定此资源的文件名，即通常是路径的最后一部分：例如“myfile.txt”。 * 如果这种类型的资源没有文件名，返回&#123;@code null&#125;。 */ String getFilename(); /** * 返回此资源的描述，用于处理资源时的错误输出。 * 还鼓励实现类的&#123;@code toString&#125;方法返回此值。 */ String getDescription();&#125; 2.1.3 WritableResource12345678910111213141516171819202122232425262728293031323334353637package org.springframework.core.io;import java.io.IOException;import java.io.OutputStream;/** * 用于支持写入的扩展资源的接口。 * 提供&#123;@link #getOutputStream（）OutputStream 访问方法&#125;。 */public interface WritableResource extends Resource &#123; /** * 指示此资源的内容是否可以通过&#123;@link #getOutputStream（）&#125;写入。 * 对于典型的资源描述符，将是&#123;@code true&#125;; * 请注意，尝试时实际的内容写入可能仍然失败。 * 但是，值&#123;@code false&#125;是资源内容无法修改的明确指示。 */ default boolean isWritable() &#123; return true; &#125; /** * 返回底层资源的&#123;@link OutputStream&#125;，允许（覆盖）写入内容。 */ OutputStream getOutputStream() throws IOException; /** * 返回一个&#123;@link WritableByteChannel&#125;。 * 预计每次调用都会创建一个新鲜的 channel。 * 默认实现返回&#123;@link Channels#newChannel(OutputStream)&#125;，使用&#123;@link #getOutputStream()&#125;的结果）。 * @since 5.0 */ default WritableByteChannel writableChannel() throws IOException &#123; return Channels.newChannel(getOutputStream()); &#125;&#125; 2.1.4 ContextResource123456789101112131415package org.springframework.core.io;/** * 从封闭的“上下文”加载的资源的扩展接口， * 例如 来自&#123;@link javax.servlet.ServletContext&#125;，但也可以使用纯类路径路径或相对文件系统路径（没有明确的前缀指定，因此适用于相对于本地&#123;@link ResourceLoader&#125;的上下文）。 */public interface ContextResource extends Resource &#123; /** * 返回包围的“上下文”中的路径。 * 这通常是相对于上下文特定根目录的路径，例如。 一个ServletContext根或一个PortletContext根。 */ String getPathWithinContext(); &#125; 2.2 抽象实现类2.2.1 AbstractResource12345678910/** * 实现&#123;@link Resource&#125;的便利基类，预先实现典型行为。 * “存在”方法将检查是否可以打开File或InputStream; * “isOpen”将永远返回false; * “getURL”和“getFile”抛出异常; * “toString”将返回描述。 */public abstract class AbstractResource implements Resource &#123; &#125; 2.2.2 DescriptiveResource1234567/** * 简单的 &#123;@link Resource&#125; 实现，保存资源描述，但不指向实际可读的资源。 * 如果API需要 &#123;@code Resource&#125; 参数，但不一定用于实际读取时被用作占位符。 */public class DescriptiveResource extends AbstractResource &#123; private final String description;&#125; 2.2.3 VfsResource1234567/** * 基于JBoss VFS的&#123;@link Resource&#125;实现。 * 从Spring 4.0开始，该类支持JBoss AS 6+上的VFS 3.x（软件包&#123;@code org.jboss.vfs&#125;），特别兼容JBoss AS 7和WildFly 8。 */public class VfsResource extends AbstractResource &#123; private final Object resource;&#125; 2.2.4 InputStreamResource1234567891011121314/** * &#123;@link Resource&#125;实现给定的&#123;@link InputStream&#125;。 * 只有在没有其他特定的 &#123;@code Resource&#125; 实现适用的情况下才使用。 * 特别是，尽可能选择&#123;@link ByteArrayResource&#125;或任何基于文件的&#123;@code Resource&#125;实现。 * * 与其他&#123;@code Resource&#125;实现相反，这是一个已经打开的资源的描述符，因此从&#123;@link #isOpen()&#125;返回 &#123;@code true&#125;。 * 如果您需要将资源描述符保留在某处，或者您需要多次读取数据流，请勿使用&#123;@code InputStreamResource&#125;。 * */public class InputStreamResource extends AbstractResource &#123; private final InputStream inputStream; private final String description; private boolean read = false;&#125; 2.2.5 ByteArrayResource12345678910/** * 一个给定的字节数组的 &#123;@link Resource&#125;实现。 * 为给定的字节数组创建&#123;@link ByteArrayInputStream&#125;。 * 用于从任何给定的字节数组加载内容，而无需使用单次使用的&#123;@link InputStreamResource&#125;。 * 特别适用于从本地内容创建邮件附件，JavaMail需要能够多次读取流。 */public class ByteArrayResource extends AbstractResource &#123; private final byte[] byteArray; private final String description;&#125; 2.2.6 AbstractFileResolvingResource123456/** * 用于将URL解析为文件引用的资源的抽象基类，例如&#123;@link UrlResource&#125;或&#123;@link ClassPathResource&#125;。 * 在URL中检测“文件”协议以及 JBoss“vfs”协议，相应地解析文件系统引用。 */public abstract class AbstractFileResolvingResource extends AbstractResource &#123;&#125; 2.2.7 UrlResource123456789101112131415161718192021/** * &#123;@code java.net.URL&#125;定位器的&#123;@link Resource&#125;实现。 * 在&#123;@code“file：”&#125;协议的情况下支持解析为&#123;@code URL&#125;，还可以作为&#123;@code File&#125;。 */public class UrlResource extends AbstractFileResolvingResource &#123; /** * 如果有值，原始URI; 用于URI和文件访问。 */ private final URI uri; /** * 原始URL，用于实际访问。 */ private final URL url; /** * 已清理的URL（具有标准化路径），用于比较。 */ private final URL cleanedUrl;&#125; 所有URL都具有标准化的字符串表示形式，以便使用适当的标准化前缀来区分URL类型。例如：文件系统路径 file:，HTTP协议http:，FTPftp:除了几个已知前缀如classpatch会创建适当的Resource，不认识的前缀会作为标准 URL 串创。建UrlResource。 2.2.8 ClassPathResource1234567891011/** * 路径资源的&#123;@link Resource&#125;实现。 使用给定的&#123;@link ClassLoader&#125;或给定的&#123;@link Class&#125;来加载资源。 * 如果类路径资源驻留在文件系统中，则支持&#123;@code java.io.File&#125;的解析。 * 但不支持JAR中的资源 * 始终支持解析为URL。 */public class ClassPathResource extends AbstractFileResolvingResource &#123; private final String path; private ClassLoader classLoader; private Class&lt;?&gt; clazz;&#125; classpath:创建ClassPathResource。从classpath下加载的资源。不管是从线程classloader，给定classloader还是class。都可以使用此Resource。 2.2.9 PathResource12345678/** * &#123;@code java.nio.file.Path&#125;句柄的&#123;@link Resource&#125;实现。 * 支持分辨率为File，也可以作为URL。 * 实现扩展的&#123;@link WritableResource&#125;接口。 */public class PathResource extends AbstractResource implements WritableResource &#123; private final Path path;&#125; 2.2.10 FileSystemResource123456789/** * &#123;@code java.io.File&#125;句柄的&#123;@link Resource&#125;实现。 * 支持作为&#123;@code File&#125;和&#123;@code URL&#125;的解析。 * 实现扩展的&#123;@link WritableResource&#125;界面。 */public class FileSystemResource extends AbstractResource implements WritableResource &#123; private final File file; private final String path;&#125; 2.2.10 FileSystemContextResource12345/** * FileSystemResource，通过实现ContextResource接口显式表达上下文相对路径。 */private static class FileSystemContextResource extends FileSystemResource implements ContextResource &#123;&#125; 2.2.11 ClassRelativeContextResource123456 /** * ClassPathResource通过实现ContextResource接口显式表达上下文相对路径。 */ private static class ClassRelativeContextResource extends ClassPathResource implements ContextResource &#123; private final Class&lt;?&gt; clazz;&#125; 2.2.12 ClassPathContextResource12345/** * ClassPathResource通过实现ContextResource接口显式表达上下文相对路径。 */protected static class ClassPathContextResource extends ClassPathResource implements ContextResource &#123;&#125;","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]},{"title":"spring 源码解析 1.概述","date":"2017-04-30T03:45:41.000Z","path":"2017/04/30/spring-code-overview/","text":"一、干了这碗鸡汤阅读源码比较晦涩。读不懂，读了就忘，abandon 肯定会发生。届时请自行喝鸡汤。 阅读前 - 必须要形成自己的阅读源码的动机，意识上做出决定。彻底拥抱spring，在所有 java 项目中使用 spring famework 阅读过程中 - 做有效阅读，一面要揣测作者意图；理解方法作用。一面分析设计模式；设想扩展场景。 阅读后 - 提炼精髓，提高编程修养，提升设计能力。1.阅读目标 了解使用 spring 提供的绝大部分功能，工具类。不重复造轮子。达到脱离 ApplicationContext 独立使用 spring 模块。 扩展，定制 ApplicationContext。2.阅读方法 正确的阅读方式： 自下而上：根据包来绘制类图，从父类读到子类 自上而下：根据方法绘制时序图，从子类读到父类 错误的阅读方式：debug跟踪 模块化集中阅读。 二、概述基于 spring 5.0.0.M5 版本阅读。 阅读本系列博客，默认你已经拥有： java 基础 uml 类图、时序图阅读能力 spring 5.0.0.M5参考文档阅读经验 1.模块 2.pom ArtifactId 功能 spring-context 应用程序，包括context组装，JMX，Jndi，缓存，定时调度，rmi，validation spring-core 核心实用程序，asm，cglib，io，env，线程池 spring-beans Beans支持，bean属性，BeanFactory，包括Groovy spring-expression Spring Expression Language (SpEL) spring-aop 基于代理的AOP支持 3.ApplicationContextApplicationContext提供的功能点： Resource、ResourceLoader、ResourcePatternResolver - 提供统一的 io 操作 Enviroment - 提供各种配置源的变量统一读取 *BeanFactory - 提供层级化，可罗列的BeanFactory获取Bean ApplicationEventPublish - 提供发布订阅的监听者模式实现 MessageSource - 提供i18n 本系列博客将按照 资源，加载环境，读取bean配置，生成Factory，处理事件，实例化Bean，aop的顺序(core,bean,context,aop)的顺序来阅读讲解","tags":[{"name":"spring container","slug":"spring-container","permalink":"http://leerenbo.cn/tags/spring-container/"}]}]