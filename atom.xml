<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>李仁博的博客</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://leerenbo.cn/"/>
  <updated>2017-12-15T06:05:24.000Z</updated>
  <id>http://leerenbo.cn/</id>
  
  <author>
    <name>李仁博</name>
    <email>447430787@qq.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>aspectj</title>
    <link href="http://leerenbo.cn/2017/12/09/aspectj/"/>
    <id>http://leerenbo.cn/2017/12/09/aspectj/</id>
    <published>2017-12-09T05:21:23.000Z</published>
    <updated>2017-12-15T06:05:24.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-AspectJ简介"><a href="#1-AspectJ简介" class="headerlink" title="1.AspectJ简介"></a>1.AspectJ简介</h1><p>安装<br><a href="https://www.eclipse.org/aspectj/" target="_blank" rel="external">https://www.eclipse.org/aspectj/</a><br>工具<br><a href="https://www.jetbrains.com/help/idea/aspectj.html" target="_blank" rel="external">https://www.jetbrains.com/help/idea/aspectj.html</a><br>文档<br><a href="https://www.eclipse.org/aspectj/doc/released/progguide/index.html" target="_blank" rel="external">https://www.eclipse.org/aspectj/doc/released/progguide/index.html</a><br><a href="https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html" target="_blank" rel="external">https://www.eclipse.org/aspectj/doc/released/adk15notebook/index.html</a><br><a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html" target="_blank" rel="external">https://www.eclipse.org/aspectj/doc/released/devguide/index.html</a></p>
<h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1 简介"></a>1.1 简介</h2><h3 id="Join-Point-Signatures"><a href="#Join-Point-Signatures" class="headerlink" title="Join Point Signatures"></a>Join Point Signatures</h3><p>AspectJ 支持 11 种 join points ：<br>method call, method execution, constructor call, constructor execution, field get, field set, pre-initialization, initialization, static initialization, handler, and advice execution </p>
<p>Pointcuts 选择 join points<br>使用 9 种 指示符：<br>call, execution, get, set, preinitialization, initialization, staticinitialization, handler, and adviceexecution</p>
<table>
<thead>
<tr>
<th>Join Point Kind</th>
<th>Subject</th>
</tr>
</thead>
<tbody>
<tr>
<td>Method call</td>
<td>The method picked out by Java as the static target of the method call.</td>
</tr>
<tr>
<td>Method execution</td>
<td>The method that is executing.</td>
</tr>
<tr>
<td>Constructor call</td>
<td>The constructor being called.</td>
</tr>
<tr>
<td>Constructor execution</td>
<td>The constructor executing.</td>
</tr>
<tr>
<td>Field get</td>
<td>The field being accessed.</td>
</tr>
<tr>
<td>Field set</td>
<td>The field being set.</td>
</tr>
</tbody>
</table>
<p><a href="https://www.eclipse.org/aspectj/doc/released/devguide/index.html|" target="_blank" rel="external">https://www.eclipse.org/aspectj/doc/released/devguide/index.html|</a> Initialization        | The first constructor executing in this constructor chain.             |<br>| Static initialization | The type being initialized.                                            |<br>| Handler               | The declared type of the exception being handled.                      |<br>| Advice execution      | The advice being executed.                                             |</p>
<p>Pointcuts 使用 patterns 、signature、 modifiers 来匹配，例如 call pointcut</p>
<pre><code>call(ModifierPattern TypePattern TypePattern.IdPattern(TypePatternList) ThrowsPattern)
</code></pre><p>modifiers： ModifierPattern ThrowsPattern<br>signature： TypePattern TypePattern.IdPattern(TypePatternList)</p>
<h4 id="Join-Point-Signatures-1"><a href="#Join-Point-Signatures-1" class="headerlink" title="Join Point Signatures"></a>Join Point Signatures</h4><table>
<thead>
<tr>
<th>Join Point Kind</th>
<th>Return Type</th>
<th>Declaring Type</th>
<th>Id</th>
<th>Parameter Types</th>
<th>Field Type</th>
<th>Exception Type</th>
</tr>
</thead>
<tbody>
<tr>
<td>Method call</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Method execution</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Constructor call</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Constructor execution</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Field get</td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>Field set</td>
<td></td>
<td>+</td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
</tr>
<tr>
<td>Pre-initialization</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Initialization</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
</tr>
<tr>
<td>Static initialization</td>
<td></td>
<td>+</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>Handler</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>+</td>
</tr>
<tr>
<td>Advice execution</td>
<td></td>
<td>+</td>
<td></td>
<td>+</td>
<td></td>
</tr>
</tbody>
</table>
<p>注意，虽然 advice excetution 签名包含  declaring type 、 parameter types。 adviceexecution pointcut指示符不支持匹配签名。</p>
<p>除了 field 的 get set, 和 method 的 call execution 切点可以有多个签名, 其他 join point 是明确的。<br>method 的 call 或 execution join point 有相同的 id 和 parameter types ，但 Declaring Type 和 Return Type 可能有多个。<br>field  的 get 或 set join point 有相同的 id 和 field type 但是 declaring type 可能有多个。</p>
<h5 id="Method-call-join-point-signatures"><a href="#Method-call-join-point-signatures" class="headerlink" title="Method call join point signatures"></a>Method call join point signatures</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">interface <span class="type">Q</span> &#123;</div><div class="line">  <span class="type">R</span> m(<span class="type">String</span> s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> <span class="title">implements</span> <span class="title">Q</span> </span>&#123;</div><div class="line">  <span class="type">R</span> m(<span class="type">String</span> s) &#123;...&#125;        </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</div><div class="line">  <span class="type">R</span>' m(<span class="type">String</span> s) &#123;...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">S</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">T t = <span class="keyword">new</span> T(); </div><div class="line">t.m(<span class="string">"hello"</span>);  &lt;= call <span class="built_in">join</span> <span class="built_in">point</span> occurs when <span class="keyword">this</span> <span class="built_in">line</span> is executed</div></pre></td></tr></table></figure>
<pre><code>R(T) T.m(parameter_types)

R&apos; S.m(String)
R  P.m(String)
R  Q.m(String)
</code></pre><h5 id="Method-execution-join-point-signatures"><a href="#Method-execution-join-point-signatures" class="headerlink" title="Method execution join point signatures"></a>Method execution join point signatures</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">interface <span class="type">Q</span> &#123;</div><div class="line">  <span class="type">R</span> m(<span class="type">String</span> s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> <span class="title">implements</span> <span class="title">Q</span> </span>&#123;</div><div class="line">  <span class="type">R</span> m(<span class="type">String</span> s) &#123;...&#125;        </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</div><div class="line">  <span class="type">R</span>' m(<span class="type">String</span> s) &#123;...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">S</span> </span>&#123; &#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">U</span> <span class="keyword">extends</span> <span class="title">T</span> </span>&#123;</div><div class="line">  <span class="type">R</span>' m(<span class="type">String</span> s) &#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<pre><code>R&apos; U.m(String)
R&apos; S.m(String)
R  P.m(String)
R  Q.m(String)
</code></pre><h5 id="Field-get-and-set-join-point-signatures"><a href="#Field-get-and-set-join-point-signatures" class="headerlink" title="Field get and set join point signatures"></a>Field get and set join point signatures</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span>  </span>&#123;</div><div class="line">  <span class="type">F</span> f;        </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</div><div class="line">  <span class="type">F</span> f;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">S</span> </span>&#123; &#125;</div></pre></td></tr></table></figure>
<pre><code>F S.f
F T.f
注意：没有 F P.f
</code></pre><h4 id="Join-Point-Modifiers"><a href="#Join-Point-Modifiers" class="headerlink" title="Join Point Modifiers"></a>Join Point Modifiers</h4><p>每一个 join point 都有一些 modifiers。包括：<br>java 的 modifiers public, private, static, abstract 等<br>任何 annotations<br>methods 和 constructors 的 throws 从句</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">public class X &#123;        </div><div class="line">  @<span class="type">Foo</span></div><div class="line">  protected <span class="built_in">void</span> doIt() <span class="meta">&#123;...&#125;</span> </div><div class="line">&#125;</div><div class="line"></div><div class="line">public class Y extends X &#123;        </div><div class="line">  public <span class="built_in">void</span> doIt() <span class="meta">&#123;...&#125;</span>        </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果调用(Y y) y.doIt();  modifiers 是 public<br>如果调用(X x) x.doIt();  modifiers 是 @Foo,protected</p>
<h4 id="Summary-of-Join-Point-Matching"><a href="#Summary-of-Join-Point-Matching" class="headerlink" title="Summary of Join Point Matching"></a>Summary of Join Point Matching</h4><p>可以有多个 signatures 限定。只能有一个 modifiers 限定。</p>
<p>当且仅当满足以下条件时，一个Pointcut才匹配特定的连接点：<br>他们是同一kind(9种之一)<br>signature （严格）匹配至少一个连接点的签名<br>modifiers 匹配连接点的主体的修饰符</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">interface <span class="type">Q</span> &#123;</div><div class="line">  <span class="type">R</span> m(<span class="type">String</span> s);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">P</span> <span class="title">implements</span> <span class="title">Q</span> </span>&#123;</div><div class="line">  <span class="meta">@Foo</span></div><div class="line">  public <span class="type">R</span> m(<span class="type">String</span> s) &#123;...&#125;        </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">S</span> <span class="keyword">extends</span> <span class="title">P</span> </span>&#123;</div><div class="line">  <span class="meta">@Bar</span></div><div class="line">  public <span class="type">R</span>' m(<span class="type">String</span> s) &#123;...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> <span class="keyword">extends</span> <span class="title">S</span> </span>&#123;&#125;</div></pre></td></tr></table></figure>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">P p = new P()<span class="comment">;</span></div><div class="line">S s = new S()<span class="comment">;</span></div><div class="line">T t = new T()<span class="comment">;</span></div><div class="line">...</div><div class="line">p.m(<span class="string">"hello"</span>)<span class="comment">;</span></div><div class="line">s.m(<span class="string">"hello"</span>)<span class="comment">;   </span></div><div class="line">t.m(<span class="string">"hello"</span>)<span class="comment">;</span></div></pre></td></tr></table></figure>
<p>call(@Foo R P.m(String))  signature与modifiers都匹配  s.m(“hello”);<br>call(R’ m(String))  匹配  t.m(“hello”)  s.m(“hello”)   不匹配  p.m(“hello”)</p>
<h3 id="Annotations"><a href="#Annotations" class="headerlink" title="Annotations"></a>Annotations</h3><h4 id="Annotations-in-Java-5"><a href="#Annotations-in-Java-5" class="headerlink" title="Annotations in Java 5"></a>Annotations in Java 5</h4><p>@Inherited<br>@Retention(RetentionPolicy.RUNTIME)<br>@Target(value = {ElementType.METHOD,ElementType.TYPE})</p>
<p>@this,@target and @args 需要 runtime retention<br>@within, @withincode and @annotation 最少需要 class-file retention，如果用于binding形式，必须使用runtime retention。</p>
<h4 id="Annotating-Aspects"><a href="#Annotating-Aspects" class="headerlink" title="Annotating Aspects"></a>Annotating Aspects</h4><p>AspectJ 5 支持 annotations 在 aspects, 和 aspects 内部的 method, field, constructor, advice, 和 inter-type declarations 上。<br>不允许在 pointcut declarations 或 declare statements 上。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AspectAnnotation</span></div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">aspect</span> <span class="title">ObserverProtocol</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@InterfaceAnnotation</span></div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;&#125;		</div><div class="line"></div><div class="line">	<span class="meta">@InterfaceAnnotation</span></div><div class="line">	<span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="meta">@ITDFieldAnnotation</span></div><div class="line">	<span class="keyword">private</span> List&lt;Observer&gt; Subject.observers;  </div><div class="line">		</div><div class="line">	<span class="meta">@ITDMethodAnnotation</span></div><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> Subject.<span class="title">addObserver</span><span class="params">(Observer o)</span> </span>&#123; </div><div class="line">	  observers.add(o);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@ITDMethodAnnotation</span></div><div class="line">	<span class="keyword">public</span> <span class="function"><span class="keyword">void</span> Subject.<span class="title">removeObserver</span><span class="params">(Observer o)</span> </span>&#123;</div><div class="line">	  observers.remove(o);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="meta">@MethodAnnotation</span></div><div class="line">	<span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Subject subject)</span> </span>&#123;</div><div class="line">	  <span class="keyword">for</span>(Observer o : subject.observers) </div><div class="line">	    notifyObserver(o,subject);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Delegate to concrete sub-aspect the actual form of</div><div class="line">	 * notification for a given type of Observer.</div><div class="line">	 */</div><div class="line">	<span class="meta">@MethodAnnotation</span></div><div class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">notifyObserver</span><span class="params">(Observer o, Subject s)</span></span>;</div><div class="line">	</div><div class="line">	<span class="comment">/* no annotations on pointcuts */</span></div><div class="line">	<span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">pointcut</span> <span class="title">observedEvent</span>(Subject subject);</div><div class="line">	</div><div class="line">	<span class="meta">@AdviceAnnotation</span></div><div class="line">	<span class="keyword">after</span>(Subject subject) <span class="keyword">returning</span> : <span class="title">observedEvent</span>(subject) &#123;</div><div class="line">		notifyObservers(subject);  </div><div class="line">	&#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>@SuppressAjWarnings 压制静态匹配为空的advice警告。</p>
<h4 id="Join-Point-Matching-based-on-Annotations"><a href="#Join-Point-Matching-based-on-Annotations" class="headerlink" title="Join Point Matching based on Annotations"></a>Join Point Matching based on Annotations</h4><h5 id="Annotation-Patterns"><a href="#Annotation-Patterns" class="headerlink" title="Annotation Patterns"></a>Annotation Patterns</h5><p>annotation 匹配的两种自出形式<br>@<qualified-name>, 例如, @Foo, or @org.xyz.Foo.<br>@(<type-pattern>), 例如, @(org.xyz..*), or @(Foo || Boo)</type-pattern></qualified-name></p>
<p>@Immutable<br>Matches any annotated element which has an annotation of type Immutable.</p>
<p>!@Persistent<br>Matches any annotated element which does not have an annotation of type Persistent.</p>
<p>@Foo @Goo<br>Matches any annotated element which has both an annotation of type Foo and an annotation of type Goo.</p>
<p>@(Foo || Goo)<br>Matches any annotated element which has either an annotation of a type matching the type pattern (Foo || Goo). In other words, an annotated element with either an annotation of type Foo or an annotation of type Goo (or both). (The parenthesis are required in this example).</p>
<p>@(org.xyz..<em>)<br>Matches any annotated element which has either an annotation of a type matching the type pattern (org.xyz..</em>). In other words, an annotated element with an annotation that is declared in the org.xyz package or a sub-package. (The parenthesis are required in this example).</p>
<h5 id="Type-Patterns"><a href="#Type-Patterns" class="headerlink" title="Type Patterns"></a>Type Patterns</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"> 	TypePattern := SimpleTypePattern |</div><div class="line"> 	               <span class="string">'!'</span> TypePattern |</div><div class="line"> 	               <span class="string">'('</span> AnnotationPattern? TypePattern <span class="string">')'</span></div><div class="line"> 	               TypePattern <span class="string">'&amp;&amp;'</span> TypePattern |</div><div class="line"> 	               TypePattern <span class="string">'||'</span> TypePattern </div><div class="line"> 	</div><div class="line"> 	SimpleTypePattern := DottedNamePattern <span class="string">'+'</span>? <span class="string">'[]'</span>*</div><div class="line"> 	</div><div class="line">DottedNamePattern := FullyQualifiedName RestOfNamePattern? |</div><div class="line">                     <span class="string">'*'</span> NotStarNamePattern?</div><div class="line"></div><div class="line">RestOfNamePattern := <span class="string">'..'</span> DottedNamePattern |</div><div class="line">                     <span class="string">'*'</span> NotStarNamePattern?</div><div class="line">                     </div><div class="line">NotStarNamePattern := FullyQualifiedName RestOfNamePattern? |</div><div class="line">                      <span class="string">'..'</span> DottedNamePattern               </div><div class="line"></div><div class="line">FullyQualifiedName := JavaIdentifierCharacter+ (<span class="string">'.'</span> JavaIdentifierCharacter+)*</div></pre></td></tr></table></figure>
<p>The following examples illustrate the use of annotations in type patterns:</p>
<p>(@Immutable *)<br>Matches any type with an @Immutable annotation.</p>
<p>(!@Immutable *)<br>Matches any type which does not have an @Immutable annotation.</p>
<p>(@Immutable (org.xyz.<em> || org.abc.</em>))<br>Matches any type in the org.xyz or org.abc packages with the @Immutable annotation.</p>
<p>((@Immutable Foo+) || Goo)<br>Matches a type Foo or any of its subtypes, which have the @Immutable annotation, or a type Goo.</p>
<p>((@(Immutable || NonPersistent) org.xyz..*)<br>Matches any type in a package beginning with the prefix org.xyz, which has either the @Immutable annotation or the @NonPersistent annotation.</p>
<p>(@Immutable @NonPersistent org.xyz..*)<br>Matches any type in a package beginning with the prefix org.xyz, which has both an @Immutable annotation and an @NonPersistent annotation.</p>
<p>(@(@Inherited <em>) org.xyz..</em>)<br>Matches any type in a package beginning with the prefix org.xyz, which has an inheritable annotation. The annotation pattern @(@Inherited <em>) matches any annotation of a type matching the type pattern @Inherited </em>, which in turn matches any type with the @Inherited annotation.</p>
<h5 id="Signature-Patterns"><a href="#Signature-Patterns" class="headerlink" title="Signature Patterns"></a>Signature Patterns</h5><h6 id="Field-Patterns"><a href="#Field-Patterns" class="headerlink" title="Field Patterns"></a>Field Patterns</h6><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">		FieldPattern := </div><div class="line">		    AnnotationPattern? FieldModifiersPattern? </div><div class="line">		    TypePattern (TypePattern DotOrDotDot)? SimpleNamePattern</div><div class="line"></div><div class="line">FieldModifiersPattern := <span class="string">'!'</span>? FieldModifier FieldModifiersPattern*</div><div class="line">                         		</div><div class="line">FieldModifier := <span class="string">'public'</span> | <span class="string">'private'</span> | <span class="string">'protected'</span> | <span class="string">'static'</span> | </div><div class="line">                 <span class="string">'transient'</span> | <span class="string">'final'</span> </div><div class="line"></div><div class="line">DotOrDotDot := <span class="string">'.'</span> | <span class="string">'..'</span>		            		      </div><div class="line">            		      		            			</div><div class="line">SimpleNamePattern := JavaIdentifierChar+ (<span class="string">'*'</span> SimpleNamePattern)?</div></pre></td></tr></table></figure>
<p>@SensitiveData <em> </em><br>Matches a field of any type and any name, that has an annotation of type @SensitiveData</p>
<p>@SensitiveData List org.xyz..<em>.</em><br>Matches a member field of a type in a package with prefix org.xzy, where the field is of type List, and has an annotation of type @SensitiveData</p>
<p>(@SensitiveData <em>) org.xyz..</em>.*<br>Matches a member field of a type in a package with prefix org.xzy, where the field is of a type which has a @SensitiveData annotation.</p>
<p>@Foo (@Goo <em>) (@Hoo </em>).*<br>Matches a field with an annotation @Foo, of a type with an annotation @Goo, declared in a type with annotation @Hoo.</p>
<p>@Persisted @Classified <em> </em><br>Matches a field with an annotation @Persisted and an annotation @Classified.</p>
<h6 id="Method-and-Constructor-Patterns"><a href="#Method-and-Constructor-Patterns" class="headerlink" title="Method and Constructor Patterns"></a>Method and Constructor Patterns</h6><p>MethodPattern<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">		MethodPattern := </div><div class="line">		    AnnotationPattern? MethodModifiersPattern? TypePattern </div><div class="line">		                       (TypePattern DotOrDotDot)? SimpleNamePattern </div><div class="line">		                       <span class="string">'('</span> FormalsPattern <span class="string">')'</span>ThrowsPattern?</div><div class="line"></div><div class="line">MethodModifiersPattern := <span class="string">'!'</span>? MethodModifier MethodModifiersPattern*</div><div class="line"></div><div class="line">MethodModifier := <span class="string">'public'</span> | <span class="string">'private'</span> | <span class="string">'protected'</span> | <span class="string">'static'</span> | </div><div class="line">                  <span class="string">'synchronized'</span> | <span class="string">'final'</span> </div><div class="line">            		      </div><div class="line">FormalsPattern := <span class="string">'..'</span> (<span class="string">','</span> FormalsPatternAfterDotDot)* |</div><div class="line">                  OptionalParensTypePattern (<span class="string">','</span> FormalsPattern)* |</div><div class="line">                  TypePattern <span class="string">'...'</span></div><div class="line">                  </div><div class="line">FormalsPatternAfterDotDot := </div><div class="line">        OptionalParensTypePattern (<span class="string">','</span> FormalsPatternAfterDotDot)* |</div><div class="line">        TypePattern <span class="string">'...'</span></div><div class="line">                                               		                  </div><div class="line">ThrowsPattern := <span class="string">'throws'</span> TypePatternList</div><div class="line"></div><div class="line">TypePatternList := TypePattern (<span class="string">','</span> TypePattern)*</div></pre></td></tr></table></figure></p>
<p>ConstructorPattern<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">		ConstructorPattern := </div><div class="line">		    AnnotationPattern? ConstructorModifiersPattern?  </div><div class="line">		                       (TypePattern DotOrDotDot)? <span class="string">'new'</span> <span class="string">'('</span> FormalsPattern <span class="string">')'</span></div><div class="line">		                       ThrowsPattern?</div><div class="line">	</div><div class="line">ConstructorModifiersPattern := <span class="string">'!'</span>? ConstructorModifier ConstructorModifiersPattern*</div><div class="line"></div><div class="line">ConstructorModifier := <span class="string">'public'</span> | <span class="string">'private'</span> | <span class="string">'protected'</span></div></pre></td></tr></table></figure></p>
<p>@Oneway <em> </em>(..)<br>Matches a method with any return type and any name, that has an annotation of type @Oneway.</p>
<p>@Transaction <em> (@Persistent org.xyz..</em>).*(..)<br>Matches a method with the @Transaction annotation, declared in a type with the @Persistent annotation, and in a package beginning with the org.xyz prefix.</p>
<ul>
<li><em>.</em>(@Immutable *,..)<br>Matches any method taking at least one parameter, where the parameter type has an annotation @Immutable.</li>
</ul>
<h5 id="Example-Pointcuts"><a href="#Example-Pointcuts" class="headerlink" title="Example Pointcuts"></a>Example Pointcuts</h5><p>within(@Secure *)<br>Matches any join point where the code executing is declared in a type with an @Secure annotation. The format of the within pointcut designator in AspectJ 5 is ‘within’ ‘(‘ OptionalParensTypePattern ‘)’.</p>
<p>staticinitialization(@Persistent *)<br>Matches the staticinitialization join point of any type with the @Persistent annotation. The format of the staticinitialization pointcut designator in AspectJ 5 is ‘staticinitialization’ ‘(‘ OptionalParensTypePattern ‘)’.</p>
<p>call(@Oneway <em> </em>(..))<br>Matches a call to a method with a @Oneway annotation.</p>
<p>execution(public (@Immutable <em>) org.xyz..</em>.*(..))<br>The execution of any public method in a package with prefix org.xyz, where the method returns an immutable result.</p>
<p>set(@Cachable <em> </em>)<br>Matches the set of any cachable field.</p>
<p>handler(!@Catastrophic *)<br>Matches the handler join point for the handling of any exception that is not Catastrophic. The format of the handler pointcut designator in AspectJ 5 is ‘handler’ ‘(‘ OptionalParensTypePattern ‘)’.</p>
<h5 id="Runtime-type-matching-and-context-exposure"><a href="#Runtime-type-matching-and-context-exposure" class="headerlink" title="Runtime type matching and context exposure"></a>Runtime type matching and context exposure</h5><p>AspectJ 5 支持  “@” pointcut 指示器，用于运行时 annotation 存在校验，和 annotation 环境绑定 ： @args, @this, @target, @within, @withincode, and @annotation。</p>
<hr>
<p>使用 @this, @target or @args 在编译时如果 annotation 保留策略不是 runtime 的 annotation会报错。<br><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">AtThis := <span class="string">'@this'</span> <span class="string">'('</span> AnnotationOrIdentifer <span class="string">')'</span></div><div class="line">    </div><div class="line">AtTarget := <span class="string">'@target'</span> <span class="string">'('</span> AnnotationOrIdentifier <span class="string">')'</span></div><div class="line">  	</div><div class="line">AnnotationOrIdentifier := FullyQualifiedName | Identifier</div><div class="line"> </div><div class="line">AtArgs := <span class="string">'@args'</span> <span class="string">'('</span> AnnotationsOrIdentifiersPattern <span class="string">')'</span></div><div class="line"> </div><div class="line">AnnotationsOrIdentifiersPattern :=</div><div class="line">                  <span class="string">'..'</span> (<span class="string">','</span> AnnotationsOrIdentifiersPatternAfterDotDot)? |</div><div class="line">                  AnnotationOrIdentifier (<span class="string">','</span> AnnotationsOrIdentifiersPattern)* |</div><div class="line">                  <span class="string">'*'</span> (<span class="string">','</span> AnnotationsOrIdentifiersPattern)*</div><div class="line">             </div><div class="line">AnnotationsOrIdentifiersPatternAfterDotDot := </div><div class="line">             AnnotationOrIdentifier (<span class="string">','</span> AnnotationsOrIdentifiersPatternAfterDotDot)* |</div><div class="line">             <span class="string">'*'</span> (<span class="string">','</span> AnnotationsOrIdentifiersPatternAfterDotDot)*</div></pre></td></tr></table></figure></p>
<p>@this(Foo)<br>Matches any join point where the object currently bound to ‘this’ has an annotation of type Foo.</p>
<p>call(<em> </em>(..)) &amp;&amp; @target(Classified)<br>Matches a call to any object where the target of the call has a @Classified annotation.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">pointcut callToClassifiedObject(Classified classificationInfo) :</div><div class="line">    call(* *(..)) &amp;&amp; @target(classificationInfo);</div><div class="line"></div><div class="line">pointcut txRequiredMethod(Tx transactionAnnotation) :</div><div class="line">    execution(* *(..)) &amp;&amp; @this(transactionAnnotation) </div><div class="line">    &amp;&amp; if(transactionAnnotation.policy() == TxPolicy.REQUIRED);</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">/**</div><div class="line"> * matches any join point with at least one argument, and where the</div><div class="line"> * type of the first argument has the @Classified annotation</div><div class="line"> */</div><div class="line">pointcut classifiedArgument() : @args(Classified,..);</div><div class="line"></div><div class="line">/**</div><div class="line"> * matches any join point with three arguments, where the third</div><div class="line"> * argument has an annotation of type @Untrusted.</div><div class="line"> */</div><div class="line">pointcut untrustedData(Untrusted untrustedDataSource) : </div><div class="line">    @args(*,*,untrustedDataSource);</div></pre></td></tr></table></figure>
<p>除了context绑定，还可以从thisJoinPoint, thisJoinPointStaticPart, and thisEnclosingJoinPointStaticPart中获取AnnotatedElement<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Annotation[] thisAnnotations = thisJoinPoint.getThis().getClass().getAnnotations();</div><div class="line">Annotation[] targetAnnotations = thisJoinPoint.getTarget().getClass().getAnnotations();</div><div class="line">Annotation[] firstParamAnnotations = thisJoinPoint.getArgs()[0].getClass().getAnnotations();</div></pre></td></tr></table></figure></p>
<hr>
<p>@within 有指定 annotation 注释的类中。<br>@withincode 有指定 annotation 注释的方法中。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">AtWithin</span> := <span class="string">'<span class="variable">@within</span>'</span> <span class="string">'('</span> AnnotationOrIdentifier <span class="string">')'</span></div><div class="line">AtWithinCode := <span class="string">'<span class="variable">@withincode</span>'</span> <span class="string">'('</span> AnnotationOrIdentifier <span class="string">')'</span></div></pre></td></tr></table></figure></p>
<p>@within(Foo)<br>Matches any join point where the executing code is defined within a type which has an annotation of type Foo.</p>
<p>pointcut insideCriticalMethod(Critical c) : @withincode(c);<br>Matches any join point where the executing code is defined in a method or constructor which has an annotation of type @Critical, and exposes the value of the annotation in the parameter c.</p>
<hr>
<p>@annotation  任何 join point 的主题上有给定的类型。可用于context曝光。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">AtAnnotation := &apos;@annotation&apos; &apos;(&apos; AnnotationOrIdentifier &apos;)&apos;</div></pre></td></tr></table></figure></p>
<h5 id="Package-and-Parameter-Annotations"><a href="#Package-and-Parameter-Annotations" class="headerlink" title="Package and Parameter Annotations"></a>Package and Parameter Annotations</h5><p>不支持package annotations，未来可能支持。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">@SomeAnnotation</div><div class="line">@SomeOtherAnnotation</div><div class="line">class AnnotatedType &#123;&#125;</div><div class="line"></div><div class="line">class C &#123;</div><div class="line">  public void foo(AnnotatedType a) &#123;&#125;</div><div class="line">  public void goo(@SomeAnnotation String s) &#123;&#125;</div><div class="line">  public void hoo(@SomeAnnotation AnnotatedType a) &#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pointcut p(): execution(* *(@SomeAnnotation *));  method foo</div><div class="line">pointcut p(): execution(* *(@SomeAnnotation (*)));  method goo</div><div class="line">pointcut p(): execution(* *(@SomeAnnotation (@SomeOtherAnnotation *)));  method hoo</div></pre></td></tr></table></figure>
<h5 id="Annotation-Inheritance-and-pointcut-matching"><a href="#Annotation-Inheritance-and-pointcut-matching" class="headerlink" title="Annotation Inheritance and pointcut matching"></a>Annotation Inheritance and pointcut matching</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C1</span> </span>&#123;</div><div class="line">  <span class="meta">@SomeAnnotation</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aMethod</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C2</span> <span class="keyword">extends</span> <span class="title">C1</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aMethod</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    C1 c1 = <span class="keyword">new</span> C1();</div><div class="line">    C2 c2 = <span class="keyword">new</span> C2();</div><div class="line">    c1.aMethod();</div><div class="line">    c2.aMethod();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">aspect</span> <span class="title">X</span> </span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">pointcut</span> <span class="title">annotatedC2MethodCall</span>() : </div><div class="line">    <span class="keyword">call</span>(@SomeAnnotation * C2.aMethod());</div><div class="line"></div><div class="line">  <span class="keyword">pointcut</span> <span class="title">annotatedMethodCall</span>() :</div><div class="line">    <span class="keyword">call</span>(@SomeAnnotation * aMethod());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>annotatedC2MethodCall 匹配不到任何属性。因为C2.aMethod方法没有任何注释。<br>annotatedMethodCall 匹配到C1.aMethod() 没有c2.aMethod()</p>
<h5 id="Matching-based-on-annotation-values"><a href="#Matching-based-on-annotation-values" class="headerlink" title="Matching based on annotation values"></a>Matching based on annotation values</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">pointcut txRequiredMethod(Tx transactionAnnotation) :</div><div class="line">    execution(* *(..)) &amp;&amp; @this(transactionAnnotation) </div><div class="line">    &amp;&amp; if(transactionAnnotation.policy() == TxPolicy.REQUIRED);</div></pre></td></tr></table></figure>
<h4 id="Using-Annotations-with-declare-statements"><a href="#Using-Annotations-with-declare-statements" class="headerlink" title="Using Annotations with declare statements"></a>Using Annotations with declare statements</h4><h5 id="Declare-error-and-declare-warning"><a href="#Declare-error-and-declare-warning" class="headerlink" title="Declare error and declare warning"></a>Declare error and declare warning</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">declare warning : withincode(@PerformanceCritical * *(..)) &amp;&amp;</div><div class="line">                  call(@ExpensiveOperation * *(..))</div><div class="line">                : &quot;Expensive operation called from within performance critical section&quot;;</div><div class="line">                </div><div class="line">declare error : call(* org.xyz.model.*.*(..)) &amp;&amp;</div><div class="line">                !@within(Trusted)</div><div class="line">                : &quot;Untrusted code should not call the model classes directly&quot;;</div></pre></td></tr></table></figure>
<h5 id="declare-parents"><a href="#declare-parents" class="headerlink" title="declare parents"></a>declare parents</h5><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> <span class="keyword">parents</span> : TypePattern <span class="keyword">extends</span> Type;</div><div class="line"><span class="keyword">declare</span> <span class="keyword">parents</span> : TypePattern <span class="keyword">implements</span> TypeList;</div></pre></td></tr></table></figure>
<p>declare parents : (@Secured *) implements SecuredObject;<br>    All types with the @Secured annotation implement the SecuredObject inteface.</p>
<p>declare parents : (@Secured BankAccount+) implements SecuredObject;<br>    The subset of types drawn from the BankAccount type and any subtype of BankAccount, where the @Secured annotation is present, implement the SecuredObject interface.</p>
<h5 id="declare-precedence"><a href="#declare-precedence" class="headerlink" title="declare precedence"></a>declare precedence</h5><figure class="highlight ada"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">declare</span> precedence : <span class="type">TypePatList</span>;</div></pre></td></tr></table></figure>
<p>declare precedence : (@Security <em>),</em>;<br>    All aspects with the @Security annotation take precedence over any other aspects in the system. (Or, more informally, all security-related aspects take precedence).</p>
<h4 id="Declare-Annotation"><a href="#Declare-Annotation" class="headerlink" title="Declare Annotation"></a>Declare Annotation</h4><p>AspectJ 5 支持一种新的 declare statement, declare annotation<br>不同的 annotation 接收方，有不同的形式。<br>declare @type for types<br>declare @method for methods<br>declare @constructor for constructors<br>declare @field for fields<br>declare @package may be supported in a future release.</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">declare <span class="meta">@&lt;kind&gt;</span> : ElementPattern : Annotation ;</div><div class="line"></div><div class="line">  	        ElementPattern := TypePattern |<span class="string"></span></div><div class="line">   	                          MethodPattern |</div><div class="line">   	                          ConstructorPattern |<span class="string"></span></div><div class="line">   	                          FieldPattern</div></pre></td></tr></table></figure>
<p>declare @type : org.xyz.model..* : @BusinessDomain ;<br>All types defined in a package with the prefix org.xyz.model have the @BusinessDomain annotation.</p>
<p>declare @method : public <em> BankAccount+.</em>(..) : @Secured(role=”supervisor”)<br>All public methods in BankAccount and its subtypes have the annotation @Secured(role=”supervisor”).</p>
<p>declare @constructor : BankAccount+.new(..) : @Secured(role=”supervisor”)<br>All constructors in BankAccount and its subtypes have the annotation @Secured(role=”supervisor”).</p>
<p>declare @field : <em> DAO+.</em> : @Persisted;<br>All fields defined in DAO or its subtypes have the @Persisted annotation.</p>
<h4 id="Inter-type-Declarations"><a href="#Inter-type-Declarations" class="headerlink" title="Inter-type Declarations"></a>Inter-type Declarations</h4><p>annotation type 不能作为 inter-type 声明的目标。</p>
<h3 id="Generics"><a href="#Generics" class="headerlink" title="Generics"></a>Generics</h3><h4 id="Generics-in-AspectJ-5"><a href="#Generics-in-AspectJ-5" class="headerlink" title="Generics in AspectJ 5"></a>Generics in AspectJ 5</h4><h5 id="Matching-generic-and-parameterized-types-in-pointcut-expressions"><a href="#Matching-generic-and-parameterized-types-in-pointcut-expressions" class="headerlink" title="Matching generic and parameterized types in pointcut expressions"></a>Matching generic and parameterized types in pointcut expressions</h5><p>在 pointcut 中使用泛型和参数化类型最简单的方式是，使用 raw type。例如：List 会匹配 List<e>。这将保证jdk 5以前的兼容性。除非你想明确缩小匹配泛型类型，否则这是建议方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Utils</span> </span>&#123;</div><div class="line">  </div><div class="line">  <span class="comment">/** static generic method */</span></div><div class="line">  <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">first</span><span class="params">(List&lt;T&gt; ts)</span> </span>&#123; ... &#125;</div><div class="line">  </div><div class="line">  <span class="comment">/** instance generic method */</span></div><div class="line">  &lt;T extends Number&gt; <span class="function">T <span class="title">max</span><span class="params">(T t1, T t2)</span> </span>&#123; ... &#125;</div><div class="line">      </div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">G</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"> </div><div class="line">   <span class="comment">// field with parameterized type</span></div><div class="line">   T myData;</div><div class="line">   </div><div class="line">   <span class="comment">// method with parameterized return type</span></div><div class="line">   <span class="function"><span class="keyword">public</span> List&lt;T&gt; <span class="title">getAllDataItems</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure></e></p>
<p>AspectJ 不允许使用type variables进行pointcut类型匹配。<br>Java5 定义泛型擦除如下<br>The erasure of a parameterized type T<t1,...,tn> is |T|. For example, the erasure of List<string> is List.<br>The erasure of a nested type T.C is |T|.C. For example, the erasure of the nested type Foo<t>.Bar is Foo.Bar.<br>The erasure of an array type T[] is |T|[]. For example, the erasure of List<string>[] is List[].<br>The erasure of a type variable is its leftmost bound. For example, the erasure of a type variable P is Object, and the erasure of a type variable N extends Number is Number.<br>The erasure of every other type is the type itself</string></t></string></t1,...,tn></p>
<p>根据擦除规则。<br>Utils  signature 为 static Object Utils.first(List)   Number Utils.max(Number, Number)<br>G  signature 为  Object G.myData   public List G.getAllDataItems()</p>
<h6 id="Restricting-matching-using-parameterized-types"><a href="#Restricting-matching-using-parameterized-types" class="headerlink" title="Restricting matching using parameterized types"></a>Restricting matching using parameterized types</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</div><div class="line">  </div><div class="line">  List&lt;String&gt; myStrings;</div><div class="line">  List&lt;Float&gt;  myFloats;</div><div class="line">      </div><div class="line">  <span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getStrings</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> myStrings; &#125;</div><div class="line">  <span class="function"><span class="keyword">public</span> List&lt;Float&gt; <span class="title">getFloats</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> myFloats; &#125;</div><div class="line">      </div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStrings</span><span class="params">(List&lt;String&gt; evenMoreStrings)</span> </span>&#123;</div><div class="line">     myStrings.addAll(evenMoreStrings);   </div><div class="line">  &#125;</div><div class="line">      </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>myStrings 可以被 get(List Foo.myStrings) 和 get(List<string> Foo.myStrings) 匹配。但是不能被get(List<number> <em>) 匹配。<br>myFloats  可以被 get(List Foo.myFloats)  get(List<float> </float></em>)  和 get(List<number+> *) 匹配。</number+></number></string></p>
<p>getStrings() 和 getFloats() 可以被 execution(List get<em>(..)) execution(List&lt;</em>&gt; get<em>(..)) 匹配。<br>getStrings() 可以被 execution(List<string> get</string></em>(..))<br>getFloats() 可以被 execution(List<number+> get*(..))</number+></p>
<p>注意 type variable 总会被擦除<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">          <span class="class"><span class="keyword">class</span> <span class="title">G</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	        <span class="function">List&lt;T&gt; <span class="title">foo</span><span class="params">(List&lt;String&gt; ls)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">null</span>; &#125;</div><div class="line">          &#125;</div><div class="line">``` </div><div class="line">foo() 可以被 execution(<span class="function">List <span class="title">foo</span><span class="params">(List)</span>), <span class="title">execution</span><span class="params">(List foo(List&lt;String&gt;&gt;)</span>), and <span class="title">execution</span><span class="params">(* foo(List&lt;String&lt;)</span>) </span></div><div class="line">但是不能被 <span class="title">execution</span><span class="params">(List&lt;Object&gt; foo(List&lt;String&gt;&gt;)</span> 匹配。因为 List&lt;T&gt; 被擦除为 List 而非 List&lt;Object&gt;</div><div class="line"></div><div class="line">###### Generic wildcards and signature matching</div><div class="line">```java</div><div class="line">          class C &#123;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(List&lt;? extends Number&gt; listOfSomeNumberType)</span> </span>&#123;&#125;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bar</span><span class="params">(List&lt;?&gt; listOfSomeType)</span> </span>&#123;&#125;</div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goo</span><span class="params">(List&lt;Double&gt; listOfDoubles)</span> </span>&#123;&#125;	</div><div class="line">          &#125;</div></pre></td></tr></table></figure></p>
<p>execution(<em> C.</em>(List))<br>Matches an execution join point for any of the three methods.</p>
<p>execution(<em> C.</em>(List&lt;? extends Number&gt;))<br>matches only the execution of foo, and not the execution of goo since List&lt;? extends Number&gt; and List<double> are distinct types.</double></p>
<p>execution(<em> C.</em>(List&lt;?&gt;))<br>matches only the execution of bar.</p>
<p>execution(<em> C.</em>(List&lt;? extends Object+&gt;))<br>matches both the execution of foo and the execution of bar since the upper bound of List&lt;?&gt; is implicitly Object.</p>
<h6 id="Treatment-of-bridge-methods"><a href="#Treatment-of-bridge-methods" class="headerlink" title="Treatment of bridge methods"></a>Treatment of bridge methods</h6><h6 id="Runtime-type-matching-with-this-target-and-args"><a href="#Runtime-type-matching-with-this-target-and-args" class="headerlink" title="Runtime type matching with this(), target() and args()"></a>Runtime type matching with this(), target() and args()</h6><h6 id="Binding-return-values-in-after-returning-advice"><a href="#Binding-return-values-in-after-returning-advice" class="headerlink" title="Binding return values in after returning advice"></a>Binding return values in after returning advice</h6><h6 id="Declaring-pointcuts-inside-generic-types"><a href="#Declaring-pointcuts-inside-generic-types" class="headerlink" title="Declaring pointcuts inside generic types"></a>Declaring pointcuts inside generic types</h6><h5 id="Inter-type-Declarations-1"><a href="#Inter-type-Declarations-1" class="headerlink" title="Inter-type Declarations"></a>Inter-type Declarations</h5><h5 id="Declare-Parents"><a href="#Declare-Parents" class="headerlink" title="Declare Parents"></a>Declare Parents</h5><h5 id="Declare-Soft"><a href="#Declare-Soft" class="headerlink" title="Declare Soft"></a>Declare Soft</h5><h5 id="Generic-Aspects"><a href="#Generic-Aspects" class="headerlink" title="Generic Aspects"></a>Generic Aspects</h5><h3 id="Autoboxing-and-Unboxing"><a href="#Autoboxing-and-Unboxing" class="headerlink" title="Autoboxing and Unboxing"></a>Autoboxing and Unboxing</h3><h4 id="Autoboxing-and-Join-Point-matching-in-AspectJ-5"><a href="#Autoboxing-and-Join-Point-matching-in-AspectJ-5" class="headerlink" title="Autoboxing and Join Point matching in AspectJ 5"></a>Autoboxing and Join Point matching in AspectJ 5</h4><p>基于 signatures 匹配的 pointcut 不受影响。Integer 和 int 区分表示。<br>args 受自动封包解包影响：<br>args(Integer) and args(int) are equivalent<br>args(Float) and args(float) are equivalent<br>args(Double) and args(double) are equivalent<br>args(Short) and args(short) are equivalent<br>args(Byte) and args(byte) are equivalent<br>args(Long) and args(long) are equivalent<br>args(Boolean) and args(boolean) are equivalent</p>
<h4 id="Inter-type-method-declarations-and-method-dispatch"><a href="#Inter-type-method-declarations-and-method-dispatch" class="headerlink" title="Inter-type method declarations and method dispatch"></a>Inter-type method declarations and method dispatch</h4><p>根据以下算法选择调用的目标方法：</p>
<ol>
<li>不考虑自动装包解包与可变变量调用，尝试定位匹配的方法 或 inter-type declared 方法</li>
<li>如果没有找到匹配，则尝试使用自动装包解包。</li>
<li>最后同时考虑自动装包解包与可变变量调用。</li>
</ol>
<h3 id="Covariance"><a href="#Covariance" class="headerlink" title="Covariance"></a>Covariance</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">public</span> A <span class="title">whoAreYou</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">extends</span> <span class="title">A</span> </span>&#123;</div><div class="line">  <span class="comment">// override A.whoAreYou *and* narrow the return type.</span></div><div class="line">  <span class="function"><span class="keyword">public</span> B <span class="title">whoAreYou</span><span class="params">()</span> </span>&#123;...&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>a.whoAreYou()  signatures   A A.whoAreYou()<br>b.whoAreYou()  signatures      A A.whoAreYou()  B B.whoAreYou()</p>
<p>call(* whoAreYou())<br>Matches both calls, (since each call join point has at least one matching signature).</p>
<p>call(* A.whoAreYou())<br>Matches both calls, (since each call join point has at least one matching signature).</p>
<p>call(A whoAreYou())<br>Matches both calls, (since each call join point has at least one matching signature).</p>
<p>call(A B.whoAreYou())<br>Does not match anything - neither of the call join points has a signature matched by this pattern. A lint warning is given for the call a.whoAreYou() (“does not match because declaring type is A, if match required use target(B)”).</p>
<p>call(A+ B.whoAreYou())<br>Matches the call to b.whoAreYou() since the signature pattern matches the signature B B.whoAreYou(). A lint warning is given for the call a.whoAreYou() (“does not match because declaring type is A, if match required use target(B)”).</p>
<p>call(B A.whoAreYou())<br>Does not match anything since neither join point has a signature matched by this pattern.</p>
<p>call(B whoAreYou())<br>Matches the call to b.whoAreYou() only.</p>
<p>call(B B.whoAreYou())<br>Matches the call to b.whoAreYou() only.</p>
<h3 id="Varargs"><a href="#Varargs" class="headerlink" title="Varargs"></a>Varargs</h3><h4 id="Using-Variable-length-arguments-in-advice-and-pointcut-expressions"><a href="#Using-Variable-length-arguments-in-advice-and-pointcut-expressions" class="headerlink" title="Using Variable-length arguments in advice and pointcut expressions"></a>Using Variable-length arguments in advice and pointcut expressions</h4><p>AspectJ 5 允许变长参数声明在 apects内部、inter-type、构造方法 。同样允许通过pointcut表达式匹配和advice绑定。</p>
<h5 id="Matching-signatures-based-on-variable-length-argument-types"><a href="#Matching-signatures-based-on-variable-length-argument-types" class="headerlink" title="Matching signatures based on variable length argument types"></a>Matching signatures based on variable length argument types</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">	FormalsPattern := <span class="string">'..'</span> (<span class="string">','</span> FormalsPatternAfterDotDot)? |</div><div class="line">                  OptionalParensTypePattern (<span class="string">','</span> FormalsPattern)* |</div><div class="line">                  TypePattern <span class="string">'...'</span></div><div class="line">                  </div><div class="line">FormalsPatternAfterDotDot := </div><div class="line">        OptionalParensTypePattern (<span class="string">','</span> FormalsPatternAfterDotDot)* |</div><div class="line">        TypePattern <span class="string">'...'</span></div></pre></td></tr></table></figure>
<p>用于 call, execution, initialization, preinitialization, and withincode pointcut designators.</p>
<p>call(<em> org.xyz.</em>.*(int, String…))<br>Matches a call join point for a call to a method defined in the org.xyz package, taking an int and a String vararg.</p>
<p>execution(<em> org.xyz.</em>.*(Integer…))<br>Matches an execution join point for the execution of a method defined in the org.xyz package, taking an Integer vararg.</p>
<p>initialization(org.xyz.*.new((Foo || Goo)…))<br>Matches the initialization join point for the construction of an object in the org.xyz package via a constructor taking either a variable number of Foo parameters or a variable number of Goo parameters. (This example illustrating the use of a type pattern with …).</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">void foo(String...);</div><div class="line">void bar(String[]);</div></pre></td></tr></table></figure>
<p>execution(<em> </em>.<em>(String…)) 匹配 foo<br>execution(</em> <em>.</em>(String[]))  比配 bar</p>
<h5 id="Exposing-variable-length-arguments-as-context-in-pointcuts-and-advice"><a href="#Exposing-variable-length-arguments-as-context-in-pointcuts-and-advice" class="headerlink" title="Exposing variable-length arguments as context in pointcuts and advice"></a>Exposing variable-length arguments as context in pointcuts and advice</h5><p>不能使用 args(int,String…)，使用args(int,String[]) 代替<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">void</span> foo(<span class="keyword">int</span> i, <span class="keyword">String</span>... strings) &#123; </div><div class="line">&#125;</div><div class="line"></div><div class="line">before(<span class="keyword">int</span> i, <span class="keyword">String</span>[] ss) : call(* foo(<span class="keyword">int</span>,<span class="keyword">String</span>...)) &amp;&amp; args(i,ss) &#123;</div><div class="line">  <span class="comment">// varargs String... argument is accessible in advice body through ss</span></div><div class="line">  <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="Enumerated-Types"><a href="#Enumerated-Types" class="headerlink" title="Enumerated Types"></a>Enumerated Types</h3><p>构造函数私有，不能被继承，隐性继承 java.lang.Enum</p>
<h4 id="Enumerated-Types-in-AspectJ-5"><a href="#Enumerated-Types-in-AspectJ-5" class="headerlink" title="Enumerated Types in AspectJ 5"></a>Enumerated Types in AspectJ 5</h4><p>AspectJ 有额外限制:<br>You cannot use declare parents to change the super type of an enum.<br>You cannot use declare parents to declare java.lang.Enum as the parent of any type.<br>You cannot make inter-type constructor declarations on an enum.<br>You cannot extend the set of values in an enum via any ITD-like construct.<br>You cannot make inter-type method or field declarations on an enum.<br>You cannot use declare parents to make an enum type implement an interface.</p>
<p>后两个理论上可以支持。但是 AspectJ 遵循枚举类型不能作为 inter-type 声明 与 declare parents。可能在未来的版本中放开。</p>
<p>join point 运行时的每个方法调用都是一个不同的连接点，即使它来自程序中相同的调用表达式。</p>
<p>call vs. execution</p>
<pre><code>1. within 和 withincode 匹配不同
call(void m()) &amp;&amp; withincode(void m()) 表示 m() 的递归调用。execution(void m()) &amp;&amp; withincode(void m()) 等效 execution(void m())
2. call() 非静态方法的 super() 调用不会捕获执行adivce。 
经验是，如果关注方法的执行，使用execution，如果关注具体方法名的调用使用call。
</code></pre><h3 id="1-1-2-Advice"><a href="#1-1-2-Advice" class="headerlink" title="1.1.2 Advice"></a>1.1.2 Advice</h3><h3 id="1-1-3-Inter-type-declarations"><a href="#1-1-3-Inter-type-declarations" class="headerlink" title="1.1.3 Inter-type declarations"></a>1.1.3 Inter-type declarations</h3><h3 id="1-1-4-Aspects"><a href="#1-1-4-Aspects" class="headerlink" title="1.1.4 Aspects"></a>1.1.4 Aspects</h3><p>aspect 由AspectJ 初始化，不能使用Java 的 new 构造方法。默认使用单例模式，所以 aspect 中不需要使用 static 属性来共享状态。</p>
<h2 id="Load-Time-Weaving"><a href="#Load-Time-Weaving" class="headerlink" title="Load-Time Weaving"></a>Load-Time Weaving</h2><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>AspectJ 编制把 class 文件做为输入，产出class文件作为输出。织入过程可能发生在3个不同时期：compile-time, post-compile time, and load-time。class 文件和表现的行为相同，与织入选择无关，</p>
<ul>
<li><p>Compile-time weaving：是最简单的方法，当你有应用源码ajc会编译产出class文件。编织调用是ajc编译的一部分。aspects，可以是源码或二进制形式。如果受影响的class在编译期需要aspect。那么你必须在编译期织入。aspects需要的情况例如：其他被编译类引用了 apsect 添加的成员。</p>
</li>
<li><p>Post-compile weaving (also sometimes called binary weaving) ：被用于编织已经存在的 class 和 JAR 文件。与 Comile-time weaving 一样。 aspects 可以是源码或二进制形式，甚至aspects本身就被其他aspects织入了。</p>
</li>
<li><p>Load-time weaving (LTW) ：只是 Post-compile weaving 延时到 classloader 加载 class 文件和定义class 文件到JVM时。为了支持这个特性，一个或多个 weaving class loaders ，在运行环境被明确提供，或需要通过 weaving agent 开启。 </p>
</li>
</ul>
<p>你可能听过 “run-time weaving” 。我们定义为，织入已经加载到JVM的 classes 文件（而且无需重新加载他们）。AspectJ 5没有提供对运行时编织的明确支持，虽然简单的编码模式可以支持动态启用和禁用方面的建议。</p>
<h4 id="Weaving-class-files-more-than-once"><a href="#Weaving-class-files-more-than-once" class="headerlink" title="Weaving class files more than once"></a>Weaving class files more than once</h4><p>AspectJ 5 的切面和植入的 classes 默认是可以重新织入。旧版的ajc编译器需要指定-Xreweavable来支持load-time weaving。这允许AspectJ添加额外的信息到class中用于随后的重织入。</p>
<h4 id="Load-time-Weaving-Requirements"><a href="#Load-time-Weaving-Requirements" class="headerlink" title="Load-time Weaving Requirements"></a>Load-time Weaving Requirements</h4><p>aspectjweaver.jar</p>
<h2 id="2-开发Aspects"><a href="#2-开发Aspects" class="headerlink" title="2 开发Aspects"></a>2 开发Aspects</h2><h3 id="1-2-1-Trace"><a href="#1-2-1-Trace" class="headerlink" title="1.2.1 Trace"></a>1.2.1 Trace</h3><h3 id="1-2-2-打点与Log"><a href="#1-2-2-打点与Log" class="headerlink" title="1.2.2 打点与Log"></a>1.2.2 打点与Log</h3><h3 id="1-2-3-入参出参校验"><a href="#1-2-3-入参出参校验" class="headerlink" title="1.2.3 入参出参校验"></a>1.2.3 入参出参校验</h3><h3 id="1-2-4-强制规范（如方法禁止）"><a href="#1-2-4-强制规范（如方法禁止）" class="headerlink" title="1.2.4 强制规范（如方法禁止）"></a>1.2.4 强制规范（如方法禁止）</h3><h2 id="3-生产Aspects"><a href="#3-生产Aspects" class="headerlink" title="3 生产Aspects"></a>3 生产Aspects</h2><h3 id="1-3-1-方法-属性Monitoring"><a href="#1-3-1-方法-属性Monitoring" class="headerlink" title="1.3.1 方法/属性Monitoring"></a>1.3.1 方法/属性Monitoring</h3><h3 id="1-3-2-环境传递（样式）"><a href="#1-3-2-环境传递（样式）" class="headerlink" title="1.3.2 环境传递（样式）"></a>1.3.2 环境传递（样式）</h3><h3 id="1-3-3-一致的方法行为，如异常处理"><a href="#1-3-3-一致的方法行为，如异常处理" class="headerlink" title="1.3.3 一致的方法行为，如异常处理"></a>1.3.3 一致的方法行为，如异常处理</h3><h3 id="1-3-4-方法开关"><a href="#1-3-4-方法开关" class="headerlink" title="1.3.4 方法开关"></a>1.3.4 方法开关</h3><h3 id="1-3-5-alive检测"><a href="#1-3-5-alive检测" class="headerlink" title="1.3.5 alive检测"></a>1.3.5 alive检测</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-AspectJ简介&quot;&gt;&lt;a href=&quot;#1-AspectJ简介&quot; class=&quot;headerlink&quot; title=&quot;1.AspectJ简介&quot;&gt;&lt;/a&gt;1.AspectJ简介&lt;/h1&gt;&lt;p&gt;安装&lt;br&gt;&lt;a href=&quot;https://www.eclipse
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>AOP</title>
    <link href="http://leerenbo.cn/2017/11/25/spring-AOP/"/>
    <id>http://leerenbo.cn/2017/11/25/spring-AOP/</id>
    <published>2017-11-25T13:21:52.000Z</published>
    <updated>2017-12-15T03:48:29.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="5-1-介绍"><a href="#5-1-介绍" class="headerlink" title="5.1.介绍"></a>5.1.介绍</h1><p>面向切面编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象编程（OOP）。 OOP中模块化的关键单元是类，而AOP中模块化的单元是aspect。 Aspects可以使关注的模块化，例如跨越多种类型和对象的事务管理。 </p>
<h1 id="5-1-1-概念"><a href="#5-1-1-概念" class="headerlink" title="5.1.1 概念"></a>5.1.1 概念</h1><p>Aspect: 横切多个类的模块。 事务管理是企业Java应用程序中横切关注的一个很好的例子。 在Spring AOP中，切面可以使用类（基于xml的方法）或@Aspect注解（@AspectJ风格）标注的通用类。</p>
<p>Join point: 一个程序的执行，如方法的执行或异常的处理过程中的一个点。 在Spring AOP中，连接点总是代表一个方法的执行。</p>
<p>Advice: 在切面的一个特定采取行动的连接点。 不同类型的建议包括“周围”，“之前”和“之后”的建议。 （建议类型将在下面讨论。）许多AOP框架，包括Spring，都将建议建模为拦截器，在连接点周围维护一个拦截器链。</p>
<p>Pointcut: 一个匹配连接点的判断。 将Advice与Join point用表达式相关联，并在切入点匹配的任何连接点（例如，执行具有特定名称的方法）上运行。 与切入点表达式匹配的连接点的概念是AOP的核心，Spring默认使用AspectJ切入点表达式语言。</p>
<p>Introduction: 代表类型声明额外方法或字段。 Spring AOP允许您向任何建议的对象引入新的接口（和相应的实现）。 例如，您可以使用 introduction 来使bean实现一个IsModified接口，以简化缓存。 （在AspectJ社区中，introduction被称为一个inter-type declaration。）</p>
<p>Target object: 对象被一个或多个方面建议。 也被称为被建议对象。 由于Spring AOP是使用运行时代理实现的，因此该对象将始终是代理对象。</p>
<p>AOP proxy: 一个由AOP框架创建的对象，用于实现切面合约（建议方法执行等等）。 在Spring框架中，AOP代理将是JDK动态代理或CGLIB代理。</p>
<p>Weaving: 链接切面与其他应用程序类型或对象，创建建议的对象。 这可以在编译时（例如使用AspectJ编译器），加载时间或运行时完成。 像其他纯Java AOP框架一样，Spring AOP在运行时执行编织。</p>
<p>advice 类型<br>Before advice: 在连接点之前执行的建议，但无法阻止执行流程继续到连接点（除非抛出异常）。</p>
<p>After returning advice: 连接点正常完成后要执行的建议：例如，如果方法返回而不抛出异常。</p>
<p>After throwing advice: 如果方法通过抛出异常退出，则要执行的建议。</p>
<p>After (finally) advice: 无论加入点退出的方式（正常或异常退回），要执行的建议。</p>
<p>Around advice: 围绕连接点（如方法调用）的建议。 这是最强大的建议。 周围的建议可以在方法调用之前和之后执行自定义行为。 它还负责选择是否继续加入点，还是通过返回自己的返回值或引发异常来缩短建议的方法执行。</p>
<p>建议使用能够实现所需行为的功能最低的 advice 类型.<br>pointcuts 是AOP的关键，能独立于对象继承关系来建议方法。</p>
<h1 id="5-1-2-Spring-AOP的功能和目标"><a href="#5-1-2-Spring-AOP的功能和目标" class="headerlink" title="5.1.2 Spring AOP的功能和目标"></a>5.1.2 Spring AOP的功能和目标</h1><p>Spring AOP是用纯Java实现的。 不需要特殊的编译过程。 Spring AOP不需要控制类加载器层次结构，因此适用于Servlet容器或应用程序服务器。</p>
<p>Spring AOP目前仅支持方法执行连接点（建议Spring bean的方法的执行）。 虽然可以在不破坏核心Spring AOP API的情况下添加对属性拦截的支持，但没实现属性拦截。 如果您需要建议属性访问和更新连接点，请考虑使用诸如AspectJ之类的语言。</p>
<p>Spring AOP的AOP方法与其他大多数AOP框架不同。 目标不是提供最完整的AOP实现（尽管Spring AOP是相当有能力的）; 而是提供AOP实现和Spring IoC之间的紧密集成，以帮助解决企业应用程序中的常见问题。</p>
<p>因此，例如，Spring框架的AOP功能通常与Spring IoC容器一起使用。 切面使用正常的bean定义语法进行配置（尽管这允许强大的“自动代理”功能）：这是与其他AOP实现的关键区别。 有些事情你不能用Spring AOP轻松或有效地完成，比如建议非常细粒度的对象（比如域对象）：在这种情况下，AspectJ是最好的选择。 但是，我们的经验是，Spring AOP为适用于AOP的企业Java应用程序中的大多数问题提供了极好的解决方案。</p>
<p>Spring AOP将永远不会与AspectJ竞争提供全面的AOP解决方案。 我们认为像Spring AOP这样的基于代理的框架和像AspectJ这样的全面的框架都是有价值的，而且它们是互补的，而不是竞争。 Spring将Spring AOP和IoC与AspectJ无缝集成，以便在一致的基于Spring的应用程序体系结构中满足AOP的所有用途。 此集成不影响Spring AOP API或AOP Alliance API：Spring AOP保持向后兼容。 有关Spring AOP API的讨论，请参阅以下章节。</p>
<h1 id="5-1-3-AOP代理"><a href="#5-1-3-AOP代理" class="headerlink" title="5.1.3 AOP代理"></a>5.1.3 AOP代理</h1><p>Spring AOP 代理默认使用标准JDK动态代理。 这使得任何接口（或一组接口）都可以被代理。</p>
<p>Spring AOP也可以使用CGLIB代理。 这是代理 类而不是接口的必要条件。 如果业务对象没有实现接口，则默认使用CGLIB。 面向接口编程而不是类是个好习惯; 业务类通常会实现一个或多个业务接口。 可以强制使用CGLIB，在那些需要建议未在接口中声明的方法的情况下（希望很少），或者需要将代理对象作为具体类型传递给方法的情况。</p>
<p>掌握Spring AOP是基于代理的事实是很重要的。 请参阅了解AOP代理，以彻底检查此实现细节的实际含义。</p>
<h1 id="5-2-AspectJ-support"><a href="#5-2-AspectJ-support" class="headerlink" title="5.2. @AspectJ support"></a>5.2. @AspectJ support</h1><p><a href="https://www.eclipse.org/aspectj/" target="_blank" rel="external">https://www.eclipse.org/aspectj/</a></p>
<h1 id="5-2-1-Configuration-EnableAspectJAutoProxy"><a href="#5-2-1-Configuration-EnableAspectJAutoProxy" class="headerlink" title="5.2.1 @Configuration @EnableAspectJAutoProxy"></a>5.2.1 @Configuration @EnableAspectJAutoProxy</h1><h1 id="5-2-2-Aspect"><a href="#5-2-2-Aspect" class="headerlink" title="5.2.2 @Aspect"></a>5.2.2 @Aspect</h1><h1 id="5-2-3-Pointcut"><a href="#5-2-3-Pointcut" class="headerlink" title="5.2.3 @Pointcut"></a>5.2.3 @Pointcut</h1><p>execution - 用于匹配方法执行的连接点，在使用Spring AOP时，你会使用的主要切入点指示符<br>execution(modifiers-pattern? ret-type-pattern declaring-type-pattern?name-pattern(param-pattern) throws-pattern?)<br>modifiers-pattern 作用域<br>ret-type-pattern 返回类型(必填) <em> 匹配所有类型。只有当方法返回给定类型时，完全限定类型名称才会匹配。<br>declaring-type-pattern 如果指定类型匹配，需要使用后缀 . 来加入name-pattern。 ..</em>包及子包<br>name-pattern <em> 作为全部或部分方法名称<br>param-pattern ()无参数； (..)任意参数； (</em>)一个任意类型参数； </p>
<p>within - 限定匹配某些路径类型的连接点</p>
<p>this - 限定匹配类型的连接点，常用于绑定形式。advice中可以获取 proxy 对象。</p>
<p>target - 限定匹配类型的连接点，常用于绑定形式。advice中可以获取 target 对象。</p>
<p>args - 限定匹配参数类型的连接点，常用于绑定形式。advice中可以获取 方法参数。<br>args(java.io.Serializable) 区别 execution(<em> </em>(java.io.Serializable))。args，只要有参数是Serializable就匹配。execution只有一个参数且是Serializable才匹配。</p>
<p>@target - 限定匹配方法有指定 annotation 的连接点，常用于绑定形式。advice中可以获取 annotation 对象。</p>
<p>@args - 限定匹配参数有 annotation 的连接点，常用于绑定形式。advice中可以获取 annotation 对象。</p>
<p>@within - limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP) 和 @target 一样</p>
<p>@annotation - 限定匹配方法上有 annotation 的连接点，常用于绑定形式。advice中可以获取 annotation 对象。</p>
<p>bean - 仅在Spring AOP中支持</p>
<p><strong>由于Spring的AOP框架的基于代理的性质，目标对象内的调用根本没有被拦截</strong>。对于JDK代理，只有代理上的公共接口方法调用才能被拦截。使用CGLIB，代理上的public和protected方法调用将被拦截，如果需要的话，甚至包package-visible方法。但是，通过代理的常见交互应始终通过 public 签名进行设计。</p>
<p>请注意，pointcut 定义通常与所有截取的方法匹配。如果一个切入点严格意义上的 public-only，即使在可能存在 non-public 交互 CGLIB代理场景中，需要相应地定义。</p>
<p><strong>如果拦截需求包含方法调用，甚至包含目标类中的构造函数，请考虑使用Spring驱动的本机AspectJ编织，而不是Spring的基于代理的AOP框架</strong>。这构成了不同特征的AOP使用方式，所以在做出决定之前一定要先熟悉编织。</p>
<p>切入点表达式可以使用’&amp;&amp;’，’||’ 和’!’组合。用更小的命名组件构建更复杂的切入点表达式是一种最佳做法。 </p>
<p>当按名称引用切入点时，将应用普通的Java可见性规则（您可以看到相同类型的私有切入点，层次结构中受保护的切入点，任何位置的公共切入点等）。 可见性不影响切入点匹配。</p>
<p>在使用企业应用程序时，您经常要从几个方面参考应用程序的模块和特定的一组操作。 我们建议定义一个“SystemArchitecture”方面来捕获常见的切入点表达式。</p>
<p>pointcuts优化，AspectJ在编译阶段会优化匹配。匹配分为静态匹配和动态匹配。动态匹配只有在代码运行阶段才能判定是否匹配。并以DNF形式进行组织排序，将开销小的评估放在前面。这意味着你无需关心pointcut的排序问题。</p>
<p>pointcuts分三类：</p>
<ul>
<li>kinded    选择一种特定类型的连接点。例如：execution, get, set, call, handler</li>
<li>scoping   选择一组感兴趣的连接点（可能有多种）。例如：within, withincode</li>
<li>context   匹配（和可选地绑定）基于上下文。 例如：this, target, @annotation<br>一个写得好的切入点应至少包括前两种类型（kinded和scoping），如果希望基于连接点context进行匹配，则可以同事包含上下文标识符，或者将该上下文绑定以用于建议。 只提供一个指定的指示符或仅指定一个上下文指示符将会起作用，但是会由于所有额外的处理和分析而影响编织性能（使用时间和内存）。 范围标识符的匹配速度非常快，而且它们的使用方式意味着AspectJ可以很快地解除不应该进一步处理的连接点组 - 这就是为什么一个好的切入点应该总是包含一个可能的情况。</li>
</ul>
<h1 id="5-2-4-Declaring-advice"><a href="#5-2-4-Declaring-advice" class="headerlink" title="5.2.4 Declaring advice"></a>5.2.4 Declaring advice</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Before</span>(<span class="string">"execution(* com.xyz.myapp.dao.*.*(..))"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AfterReturning</span>(</div><div class="line">        pointcut=<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>,</div><div class="line">        returning=<span class="string">"retVal"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAccessCheck</span><span class="params">(Object retVal)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>returning与advice方法中的参数类型，一起参与匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AfterThrowing</span>(</div><div class="line">        pointcut=<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>,</div><div class="line">        throwing=<span class="string">"ex"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span><span class="params">(DataAccessException ex)</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>throwing与advice方法中的参数类型，一起参与匹配。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@After</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation()"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doReleaseLock</span><span class="params">()</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Around</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService()"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">doBasicProfiling</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">// start stopwatch</span></div><div class="line">        Object retVal = pjp.proceed();</div><div class="line">        <span class="comment">// stop stopwatch</span></div><div class="line">        <span class="keyword">return</span> retVal;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一个参数必须是ProceedingJoinPoint类型。<br>Spring AOP 于 AspectJ 的proceed参数绑定不一样。</p>
<p>任何Advice方法的第一个参数都可以是JoinPoint类型（@Around是子类型ProceedingJoinPoint）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessO peration() &amp;&amp; args(account,..)"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Pointcut</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.dataAccessOperation() &amp;&amp; args(account,..)"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">accountDataAccessOperation</span><span class="params">(Account account)</span> </span>&#123;&#125;</div><div class="line"></div><div class="line"><span class="meta">@Before</span>(<span class="string">"accountDataAccessOperation(account)"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">validateAccount</span><span class="params">(Account account)</span> </span>&#123;</div><div class="line">        <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用args可以绑定参数与参数类型<br>The proxy object ( this), target object ( target), and annotations ( @within, @target, @annotation, @args)  可以用同样的方式绑定</p>
<p>可使用 args 限定泛型 T 类型。但不支持泛型集合Collection<t>。你必须指定Advice中的参数为Collection&lt;?&gt;类型。然后在方法中自己判断。</t></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Before</span>(value=<span class="string">"com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)"</span>,</div><div class="line">                argNames=<span class="string">"bean,auditable"</span>)</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">audit</span><span class="params">(JoinPoint jp, Object bean, Auditable auditable)</span> </span>&#123;</div><div class="line">        AuditCode code = auditable.value();</div><div class="line">        <span class="comment">// ... use code, bean, and jp</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>参数名称绑定。如果有多个参数需要使用argNames来指定参数名称。旧版的java反射无法获取方法中的参数名称。<br>如果第一个参数类型是JoinPoint, ProceedingJoinPoint, JoinPoint.StaticPart。需要跳过第一个参数名称。<br>在jdk1.7及之前编译阶段使用 -g:vars 参数，可以不写argNames属性，可以从.class的变量表中读取参数名。在jdk1.8中编译中加 -parameters 参数。会增加额外的元信息。</p>
<pre><code>1. 代码反向工程容易理解
2. class文件会略微变大
3. 删除不使用的本地变量的优化不会执行。
</code></pre><p>如果AspectJ编译器（ajc）编译了@AspectJ方面，即使没有调试信息，也不需要添加argNames属性，因为编译器会保留所需的信息。<br>如果代码已经被编译而没有必要的调试信息，那么Spring AOP会尝试推断绑定变量与参数的配对（例如，如果在切入点表达式中只绑定了一个变量，而通知方法只有一个参数， 配对是显而易见的！）。 如果给定可用的信息，变量的绑定是不明确的，那么就会抛出一个AmbiguousBindingException异常。<br>如果上述所有的策略都失败了，那么IllegalArgumentException将被抛出。</p>
<p>优先级越高，before越先执行，after越后执行。<br>org.springframework.core.Ordered  @Order 可以指定优先级，value越小优先级越高。</p>
<h1 id="5-2-5-Introductions"><a href="#5-2-5-Introductions" class="headerlink" title="5.2.5 Introductions"></a>5.2.5 Introductions</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Aspect</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageTracking</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@DeclareParents</span>(value=<span class="string">"com.xzy.myapp.service.*+"</span>, defaultImpl=DefaultUsageTracked.class)</div><div class="line">        <span class="keyword">public</span> <span class="keyword">static</span> UsageTracked mixin;</div><div class="line"></div><div class="line">        <span class="meta">@Before</span>(<span class="string">"com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)"</span>)</div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">recordUsage</span><span class="params">(UsageTracked usageTracked)</span> </span>&#123;</div><div class="line">                usageTracked.incrementUseCount();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h1 id="5-2-6-Aspect-instantiation-models"><a href="#5-2-6-Aspect-instantiation-models" class="headerlink" title="5.2.6 Aspect instantiation models"></a>5.2.6 Aspect instantiation models</h1><p>perthis - 每一个 join point 创建一个 aspect<br>pertarget - 每一个 target 创建一个 aspect<br>percflow, percflowbelow, and pertypewithin 目前不支持。</p>
<h1 id="5-4-1-Spring-AOP-or-full-AspectJ"><a href="#5-4-1-Spring-AOP-or-full-AspectJ" class="headerlink" title="5.4.1 Spring AOP or full AspectJ"></a>5.4.1 Spring AOP or full AspectJ</h1><p><strong>满足需求的情况下使用最简单的工具。</strong><br>如果，要 advice 非Spring容器管理的bean、属性的getset等非简单方法执行等，需要使用AspectJ。</p>
<p>使用 AspectJ Development Tools 倾向使用 AspectJ language syntax 定义pointcut。否则使用 @AspectJ 并定期使用Java编译，并在构建时加入weaving<br>阶段。</p>
<h1 id="5-4-2-AspectJ-or-XML-for-Spring-AOP"><a href="#5-4-2-AspectJ-or-XML-for-Spring-AOP" class="headerlink" title="5.4.2 @AspectJ or XML for Spring AOP?"></a>5.4.2 @AspectJ or XML for Spring AOP?</h1><p>XML配置更集中。容易管理。但不符合DRY原则（对系统内的任何知识都应该有一个单一的，明确的，权威的表示。），xml将pointcut声明与advice实现分离。xml不能组合两个 pointcut 组合新的pointcut。</p>
<p>@AspectJ 支持 Aspect instantiation models 和 pointcut 组合。容易移植到 AspectJ 实现上。总的来说，Spring团队只要具有不仅仅是简单的“配置”企业服务的方面，就更喜欢@AspectJ风格。</p>
<h1 id="5-6-Proxying-机制"><a href="#5-6-Proxying-机制" class="headerlink" title="5.6 Proxying 机制"></a>5.6 Proxying 机制</h1><p>Spring AOP使用JDK动态代理或CGLIB为给定的目标对象创建代理。 （无论何时选择，JDK动态代理都是首选）。</p>
<p>默认，有接口或多个接口使用 JDK 代理所有接口。如果没有接口，用CGLIB代理。<br>强制使用 CGLIB 代理：</p>
<ul>
<li>final 方法不能被重写，不能被 advise</li>
<li>3.2 之后包含了CGLIB jar包在 spring-core 中</li>
<li>4.0 之后可以绕过构造方法传参的JVM 只构造一次。否则构造两次。</li>
</ul>
<p>proxy-target-class=”true” 在 <tx:annotation-driven>, <aop:aspectj-autoproxy> or <aop:config> 中只要有，全都生效。</aop:config></aop:aspectj-autoproxy></tx:annotation-driven></p>
<h1 id="5-6-1-理解-AOP-代理"><a href="#5-6-1-理解-AOP-代理" class="headerlink" title="5.6.1 理解 AOP 代理"></a>5.6.1 理解 AOP 代理</h1><p>对 Spring 代理的方法调用。通过advice组成的拦截器之后，调用到target对象方法本身。target方法内的调用都是针对this(target对象)的调用。而不是proxy对象的调用。<br>AopContext.currentProxy() 可以获取代理对象。<br>AspectJ 不存在这种自我调用问题，因为AspectJ不是基于代理的AOP。</p>
<h1 id="5-7-程序创建-AspectJ-Proxies"><a href="#5-7-程序创建-AspectJ-Proxies" class="headerlink" title="5.7. 程序创建 @AspectJ Proxies"></a>5.7. 程序创建 @AspectJ Proxies</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// create a factory that can generate a proxy for the given target object</span></div><div class="line">AspectJProxyFactory factory = <span class="keyword">new</span> AspectJProxyFactory(targetObject);</div><div class="line"></div><div class="line"><span class="comment">// add an aspect, the class must be an @AspectJ aspect</span></div><div class="line"><span class="comment">// you can call this as many times as you need with different aspects</span></div><div class="line">factory.addAspect(SecurityManager.class);</div><div class="line"></div><div class="line"><span class="comment">// you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect</span></div><div class="line">factory.addAspect(usageTracker);</div><div class="line"></div><div class="line"><span class="comment">// now get the proxy object...</span></div><div class="line">MyInterfaceType proxy = factory.getProxy();</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;5-1-介绍&quot;&gt;&lt;a href=&quot;#5-1-介绍&quot; class=&quot;headerlink&quot; title=&quot;5.1.介绍&quot;&gt;&lt;/a&gt;5.1.介绍&lt;/h1&gt;&lt;p&gt;面向切面编程（AOP）通过提供另一种思考程序结构的方式来补充面向对象编程（OOP）。 OOP中模块化的关键单
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>JSR107-缓存标准解读</title>
    <link href="http://leerenbo.cn/2017/10/23/JSR107/"/>
    <id>http://leerenbo.cn/2017/10/23/JSR107/</id>
    <published>2017-10-23T02:58:38.000Z</published>
    <updated>2017-10-26T10:03:01.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h1><p>jsr107是本地缓存标准的API，用于创建、访问、更新、删除缓存中的数据。<br>缓存能显著的提升，从多数据源，网络服务，高计算的性能。<br>部分功能与分布式缓存不相适应。</p>
<h2 id="1-1-JSR107目标"><a href="#1-1-JSR107目标" class="headerlink" title="1.1 JSR107目标"></a>1.1 JSR107目标</h2><ul>
<li>为应用程序提供缓存功能，特别是缓存Java对象的能力</li>
<li>定义一套通用的缓存概念和设施;</li>
<li>最大限度地减少Java开发人员需要学习采用缓存的概念数量</li>
<li>最大化在缓存实现之间使用缓存的应用程序的可移植性</li>
<li>支持进程内和分布式缓存实现</li>
<li>支持通过值缓存和引用缓存Java对象</li>
<li>根据JSR-175：Java编程语言的元数据设施定义运行时高速缓存注释; 以便使用可选提供的注释处理器的Java开发人员可以声明性地指定应用程序缓存要求;</li>
</ul>
<h2 id="1-2-非JSR107目标"><a href="#1-2-非JSR107目标" class="headerlink" title="1.2 非JSR107目标"></a>1.2 非JSR107目标</h2><ul>
<li>资源和内存约束配置 - 虽然许多高速缓存实现提供了对缓存可以在运行时使用的资源量的限制的支持，但本规范并未定义如何配置或表示此功能。 然而，这个规范确定了一个标准的机制，用于开发人员指定可以使用多长时间缓存的信息。</li>
<li>缓存存储和拓扑 - 此规范不指定缓存实现如何存储或表示缓存的信息。</li>
<li>管理 - 本规范不指定缓存的管理方式。 它确定了通过Java管理扩展（JMX）以编程方式配置缓存并调查高速缓存统计信息的机制。</li>
<li>安全性 - 本规范不规定缓存内容如何得到保护，以及如何控制缓存中的访问和操作。</li>
<li>外部资源同步 - 本规范不规定应用程序或缓存实现如何使缓存和外部资源内容保持同步。</li>
</ul>
<h1 id="2-基础"><a href="#2-基础" class="headerlink" title="2.基础"></a>2.基础</h1><h2 id="2-1核心概念"><a href="#2-1核心概念" class="headerlink" title="2.1核心概念"></a>2.1核心概念</h2><ul>
<li>CachingProvider - 定义了建立，配置，获取，管理和控制零个或多个 CacheManager(s) 的机制。 应用程序可以在运行时访问和使用零个或多个CachingProvider。</li>
<li>CacheManager - 定义了在CacheManager的上下文中建立，配置，获取，管理和控制零个或多个唯一命名的 Cache(s) 的机制。 CacheManager由单个CachingProvider拥有。</li>
<li>Cache - 缓存是一个类似 Map 的数据结构，允许临时存储基于键的值，一些像java.util.Map数据结构一样。 缓存由单个CacheManager拥有。</li>
<li>Entry - 是由Cache存储的单个键值对。</li>
<li>ExpiryPolicy - 由缓存存储的每个条目具有定义的持续时间，称为到期时间，在此期间，可以访问，更新和删除它们。 一旦这个持续时间过去，该条目据说已过期。 一旦过期，条目将不再可用于访问，更新或删除，就像它们从不存在于缓存中一样。 Expiry使用ExpiryPolicy设置。</li>
</ul>
<h2 id="2-2-Cache-和-Map"><a href="#2-2-Cache-和-Map" class="headerlink" title="2.2 Cache 和 Map"></a>2.2 Cache 和 Map</h2><p>虽然缓存和 Map 共享一些类似的API，但缓存不是 Map 。Map 不是高速缓存。 以下部分概述了主要的相似之处和差异。</p>
<h3 id="相似"><a href="#相似" class="headerlink" title="相似"></a>相似</h3><ul>
<li>通过关联的 key 存储和访问值。</li>
<li>每个 key 只能与缓存中的单个值相关联</li>
<li>如果使用可变对象作为关键字，则必须非常小心。 当 Cache 使用 key 时, 并在操作时修改了 key 的 equal 对比，则Cache的行为是未定义的。</li>
<li>缓存依赖相等的概念来决定，keys和values是否相同。所以key和value类应该定义合适的 Object.hashCode 的实现</li>
</ul>
<h3 id="不同"><a href="#不同" class="headerlink" title="不同"></a>不同</h3><ul>
<li>缓存键和值不能为空。对于键或值使用null的任何尝试将导致抛出NullPointerException，而不管使用何种。</li>
<li>条目可过期。</li>
<li><p>条目可驱逐。资源有限，缓存的是数据子集，超出资源大小删除条目称驱逐。驱逐策略 LRU等。</p>
  <figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">规范中没有定义容量的一些原因是：</div><div class="line">-<span class="ruby"> 实现可以利用多层分层存储结构，并因此定义每层的容量。 在这种情况下，无法定义缓存的总体容量，这样做是不明确的。</span></div><div class="line">-<span class="ruby"> 实现可以以字节而不是每个层上的条目计数来定义容量。</span></div><div class="line">-<span class="ruby"> 使用的内存条目的相对成本与运行时的条目的实现的内部表示直接相关。</span></div></pre></td></tr></table></figure>
</li>
<li><p>为了支持 compare-and-swap（CAS）操作，那些原子比较和交换值的定制值类应该提供一个适当的Object.equals实现。</p>
</li>
<li>实现可能需要按键和值以某种方式可序列化。</li>
<li>可以配置缓存，控制条目的存储方式，使用值缓存或可选地使用引用缓存。</li>
<li>实现可以可选地执行安全限制。 如果发生违规，则必须抛出SecurityException异常。</li>
</ul>
<h2 id="2-3-一致性"><a href="#2-3-一致性" class="headerlink" title="2.3 一致性"></a>2.3 一致性</h2><p>一致性是指当多个线程访问高速缓存时，高速缓存的行为和并发缓存突变发生时存在的保证以及突变的可见性。<br>所有实现必须支持如下所述的默认一致性模型。</p>
<h3 id="2-3-1-默认一致性"><a href="#2-3-1-默认一致性" class="headerlink" title="2.3.1 默认一致性"></a>2.3.1 默认一致性</h3><p>当使用默认一致性模式时，大多数缓存操作的执行方式就像 Cache 中每个 Key 存在锁定机制一样。当缓存操作获取对 key 的排他读写锁时，该 key 的所有后续操作将被阻塞，直到该锁被释放。结果是由线程执行的操作发生在由另一个线程执行的读取或变更操作之前，包括不同Java虚拟机中的线程。<br>这可以被理解为一种悲观的锁定方法。锁定，变更和解锁。</p>
<p>对于某些缓存操作，缓存返回的值被认为是最后一个值。最后一个值可能是旧值或新值，特别是在同时更新条目的情况下。它是依赖于实现的返回。<br>这可以被理解为没有保证一致性的无锁方法。</p>
<p>其他操作遵循不同的约定，因为突变可能仅在条目的当前状态与期望状态匹配时才发生。在这样的操作中，多个线程可以自由竞争来应用这些改变，就像它们共享一个锁一样。这些是：</p>
<ul>
<li>boolean putIfAbsent(K key, V value);</li>
<li>boolean remove(K key, V oldValue);</li>
<li>boolean replace(K key, V oldValue, V newValue); </li>
<li>boolean replace(K key, V value);</li>
<li>V getAndReplace(K key, V value);</li>
</ul>
<p>这可以被理解为乐观的锁定方法; 只有当状态匹配已知状态时，才应用更改，否则失败。 这些类型的操作也称为比较和交换（CAS）操作，在CPU指令也以此方式操作。<br>由于这些方法必须与其他缓存操作相互作用，表现就像它们具有排他锁一样.不装作拥有排它锁，CAS方法不能写入新的值。<br>因此，在默认的一致性的情况下，CAS方法可以允许更高级别的并发性，但它们将被非CAS方法所阻止。</p>
<p>下表显示了适用于每个Cache方法的默认一致性：</p>
<table>
<thead>
<tr>
<th>Method</th>
<th>Default Consistency</th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean containsKey(K key)</td>
<td>last value</td>
</tr>
<tr>
<td>V get(K key)</td>
<td>happen-before</td>
</tr>
<tr>
<td>Map<k,v> getAll(Collection&lt;? extends K&gt; keys)</k,v></td>
<td>happen-before for each key individually but not for the Collection.</td>
</tr>
<tr>
<td>V getAndPut(K key, V value)</td>
<td>happen-before</td>
</tr>
<tr>
<td>V getAndRemove(K key)</td>
<td>happen-before</td>
</tr>
<tr>
<td>V getAndReplace(K key, V value)</td>
<td>happen-before plus compare and swap</td>
</tr>
<tr>
<td>CacheManager getCacheManager()</td>
<td>N/A</td>
</tr>
<tr>
<td>CacheConfiguration getConfiguration()</td>
<td>N/A</td>
</tr>
<tr>
<td>String getName()</td>
<td>N/A</td>
</tr>
<tr>
<td>Iterator<cache.entry<k, v="">&gt; iterator()</cache.entry<k,></td>
<td>last value</td>
</tr>
<tr>
<td>void loadAll(Set&lt;? extends K&gt; keys, boolean replaceExistingValues, CompletionListener listener)</td>
<td>N/A</td>
</tr>
<tr>
<td>void put(K key, V value)</td>
<td>happen-before</td>
</tr>
<tr>
<td>void putAll(Map&lt;? extends K,? extends V&gt; map)</td>
<td>happen-before for each key individually but not for the Collection.</td>
</tr>
<tr>
<td>boolean putIfAbsent(K key, V value)</td>
<td>happen-before plus compare and swap</td>
</tr>
<tr>
<td>boolean remove(K key)</td>
<td>happen-before</td>
</tr>
<tr>
<td>boolean remove(K key, V oldValue)</td>
<td>happen-before plus compare and swap</td>
</tr>
<tr>
<td>void removeAll()</td>
<td>last value</td>
</tr>
<tr>
<td>void removeAll(Set&lt;? extends K&gt; keys)</td>
<td>happen-before for each key individually but not for the Collection.</td>
</tr>
<tr>
<td><t> T invoke(K key, EntryProcessor<k, v,="" t=""> entryProcessor, Object… arguments)entryProcessor)</k,></t></td>
<td>happen-before</td>
</tr>
<tr>
<td><t> Map<k, entryprocessorresult<t="">&gt; invokeAll(Set&lt;? extends K&gt; keys, EntryProcessor<k, v,="" t=""> entryProcessor, Object… arguments)</k,></k,></t></td>
<td>happen-before for each key individually but not for the Collection.</td>
</tr>
<tr>
<td>boolean replace(K key, V value)</td>
<td>happen-before plus compare and swap</td>
</tr>
<tr>
<td>boolean replace(K key, V oldValue, V newValue)</td>
<td>happen-before plus compare and swap</td>
</tr>
<tr>
<td><t> T unwrap(Class<t> cls)</t></t></td>
<td>N/A</td>
</tr>
</tbody>
</table>
<h2 id="2-4-缓存拓扑"><a href="#2-4-缓存拓扑" class="headerlink" title="2.4 缓存拓扑"></a>2.4 缓存拓扑</h2><p>虽然该规范并不要求特定的缓存拓扑，但是认识到Cache条目可以很好地被本地存储和/或分布在多个进程中。 实现可能选择不支持，一种，两种和/或其他拓扑。</p>
<p>这个概念在规范中用多种方式表达：</p>
<ul>
<li>大多数变更提供了 void 或低开销的返回类型声明。例如，Map 提供 V put(K key, V value)，Cache 提供 void put(K key, V value)。更多开销的返回类型同样提供，例如：Cache 的 V getAndPut(K key, V value) 。像Map一样，返回旧值。</li>
<li>通过具有不承担进程内实现的创建语义，Configuration 是 Serializable 的，以便可以通过网络发送。 开发人员可以定义CacheEntryListener，ExpiryPolicy，CacheEntryFilter，CacheWriter和CacheLoader的实现，并将它们与缓存相关联。 为了支持分布式拓扑，开发人员定义了一个 Factory 来创建 Cache 而不是实例。 Factory 接口是 Serializable 。</li>
<li>整个规范中使用 Iterable 返回类型和参数可能很多。返回整个集合（如Map方法keySet（））的方法可能是有问题的。缓存可能非常大，使得 keySet 可能不适合可用的存储器，并且它也可能非常网络效率低下。缓存，CacheEntryListener的子接口上的侦听器方法，以及CacheLoader上的批处理方法都使用Iterable。</li>
<li>没有假设实例化和执行CacheEntryListener，ExpiryPolicy，CacheEntryFilter，CacheWriter和CacheLoader的实现。在分布式实现中，这些都可以靠近数据而不是应用程序。</li>
<li>CachingProvider.getCacheManager（URI uri，ClassLoader classLoader）返回具有特定ClassLoader和URI的CacheManager。 这使实现实例化多个实例。</li>
</ul>
<h2 id="2-5-执行上下文"><a href="#2-5-执行上下文" class="headerlink" title="2.5 执行上下文"></a>2.5 执行上下文</h2><p>EntryProcessor s，CacheEntryListener s，CacheLoader s，CacheWriter s和ExpiryPolicy s（“customizations”）被实例化并在配置了它们的 CacheManager URI 和 ClassLoader 的上下文中进行操作。 这意味着在部署时，这些自定义的实例必须可用并可以被缓存的ClassLoader访问定义的应用程序类。<br>实现可以安全地假定，这种配置通过使用CacheManager提供的ClassLoader可被Cache获得。<br>类的获得能力和实现与部署有关。</p>
<h2 id="2-6-重入"><a href="#2-6-重入" class="headerlink" title="2.6 重入"></a>2.6 重入</h2><p>虽然本规范不限制开发人员在使用自定义EntryProcessors，CacheEntryListeners，CacheLoaders，CacheWriters和ExpiryPolicys时可能执行的操作，但缓存实现可能会限制这些接口的重入。 例如; 一个实现可能会限制EntryProcessor在Cache上调用方法或调用其他EntryProcessors的能力。 类似地，实现可以限制CacheLoader / CacheWriter访问Cache的能力。<br>因此，强烈建议开发人员避免编写这些接口的重新实现，因为这些实现可能不可移植。</p>
<h1 id="4-CacheManagers"><a href="#4-CacheManagers" class="headerlink" title="4.CacheManagers"></a>4.CacheManagers</h1><p>CacheManagers是Java Caching API的核心概念。 开发人员通过CacheManagers与缓存进行交互。<br>CacheManager 提供:</p>
<ul>
<li>建立和配置唯一命名的缓存的方法。</li>
<li>获取配置了唯一命名缓存的方法。</li>
<li>一种划分唯一命名的缓存范围的方法; 来自不同缓存管理器的同名缓存被认为是不同的高速缓存。</li>
<li>关闭缓存的方法，使其不再被管理。</li>
<li>销毁包含其所有内容的缓存的方法。</li>
<li>如果缓存需要它，则缓存的ClassLoader将用于解析和加载应用程序类。</li>
<li>迭代当前管理的缓存的方法。</li>
<li>将CacheManager与所有当前管理的高速缓存一起关闭的方法。</li>
<li>启用和禁用高速缓存统计信息收集的方法。</li>
<li>启用和禁用缓存的JMX管理的方法。</li>
<li>为CacheManager定义的获取CachingProvider特定属性的方法。</li>
<li>查询CachingProvider支持的功能和可选功能的方法。</li>
</ul>
<h3 id="4-1-1-获取默认-CacheManager"><a href="#4-1-1-获取默认-CacheManager" class="headerlink" title="4.1.1 获取默认 CacheManager"></a>4.1.1 获取默认 CacheManager</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//acquire the default CachingProvider</span></div><div class="line">CachingProvider provider = Caching.getCachingProvider();</div><div class="line"><span class="comment">//acquire the default CacheManager</span></div><div class="line">CacheManager manager = provider.getCacheManager();</div></pre></td></tr></table></figure>
<h3 id="4-1-2-配置-Caches"><a href="#4-1-2-配置-Caches" class="headerlink" title="4.1.2 配置 Caches"></a>4.1.2 配置 Caches</h3><ul>
<li><k, v,="" c="" extends="" configuration<k,="" v="">&gt; Cache<k, v=""> createCache(String cacheName, C configuration)</k,></k,></li>
<li>CacheManagers可以选择提供声明性地为应用程序配置缓存的机制，从而避免应用程序使用createCache方法。</li>
</ul>
<p>缓存配置相关的接口和类，在 javax.cache.configuration 包内定义。提供最小配置接口 Configuration 和全部配置 CompleteConfiguration 接口.<br>为了简化配置缓存，提供了实现javax.cache.configuration.CompleteConfiguration接口的javax.cache.configuration.MutableConfiguration。<br>CacheManagers 有责任验证程序提供的 Cache 配置。创建非法的Cache抛出 IllegalArgumentException。</p>
<h3 id="4-1-3-Cache-名称与范围"><a href="#4-1-3-Cache-名称与范围" class="headerlink" title="4.1.3 Cache 名称与范围"></a>4.1.3 Cache 名称与范围</h3><p>缓存由创建或初始访问它们的CacheManager范围内的唯一配置名称来标识。<br>虽然缓存名称表示为Java字符串，但是有一些限制和推荐的可移植性命名约定。 这些如下：</p>
<ul>
<li>java. 或 javax. 开头的缓存名称不能用，这些名称空间可能用于内部平台 Caches。</li>
<li>缓存名称不应包含正斜杠（/）或冒号（:)，因为它们可能在Java EE环境中用于基于JNDI的查找。</li>
<li>缓存名称可能使用Unicode字符。</li>
</ul>
<p>虽然不是一个要求，但应用程序可能会选择使用Cache类型的完全限定类名作为缓存名称。例如：存储 Orders 的缓存可能被称为“com.mycompany.Orders”。</p>
<h3 id="4-1-4-获取-Cache"><a href="#4-1-4-获取-Cache" class="headerlink" title="4.1.4 获取 Cache"></a>4.1.4 获取 Cache</h3><p>使用CacheManagers获取缓存有两种方法：</p>
<ul>
<li>当需要类型安全的Cache时，这是一个尝试确保使用正确和预期类型的缓存条目的缓存，应用程序应该使用以下CacheManager方法：<br>  <k, v=""> Cache<k, v=""> getCache(String cacheName, Class<k> keyType,Class<v> valueType)</v></k></k,></k,></li>
<li>当应用程序通过使用 rawtypes 明确地承担缓存条目类型的安全性时，应使用以下CacheManager方法：<br>  <k, v=""> Cache<k, v=""> Cache getCache(String cacheName);</k,></k,></li>
</ul>
<p>从CacheManager获取缓存的简单示例：Cache<string, integer=""> cache = cacheManager.getCache( “simpleCache”, String.class, Integer.class);</string,></p>
<h3 id="4-1-5-Cache-与-CacheManager-的生命周期"><a href="#4-1-5-Cache-与-CacheManager-的生命周期" class="headerlink" title="4.1.5 Cache 与 CacheManager 的生命周期"></a>4.1.5 Cache 与 CacheManager 的生命周期</h3><p>所有Cache和CacheManager实例都以两种可能的状态之一运行; 打开或关闭。打开时，实例可能会被操作地用于请求。 例如; 创建，更新，删除条目或配置，获取，关闭，删除缓存等。 关闭时，这些实例的任何操作使用都将抛出IllegalStateException异常。</p>
<h3 id="4-1-6-关闭-Cache"><a href="#4-1-6-关闭-Cache" class="headerlink" title="4.1.6 关闭 Cache"></a>4.1.6 关闭 Cache</h3><p>通过调用 Cache.close() 方法给持有的 CacheManager 发送信号来关闭 Cache，Cache 不应该再被管理。与此同时 CacheManager：</p>
<ul>
<li>必须关闭并释放由CacheManager代表Cache进行协调的所有资源。这包括在配置的CacheLoader，CacheWriter，注册的CacheEntryListeners和ExpiryPolicy实例上调用实现java.io.Closeable接口的close方法。</li>
<li>阻止将事件传递到Cache上注册的已配置CacheEntryListeners</li>
<li>当CacheManager getCacheNames（）方法被调用时，不返回缓存的名称。</li>
</ul>
<p>一旦关闭，任何尝试使用缓存上的操作方法将抛出一个 IllegalStateException 异常。 缓存的操作方法是：</p>
<ul>
<li>clear</li>
<li>containsKey</li>
<li>deregisterCacheEntryListener </li>
<li>get</li>
<li>getAll</li>
<li>getAndPut</li>
<li>getAndRemove</li>
<li>getAndReplace</li>
<li>invoke</li>
<li>invokeAll</li>
<li>iterator</li>
<li>loadAll</li>
<li>put</li>
<li>putAll</li>
<li>putIfAbsent</li>
<li>registerCacheEntryListener </li>
<li>remove</li>
<li>removeAll </li>
<li>replace</li>
</ul>
<p>关闭缓存不一定会破坏缓存的内容。 它只是向拥有的CacheManager发出信号，表明应用程序不再需要缓存，并且不应该允许将来使用特定的缓存实例。 根据实现和缓存拓扑（例如，存储支持或分布式缓存），关闭的缓存的内容可能仍然可用并可由其他应用程序访问，或实际上通过先前拥有缓存的缓存管理器如果应用程序在未来的某个时刻调用getCache。</p>
<h3 id="4-1-7-销毁-Cache"><a href="#4-1-7-销毁-Cache" class="headerlink" title="4.1.7 销毁 Cache"></a>4.1.7 销毁 Cache</h3><p>要销毁缓存，将其从被管理中释放出来，并删除所有缓存条目，从而允许创建具有相同名称但可能还有不同配置的新缓存，则应调用CacheManager destroyCache方法。<br>一旦销毁：</p>
<ul>
<li>任何尝试在缓存实例上使用操作方法都会抛出IllegalStateException异常。</li>
<li>通过调用CacheManager.create方法，使用相同或不同的配置，可以在新缓存中重新使用已破坏的缓存的名称。</li>
</ul>
<p>一旦破坏，Cache不再可通过CacheManager使用。 无论实现或拓扑如何，销毁缓存都可以确保其关闭，并且任何应用程序（无论是在即将还是将来）都不再可用所有关联的条目。</p>
<h3 id="4-1-8-关闭-CacheManagers"><a href="#4-1-8-关闭-CacheManagers" class="headerlink" title="4.1.8 关闭 CacheManagers"></a>4.1.8 关闭 CacheManagers</h3><p>通过调用CacheManager.close（）方法或通过CachingProvider.close（…）方法关闭CacheManager具有指示CacheManager：</p>
<ul>
<li>关闭目前管理的所有缓存</li>
<li><p>释放当前用于管理缓存的所有资源。* 一旦关闭，任何尝试在封闭的CacheManager或其管理的任何缓存中使用操作方法将抛出IllegalStateException。 CacheManager上的操作方法是：</p>
<ul>
<li>createCache</li>
<li>destroyCache</li>
<li>enableManagement</li>
<li>enableStatistics</li>
<li>getCache</li>
<li>getCacheNames</li>
</ul>
</li>
</ul>
<p>关闭CacheManager后，可能使用最初生成CacheManager的CachingProvider获取另一个可能代表先前管理的缓存的实例。 这在CachingProviders部分中有所介绍。</p>
<h3 id="4-1-9-ClassLoading"><a href="#4-1-9-ClassLoading" class="headerlink" title="4.1.9 ClassLoading"></a>4.1.9 ClassLoading</h3><p>所有缓存共享与CacheManager配置的同一个ClassLoader，当CacheManager被创建时，它们被从CacheManager中获取。<br>要配置和获取使用不同ClassLoaders的缓存，必须建立单独的缓存管理器来执行此操作。 有关如何配置CacheManagers的信息，请参阅CachingProviders部分。</p>
<h1 id="5-Caches"><a href="#5-Caches" class="headerlink" title="5.Caches"></a>5.Caches</h1><p>开发人员用于与Cache进行交互的主要是 javax.cache.Cache 接口。<br>javax.cache.Cache接口提供类似Map的方法来启用访问，更新和删除对Cache Entries 的访问。</p>
<h2 id="5-1-Cache-类型安全"><a href="#5-1-Cache-类型安全" class="headerlink" title="5.1 Cache 类型安全"></a>5.1 Cache 类型安全</h2><p>Java Caching API广泛使用JSR-14定义的Java泛型，以便在采用缓存时启用编译时类型安全应用程序的开发。<br>在可用的情况下，编译时类型安全性不能保证采用缓存的应用程序的运行时类型正确性。 对于某些缓存拓扑，特别是那些通过Java进程边界存储或传送条目的缓存拓扑，Java运行时类型信息擦除以及无法获取和传输通用类型信息可能意味着应用程序类型无法确保Cache操作的类型安全性环境。 应始终注意确保使用适当的键和值类型配置缓存，以便实现可以根据需要执行类型检查。</p>
<h2 id="5-2-编译时类型安全"><a href="#5-2-编译时类型安全" class="headerlink" title="5.2 编译时类型安全"></a>5.2 编译时类型安全</h2><p>通过使用所需的通用类型声明缓存来提供编译时类型安全性。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Configuration config = <span class="keyword">new</span> MutableConfiguration();</div><div class="line"><span class="comment">//create the cache cacheManager.createCache(cacheName, config);</span></div><div class="line"><span class="comment">//... then later to get the cache</span></div><div class="line">Cache&lt;String, Integer&gt; cache = cacheManager.getCache(cacheName);</div><div class="line"><span class="comment">//use the cache</span></div><div class="line">String key = <span class="string">"key"</span>;</div><div class="line">Integer value1 = <span class="number">1</span>; cache.put(<span class="string">"key"</span>, value1); Integer value2 = cache.get(key);</div><div class="line"><span class="comment">//the following will not compile - incorrect types specified //cache.put(2, “some value);</span></div></pre></td></tr></table></figure></p>
<p>虽然可以通过使用原始类型（不指定通用类型参数）声明缓存来规避编译时类型安全检查，但这不是推荐的做法，因为它允许发生简单的编程错误。<br>在以下示例中，缓存被声明为原始类型。 在这种情况下，不能执行编译时类型检查（尽管可能会生成类型警告）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Configuration config = <span class="keyword">new</span> MutableConfiguration(); cacheManager.createCache(cacheName, config);</div><div class="line"><span class="comment">//... then later to get the cache without type information Cache cache = cacheManager.getCache(cacheName);</span></div><div class="line">String key = <span class="string">"key"</span>;</div><div class="line">Integer value1 = <span class="number">1</span>;</div><div class="line">cache.put(<span class="string">"key"</span>, value1);</div><div class="line">cache.put(value1, <span class="string">"key1"</span>); <span class="comment">//not intended but will still compile and execute! Integer value2 = (Integer) cache.get(key);</span></div><div class="line">assertEquals(value1, value2);</div></pre></td></tr></table></figure></p>
<h2 id="5-3-运行时类型安全"><a href="#5-3-运行时类型安全" class="headerlink" title="5.3 运行时类型安全"></a>5.3 运行时类型安全</h2><p>除了编译型安全性之外，开发人员还可以通过使用特定键和值类型配置缓存来实现运行时类型安全。 例如，MutableConfiguration类提供了以下方法来定义缓存所需的密钥和值类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> MutableConfiguration&lt;K, V&gt; <span class="title">setTypes</span><span class="params">(Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</span></span></div></pre></td></tr></table></figure></p>
<p>当 Configuration 定义键值和值类型时，CacheManager.getCache 返回的 Cache 必须强制所请求的键和值类型与配置的相同。 要使用特定键和值类型请求缓存，必须使用以下CacheManager方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; <span class="title">getCache</span><span class="params">(String cacheName, Class&lt;K&gt; keyType, Class&lt;V&gt; valueType)</span></span>;</div></pre></td></tr></table></figure></p>
<p>当使用上述方法时，实现必须确保返回的Caches已经显式配置了调用该方法时指定的类型。 这为开发人员提供了更高级别的安全性，而不仅仅是简单地使用泛型。<br>执行还可以在运行时执行关键和值类型检测，用于可变缓存操作。<br>当 Configuration 未定义所需的 key 和值类型，或者它们都定义为Object.class时，在请求缓存时不需要执行运行时类型检查的实现。 要求缓存不检查使用：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;K, V&gt; <span class="function">Cache&lt;K, V&gt; Cache <span class="title">getCache</span><span class="params">(String cacheName)</span></span>;</div></pre></td></tr></table></figure></p>
<p>当缓存配置为特定类型，尝试使用getCache而不提供类型参数，或当Cache配置为没有特定类型时，使用具有特定类型参数的getCache时。会引发IllegalArgumentException异常。</p>
<p>在此示例中，缓存配置为具有String键类型和Integer值类型。 实现然后确保声明的类型与配置的缓存匹配，或者抛出IllegalArgumentException。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">CachingProvider cachingProvider = Caching.getCachingProvider(); CacheManager cacheManager = cachingProvider.getCacheManager();</div><div class="line">MutableConfiguration&lt;String, Integer&gt; config = <span class="keyword">new</span> MutableConfiguration&lt;String, Integer&gt;();</div><div class="line">config.setTypes(String.class, Integer.class); cacheManager.createCache(<span class="string">"simpleCache"</span>, config);</div><div class="line"><span class="comment">//... then later to get the cache without type information</span></div><div class="line">Cache&lt;String, Integer&gt; simpleCache = cacheManager.getCache(<span class="string">"simpleCache"</span>,</div><div class="line">String.class, Integer.class);</div><div class="line">simpleCache.put(<span class="string">"key1"</span>, <span class="number">3</span>);</div><div class="line">Integer value2 = simpleCache.get(<span class="string">"key1"</span>);</div></pre></td></tr></table></figure></p>
<p>虽然Java Caching API为编译和运行时类型的安全提供了机制，但类型检查仅适用于可重新类型的键和值，包括所有通用集合类型。 例如List <myclass>类型的值在运行时不可重新实现，因此只能与List.class类型进行比较。</myclass></p>
<h1 id="6-到期政策"><a href="#6-到期政策" class="headerlink" title="6.到期政策"></a>6.到期政策</h1><p>如果条目已过期，则不会从缓存返回。 如果没有为缓存配置有效期限策略，则默认为 Eternal 策略，其中缓存条目不会过期。<br>虽然 Eternal 政策不允许条目过期，但实施可能会在需要时驱逐条目。<br>可以通过提供ExpiryPolicy实现在配置时设置到期策略，如下所示。</p>
<p>高速缓存条目在执行某些高速缓存操作后的设定时间过期，使用Duration类定义时间。 持续时间是由java.util.concurrent.TimeUnit和long durationAmount构成的对。 最小允许的TimeUnit是TimeUnit.MILLISECONDS。<br>缓存条目的到期时间取决于配置的过期策略和执行的高速缓存操作。 定义以下ExpiryPolicy方法以根据缓存操作确定合适的持续时间：</p>
<ul>
<li>getExpiryForCreation（） - 创建条目时的持续时间</li>
<li>getExpiryForAccess（） - 访问条目时的新持续时间</li>
<li>getExpiryForUpdate（） - 更新条目时的新持续时间</li>
</ul>
<p>当Cache实现调用这些方法时，ExpiryPolicy将返回以下之一：</p>
<ul>
<li>定义所需条目到期时间的持续时间</li>
<li>Duration.ZERO表示一个条目现在被认为已过期</li>
</ul>
<p>另外getExpiryForUpdate（）和getExpiryForAccess（）也可能返回null，表示缓存实现应该使这些操作的条目的有效期限保持不变。<br>除了持续时间＃ZERO常数外，常数也定义为1天，1小时，30分钟，20分钟，10分钟，5分钟和1分钟。<br>下表详细说明了每个缓存方法如何与配置的ExpiryPolicy进行交互。</p>
<p>五个到期策略类实现被定义并包含在javax.cache.expiry包中的规范中：</p>
<ol>
<li>CreatedExpiryPolicy - 创建后一段时间过期。</li>
<li>ModifiedExpiryPolicy - 创建后一段时间过期。 更新条目时刷新过期。</li>
<li>AccessedExpiryPolicy - 创建后一段时间过期。 当访问条目时刷新过期（某种读取操作）</li>
<li>TouchedExpiryPolicy - 创建后一段时间过期。 更新或访问条目时刷新过期</li>
<li>ExternalExpiryPolicy - 永不过期。 这是默认值。</li>
</ol>
<h1 id="7-集成"><a href="#7-集成" class="headerlink" title="7.集成"></a>7.集成</h1><p>已经创建了方便的方法来简化与外部资源的集成。 这些都在javax.cache.integration包中。<br>两个接口CacheLoader和CacheWriter定义如下：<br>这些接口如下所述使用。</p>
<h2 id="7-1-Cache-Loading"><a href="#7-1-Cache-Loading" class="headerlink" title="7.1 Cache Loading"></a>7.1 Cache Loading</h2><p>Cache loadAll方法用于从外部资源加载值，并定义如下：<br>对于要使用的方法，在创建缓存时，必须在Configuration中设置CacheLoader。 高速缓存不需要设置为直读缓存模式来使用此方法。<br>装载可能需要大量的时间。 为此，可以传递一个CompletionListener，在完成或异常时通知完成。 定义如下：</p>
<p>还有一个阻止执行的CompletionListener，CompletionListenerFuture。 它实现了CompletionListener和Future。 如果调用了CompletionListener的onException（Exception e）方法，则异常被包装在ExecutionException中，并被Future get（）和get（long timeout，TimeUnit unit）方法重新抛出。</p>
<p>loadAll方法对于使用外部资源的数据预加载缓存非常有用。 可能需要它，因为应用程序逻辑假设数据在那里。 另一个用法是缓存升温。<br>如果数据不在缓存中，则不会导致应用程序错误，但会影响性能或可扩展性。</p>
<h2 id="7-2-Read-Through-Caching"><a href="#7-2-Read-Through-Caching" class="headerlink" title="7.2. Read-Through Caching"></a>7.2. Read-Through Caching</h2><p>读取高速缓存的行为与非读取高速缓存的方式完全相同，只有当缓存中缺少条目时，某些访问器方法将调用CacheLoader。<br>在配置时通过在MutableConfiguration上调用setReadThrough（boolean isReadThrough）来设置直读缓存。 还必须定义CacheLoader工厂。 CacheLoader用于从外部资源加载条目。</p>
<p>缓存处于读取模式时对每个方法调用的影响如下表所示：</p>
<p>Read-through 缓存是一种用于延迟加载缓存的有用成语。 它也有助于屏蔽Cache用户的外部资源如何加载到缓存的细节。<br>当对某些或所有缓存的内容进行预加载时，请使用 loadAll 方法。</p>
<h2 id="7-3-Write-Through-Caching"><a href="#7-3-Write-Through-Caching" class="headerlink" title="7.3. Write-Through Caching"></a>7.3. Write-Through Caching</h2><p>直写缓存的行为与非写入高速缓存的行为完全相同，只是某些变异方法将调用CacheWriter。<br>直写缓存通过在 MutableConfiguration 上调用 setWriteThrough（boolean isWriteThrough）在配置时设置。还必须定义 CacheWriter 工厂。 CacheWriter 用于从外部资源写入和删除条目。<br>缓存处于直写模式时对每个方法调用的影响如下表所示：</p>
<p>Write-through 缓存是保持外部资源更新缓存更改的有用成语。 它可以缓存Cache用户的外部资源被写入的细节。</p>
<h1 id="8-缓存条目监听"><a href="#8-缓存条目监听" class="headerlink" title="8.缓存条目监听"></a>8.缓存条目监听</h1><p>javax.cache.event包包含用于处理Cache产生的事件的类和接口。</p>
<h2 id="8-1-事件和事件类型"><a href="#8-1-事件和事件类型" class="headerlink" title="8.1 事件和事件类型"></a>8.1 事件和事件类型</h2><p>CacheEntryEvent定义如下：<br>EventType枚举列举了四种类型的事件，定义如下：</p>
<h2 id="8-2-CacheEntryListeners"><a href="#8-2-CacheEntryListeners" class="headerlink" title="8.2. CacheEntryListeners"></a>8.2. CacheEntryListeners</h2><h1 id="9-条目处理器"><a href="#9-条目处理器" class="headerlink" title="9.条目处理器"></a>9.条目处理器</h1><p>javax.cache.processor.EntryProcessor是一个可调用函数，非常类似于java.util.concurrent.Callable，应用程序可能用于高效地执行复合高速缓存操作，包括缓存条目上的原子访问，更新和删除，而不需要明确 锁定或交易。<br>当使用Cache＃invoke或Cache＃invokeAll方法调用时，EntryProcessor提供了一个MutableEntry，允许应用程序完全访问该条目。<br>javax.cache.processor.MutableEntry定义如下：</p>
<p>例如，可能希望检查Cache条目的值的应用程序，计算新值，更新条目并以原子方式返回一些其他值，可以使用自定义EntryProcessor实现。<br>javax.cache.processor.EntryProcessor接口定义如下：</p>
<p>要在缓存条目上调用EntryProcessor，应用程序必须使用Cache.invoke方法对单个key进行调用，并使用Cache.invokeAll方法来对keys进行调用。</p>
<h1 id="13-扩展建议"><a href="#13-扩展建议" class="headerlink" title="13.扩展建议"></a>13.扩展建议</h1><p>应遵循以下建议来提高Java Cache API实现之间的应用程序可移植性，建议：</p>
<ol>
<li><p>Custom Key类正确覆盖并实现Object.hashcode（）和Object.equals（）方法。自定义值类正确覆盖并实现Object.equals（）方法。<br>虽然推荐，实现不需要调用自定义类的Object.hashCode或Object.equals方法。实现可以自由优化，因此方法调用可以避免。<br>由于本规范没有定义对象等价性的概念，因此应该注意的是，使用自定义类并依赖于实现特定优化来确定等价性的应用程序可能不是便携式的。</p>
</li>
<li><p>为支持缓存值存储语义，自定义键和值类是可序列化的。</p>
</li>
<li>Caches不使用正斜杠（/）或冒号（:)作为其名称的一部分。另外建议不使用java或javax.should开头的缓存名称。</li>
<li>应用程序在请求CacheManagers时使用默认URI和属性。 </li>
<li>应用程序避免使用规范的可选功能，或使用 CachingProvider.isSupported 方法在存在时利用可选功能。例如，逐个参考的进程内实现可能会高得多<br>性能比逐个值，因为键和值可以直接引用。</li>
<li>应用程序在专有声明性配置文件中保留专有配置，而不是使用专有的编程缓存构造。</li>
<li>不使用CacheManager，Cache，Cache.Entry和CacheInvocationContext中的解包方法。这些用于分别访问专有的后备Cache和Cache.Entry。使用专有API可以降低可移植性。</li>
<li>应用不对Cache拓扑做出假设。<br> 例如，假设监听器将在本地执行，并且创建对本地应用程序类实例的依赖，可能不会在实现之间移植。</li>
<li>对于CAS操作，逐个引用将使用equals（）方法进行比较，但不一定要按值存储。确保自定义值类型上的equals（）实现考虑了所有非瞬态字段，以便使用equals（）方法比较序列化表单的比较结果将与之进行比较。</li>
<li>应用程序避免在EntryProcessor，CacheEntryListener，CacheLoader，CacheWriter或ExpiryPolicy的实现中对Cache和CacheManager方法进行引用和调用。<br>重入算法可能导致不可预测的应用程序行为，包括运行时异常，死锁和/或无限资源消耗。</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h1&gt;&lt;p&gt;jsr107是本地缓存标准的API，用于创建、访问、更新、删除缓存中的数据。&lt;br&gt;缓存能显著的提升，从多数据源，网络服务，
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>spring 源码解析 BeanPostProcessor</title>
    <link href="http://leerenbo.cn/2017/07/21/spring-code-BeanPostProcessor/"/>
    <id>http://leerenbo.cn/2017/07/21/spring-code-BeanPostProcessor/</id>
    <published>2017-07-21T09:35:29.000Z</published>
    <updated>2017-11-17T08:44:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-BeanPostProcessor"><a href="#1-BeanPostProcessor" class="headerlink" title="1. BeanPostProcessor"></a>1. BeanPostProcessor</h3><p>BeanPostProcessor.postProcessAfterInitialization在FactoryBean单例实例化后，Bean单例实例化后，InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation返回实例后，都会调用</p>
<h4 id="1-1-FactoryBean构造Bean时，调用BeanPostProcessor-postProcessAfterInitialization"><a href="#1-1-FactoryBean构造Bean时，调用BeanPostProcessor-postProcessAfterInitialization" class="headerlink" title="1.1 FactoryBean构造Bean时，调用BeanPostProcessor.postProcessAfterInitialization"></a>1.1 FactoryBean构造Bean时，调用BeanPostProcessor.postProcessAfterInitialization</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>AbstractBeanFactory.getObjectForBeanInstance -&gt;<br>FactoryBeanRegistrySupport.getObjectFromFactoryBean -&gt;<br>FactoryBeanRegistrySupport.postProcessObjectFromFactoryBean<br>@Override AbstractAutowireCapableBeanFactory.postProcessObjectFromFactoryBean -&gt;<br>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization<br>BeanPostProcessor.postProcessAfterInitialization</p>
<h3 id="2-调用InstantiationAwareBeanPostProcessor"><a href="#2-调用InstantiationAwareBeanPostProcessor" class="headerlink" title="2. 调用InstantiationAwareBeanPostProcessor"></a>2. 调用InstantiationAwareBeanPostProcessor</h3><h4 id="2-1-createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor-postProcessBeforeInstantiation"><a href="#2-1-createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor-postProcessBeforeInstantiation" class="headerlink" title="2.1 createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation"></a>2.1 createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation -&gt;<br>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInstantiation -&gt;<br>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation</p>
<h4 id="2-2-createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor-postProcessBeforeInstantiation之后bean不为空之后，调用BeanPostProcessor-postProcessAfterInitialization"><a href="#2-2-createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor-postProcessBeforeInstantiation之后bean不为空之后，调用BeanPostProcessor-postProcessAfterInitialization" class="headerlink" title="2.2 createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation之后bean不为空之后，调用BeanPostProcessor.postProcessAfterInitialization"></a>2.2 createBean时，doCreateBean之前，调用InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation之后bean不为空之后，调用BeanPostProcessor.postProcessAfterInitialization</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.resolveBeforeInstantiation -&gt;<br>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization -&gt;<br>BeanPostProcessor.postProcessAfterInitialization</p>
<h3 id="3-MergedBeanDefinitionPostProcessor"><a href="#3-MergedBeanDefinitionPostProcessor" class="headerlink" title="3. MergedBeanDefinitionPostProcessor"></a>3. MergedBeanDefinitionPostProcessor</h3><h4 id="3-1-doCreateBean时，createBeanInstance之后，earlySingletonExposure之前。调用MergedBeanDefinitionPostProcessor-postProcessMergedBeanDefinition-进行注释融合"><a href="#3-1-doCreateBean时，createBeanInstance之后，earlySingletonExposure之前。调用MergedBeanDefinitionPostProcessor-postProcessMergedBeanDefinition-进行注释融合" class="headerlink" title="3.1 doCreateBean时，createBeanInstance之后，earlySingletonExposure之前。调用MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition 进行注释融合"></a>3.1 doCreateBean时，createBeanInstance之后，earlySingletonExposure之前。调用MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition 进行注释融合</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.doCreateBean -&gt;<br>AbstractAutowireCapableBeanFactory.applyMergedBeanDefinitionPostProcessors -&gt;<br>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition</p>
<h3 id="4-SmartInstantiationAwareBeanPostProcessor"><a href="#4-SmartInstantiationAwareBeanPostProcessor" class="headerlink" title="4. SmartInstantiationAwareBeanPostProcessor"></a>4. SmartInstantiationAwareBeanPostProcessor</h3><h4 id="4-1-循环引用时，ObjectFactory-getObject获取对象时，调用SmartInstantiationAwareBeanPostProcessor-getEarlyBeanReference，用于提前返回引用，支持单例的循环引用"><a href="#4-1-循环引用时，ObjectFactory-getObject获取对象时，调用SmartInstantiationAwareBeanPostProcessor-getEarlyBeanReference，用于提前返回引用，支持单例的循环引用" class="headerlink" title="4.1 循环引用时，ObjectFactory.getObject获取对象时，调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference，用于提前返回引用，支持单例的循环引用"></a>4.1 循环引用时，ObjectFactory.getObject获取对象时，调用SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference，用于提前返回引用，支持单例的循环引用</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.doCreateBean -&gt;<br>AbstractAutowireCapableBeanFactory.addSingletonFactory -&gt;<br>ObjectFactory.getObject -&gt;<br>AbstractAutowireCapableBeanFactory.getEarlyBeanReference -&gt;<br>SmartInstantiationAwareBeanPostProcessor.getEarlyBeanReference</p>
<h3 id="5-InstantiationAwareBeanPostProcessor"><a href="#5-InstantiationAwareBeanPostProcessor" class="headerlink" title="5. InstantiationAwareBeanPostProcessor"></a>5. InstantiationAwareBeanPostProcessor</h3><h4 id="5-1-populateBean时，在自动装配之前，调用InstantiationAwareBeanPostProcessor-postProcessAfterInstantiation，用于字段注入，可停止属性填充"><a href="#5-1-populateBean时，在自动装配之前，调用InstantiationAwareBeanPostProcessor-postProcessAfterInstantiation，用于字段注入，可停止属性填充" class="headerlink" title="5.1 populateBean时，在自动装配之前，调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation，用于字段注入，可停止属性填充"></a>5.1 populateBean时，在自动装配之前，调用InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation，用于字段注入，可停止属性填充</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.doCreateBean -&gt;<br>AbstractAutowireCapableBeanFactory.populateBean -&gt;<br>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation</p>
<h3 id="6-InstantiationAwareBeanPostProcessor"><a href="#6-InstantiationAwareBeanPostProcessor" class="headerlink" title="6.InstantiationAwareBeanPostProcessor"></a>6.InstantiationAwareBeanPostProcessor</h3><h4 id="6-1-populateBean时，在装配之后，调用InstantiationAwareBeanPostProcessor-postProcessPropertyValues，用于Required校验，替换属性等"><a href="#6-1-populateBean时，在装配之后，调用InstantiationAwareBeanPostProcessor-postProcessPropertyValues，用于Required校验，替换属性等" class="headerlink" title="6.1 populateBean时，在装配之后，调用InstantiationAwareBeanPostProcessor.postProcessPropertyValues，用于Required校验，替换属性等"></a>6.1 populateBean时，在装配之后，调用InstantiationAwareBeanPostProcessor.postProcessPropertyValues，用于Required校验，替换属性等</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.doCreateBean -&gt;<br>AbstractAutowireCapableBeanFactory.populateBean -&gt;<br>InstantiationAwareBeanPostProcessor.postProcessPropertyValues</p>
<h3 id="7-BeanPostProcessor"><a href="#7-BeanPostProcessor" class="headerlink" title="7 BeanPostProcessor"></a>7 BeanPostProcessor</h3><h4 id="7-1-initializeBean初始化时，invokeInitMethods之前。调用BeanPostProcessor-postProcessBeforeInitialization"><a href="#7-1-initializeBean初始化时，invokeInitMethods之前。调用BeanPostProcessor-postProcessBeforeInitialization" class="headerlink" title="7.1 initializeBean初始化时，invokeInitMethods之前。调用BeanPostProcessor.postProcessBeforeInitialization"></a>7.1 initializeBean初始化时，invokeInitMethods之前。调用BeanPostProcessor.postProcessBeforeInitialization</h4><p>用于调用 @注释的 初始化方法等。<br>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.doCreateBean -&gt;<br>AbstractAutowireCapableBeanFactory.initializeBean -&gt;<br>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsBeforeInitialization -&gt;<br>BeanPostProcessor.postProcessBeforeInitialization</p>
<h4 id="7-2-initializeBean初始化时，invokeInitMethods之后。调用BeanPostProcessor-postProcessAfterInitialization"><a href="#7-2-initializeBean初始化时，invokeInitMethods之后。调用BeanPostProcessor-postProcessAfterInitialization" class="headerlink" title="7.2 initializeBean初始化时，invokeInitMethods之后。调用BeanPostProcessor.postProcessAfterInitialization"></a>7.2 initializeBean初始化时，invokeInitMethods之后。调用BeanPostProcessor.postProcessAfterInitialization</h4><p>AbstractBeanFactory.doGetBean -&gt;<br>DefaultSingletonBeanRegistry.getSingleton -&gt;<br>AbstractAutowireCapableBeanFactory.createBean -&gt;<br>AbstractAutowireCapableBeanFactory.doCreateBean -&gt;<br>AbstractAutowireCapableBeanFactory.initializeBean -&gt;<br>AbstractAutowireCapableBeanFactory.applyBeanPostProcessorsAfterInitialization -&gt;<br>BeanPostProcessor.postProcessAfterInitialization</p>
<h3 id="8-BeanFactoryPostProcessor"><a href="#8-BeanFactoryPostProcessor" class="headerlink" title="8 BeanFactoryPostProcessor"></a>8 BeanFactoryPostProcessor</h3><p>AbstractApplicationContext </p>
<h3 id="9-BeanDefinitionRegistryPostProcessor-extends-BeanFactoryPostProcessor-在BD扫描读取之后，再扫描其他属性获取BD。"><a href="#9-BeanDefinitionRegistryPostProcessor-extends-BeanFactoryPostProcessor-在BD扫描读取之后，再扫描其他属性获取BD。" class="headerlink" title="9 BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor 在BD扫描读取之后，再扫描其他属性获取BD。"></a>9 BeanDefinitionRegistryPostProcessor extends BeanFactoryPostProcessor 在BD扫描读取之后，再扫描其他属性获取BD。</h3><h4 id="9-1-ConfigurationClassPostProcessor-implements-BeanDefinitionRegistryPostProcessor-PriorityOrdered-ResourceLoaderAware-BeanClassLoaderAware-EnvironmentAware-扫描-Configuration"><a href="#9-1-ConfigurationClassPostProcessor-implements-BeanDefinitionRegistryPostProcessor-PriorityOrdered-ResourceLoaderAware-BeanClassLoaderAware-EnvironmentAware-扫描-Configuration" class="headerlink" title="9.1.ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware 扫描 @Configuration"></a>9.1.ConfigurationClassPostProcessor implements BeanDefinitionRegistryPostProcessor, PriorityOrdered, ResourceLoaderAware, BeanClassLoaderAware, EnvironmentAware 扫描 @Configuration</h4>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;1-BeanPostProcessor&quot;&gt;&lt;a href=&quot;#1-BeanPostProcessor&quot; class=&quot;headerlink&quot; title=&quot;1. BeanPostProcessor&quot;&gt;&lt;/a&gt;1. BeanPostProcessor&lt;/h3&gt;&lt;p&gt;
    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码解析 4.BeanFactory</title>
    <link href="http://leerenbo.cn/2017/05/29/spring-code-beanfactory/"/>
    <id>http://leerenbo.cn/2017/05/29/spring-code-beanfactory/</id>
    <published>2017-05-29T04:56:59.000Z</published>
    <updated>2017-05-30T12:50:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>BeanFactory为Spring的IoC功能提供了基础，但它直接用于与其他第三方框架的集成，现在大部分Spring用户都具有历史性。 BeanFactory和相关接口（如BeanFactoryAware，InitializingBean，DisposableBean）仍然存在于Spring中，目的是与与Spring集成的大量第三方框架向后兼容。 通常第三方组件不能使用更现代的等同物，例如@PostConstruct或@PreDestroy，以便与JDK 1.4保持兼容，或避免依赖于JSR-250。</p>
<h2 id="2-BeanDefinition"><a href="#2-BeanDefinition" class="headerlink" title="2. BeanDefinition"></a>2. BeanDefinition</h2><h3 id="2-1-类图"><a href="#2-1-类图" class="headerlink" title="2.1 类图"></a>2.1 类图</h3><p><img src="assets/img/spring/BeanDefinition.png" alt=""></p>
<h3 id="2-2-接口"><a href="#2-2-接口" class="headerlink" title="2.2 接口"></a>2.2 接口</h3><h5 id="2-2-1-AttributeAccessor"><a href="#2-2-1-AttributeAccessor" class="headerlink" title="2.2.1 AttributeAccessor"></a>2.2.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/AttributeAccessor.java" target="_blank" rel="external">AttributeAccessor</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 定义一个通用规范的接口，用于附加和访问任意对象的元数据。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AttributeAccessor</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将&#123;<span class="doctag">@code</span> name&#125;定义的属性设置为提供的&#123;<span class="doctag">@code</span> 值&#125;。 如果&#123;<span class="doctag">@code</span> 值&#125;为&#123;<span class="doctag">@code</span> null&#125;，则属性为&#123;<span class="doctag">@link</span> #removeAttribute removed&#125;。</div><div class="line">	 * 一般来说，用户应该注意通过使用完全限定的名称防止与其他元数据属性重叠，也许使用类或包名称作为前缀。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name, Object value)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取由&#123;<span class="doctag">@code</span> name&#125;标识的属性的值。 如果属性不存在，返回&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">getAttribute</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 删除&#123;<span class="doctag">@code</span> name&#125;标识的属性并返回其值。 如果找不到&#123;<span class="doctag">@code</span> name&#125;下的属性，则返回&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">removeAttribute</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果&#123;<span class="doctag">@code</span> name&#125;标识的属性存在，则返回&#123;<span class="doctag">@code</span> true&#125;。 否则返回&#123;<span class="doctag">@code</span> false&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">hasAttribute</span><span class="params">(String name)</span></span>;</div><div class="line">	String[] attributeNames();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-2-BeanMetadataElement"><a href="#2-2-2-BeanMetadataElement" class="headerlink" title="2.2.2 BeanMetadataElement"></a>2.2.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/BeanMetadataElement.java" target="_blank" rel="external">BeanMetadataElement</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 携带配置源对象的 bean metadata 元素实现的接口。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanMetadataElement</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此元数据元素的配置源&#123;<span class="doctag">@code</span> Object&#125;（可能为&#123;<span class="doctag">@code</span> null&#125;）。</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">getSource</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-3-BeanDefinition"><a href="#2-2-3-BeanDefinition" class="headerlink" title="2.2.3 BeanDefinition"></a>2.2.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/config/BeanDefinition.java" target="_blank" rel="external">BeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * BeanDefinition 描述了一个bean实例，它具有属性值，构造函数参数值以及具体实现提供的进一步信息。</div><div class="line"> * 这只是一个最小的接口：主要目的是允许&#123;<span class="doctag">@link</span> BeanFactoryPostProcessor&#125;（如&#123;<span class="doctag">@link</span> PropertyPlaceholderConfigurer&#125;）来内省和修改属性值和其他bean元数据。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinition</span> <span class="keyword">extends</span> <span class="title">AttributeAccessor</span>, <span class="title">BeanMetadataElement</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 标准单例范围的范围标识符：“singleton”。</div><div class="line">	 * 请注意，扩展bean工厂可能会支持更多的范围。</div><div class="line">	 */</div><div class="line">	String SCOPE_SINGLETON = ConfigurableBeanFactory.SCOPE_SINGLETON;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 标准原型范围的范围标识：“prototype”。</div><div class="line">	 * 请注意，扩展bean工厂可能会支持更多的范围。</div><div class="line">	 */</div><div class="line">	String SCOPE_PROTOTYPE = ConfigurableBeanFactory.SCOPE_PROTOTYPE;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 角色提示，指出&#123;<span class="doctag">@code</span> BeanDefinition&#125;是应用程序的主要部分。 通常对应于用户定义的bean。</div><div class="line">	 */</div><div class="line">	<span class="keyword">int</span> ROLE_APPLICATION = <span class="number">0</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 角色提示，指出 &#123;<span class="doctag">@code</span> BeanDefinition&#125; 是一些较大配置的支持部分，通常是外部&#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;。 &#123;<span class="doctag">@code</span> SUPPORT&#125; bean被认为是重要的，以便在查看特定的&#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;时注意到，但在查看应用程序的整体配置时不会。</div><div class="line">	 */</div><div class="line">	<span class="keyword">int</span> ROLE_SUPPORT = <span class="number">1</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 角色提示，指出&#123;<span class="doctag">@code</span> BeanDefinition&#125;提供了完全的后台角色，与最终用户无关。 当注册完全是&#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.ComponentDefinition&#125;的内部工作的一部分的bean时，使用此提示。</div><div class="line">	 */</div><div class="line">	<span class="keyword">int</span> ROLE_INFRASTRUCTURE = <span class="number">2</span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">// Modifiable attributes</span></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置此bean定义的父定义的名称（如果有）。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setParentName</span><span class="params">(String parentName)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此bean定义的父定义的名称（如果有）。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getParentName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定此bean定义的bean类名称。</div><div class="line">	 * 可以在bean工厂后处理期间修改类名称，通常用解析变量替换原始类名。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setBeanClassName</span><span class="params">(String beanClassName)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此bean定义的当前bean类名。</div><div class="line">	 * 请注意，这不一定是在运行时使用的实际类名，以便子代定义从其父代替覆盖/继承类名。</div><div class="line">	 * 此外，这可能只是调用的工厂方法类，或者在调用方法的工厂bean引用的情况下甚至可能为空。</div><div class="line">	 * 因此，不要认为这在运行时是确定的bean类型，而是仅在单个bean定义级别使用它来解析目的。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getBeanClassName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 覆盖此bean的目标范围，指定一个新的范围名称。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setScope</span><span class="params">(String scope)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此bean的当前目标范围的名称，如果尚未知道，则返回&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getScope</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置这个bean是否应该被懒惰地初始化。</div><div class="line">	 * 如果&#123;<span class="doctag">@code</span> false&#125;，bean将在启动时由Bean工厂实例化，Bean工厂会执行急速初始化单例。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setLazyInit</span><span class="params">(<span class="keyword">boolean</span> lazyInit)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回这个bean是否应该被懒惰地初始化，也就是说在启动时不是急切地被实例化。 </div><div class="line">	 * 只适用于singleton bean。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isLazyInit</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置该bean依赖于初始化的bean的名称。</div><div class="line">	 * bean工厂将保证这些bean首先被初始化。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDependsOn</span><span class="params">(String... dependsOn)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回该bean依赖的bean名称。</div><div class="line">	 */</div><div class="line">	String[] getDependsOn();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置这个bean是否是自动连线到其他bean的候选项。</div><div class="line">	 * 请注意，此标志仅用于影响基于类类型的自动装配。</div><div class="line">	 * 它不影响名称的显式引用，即使指定的bean未被标记为自动连接候选，它也将被解析。 因此，如果名称匹配，则通过名称自动装配将会注入一个bean。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setAutowireCandidate</span><span class="params">(<span class="keyword">boolean</span> autowireCandidate)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回这个bean是否是自动连线到其他bean的候选项。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置此bean是否是主要的自动连线候选。</div><div class="line">	 * 如果这个值是&#123;<span class="doctag">@code</span> true&#125;，在多个匹配候选者中只有一个bean，则它将作为一个打破者。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setPrimary</span><span class="params">(<span class="keyword">boolean</span> primary)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此bean是否是主要的自动装配候选。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrimary</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定要使用的工厂bean（如果有）。</div><div class="line">	 * 这个为指定的工厂方法的bean的名称。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFactoryBeanName</span><span class="params">(String factoryBeanName)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回工厂bean名称，如果有的话。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getFactoryBeanName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定工厂方法（如果有）。</div><div class="line">	 * 该方法将使用构造函数参数进行调用，如果没有指定，则不使用参数。</div><div class="line">	 * 该方法将在指定的工厂bean（如果有）或其他方式在本地bean类上作为静态方法调用。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setFactoryMethodName</span><span class="params">(String factoryMethodName)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回工厂方法（如有）。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getFactoryMethodName</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此bean的构造函数参数值。</div><div class="line">	 * 可以在bean工厂post-processing期间修改返回的实例。</div><div class="line">	 */</div><div class="line">	<span class="function">ConstructorArgumentValues <span class="title">getConstructorArgumentValues</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回要应用于bean新实例的属性值。</div><div class="line">	 * 可以在bean工厂post-processing期间修改返回的实例。</div><div class="line">	 */</div><div class="line">	<span class="function">MutablePropertyValues <span class="title">getPropertyValues</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">// Read-only attributes</span></div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isPrototype</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isAbstract</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getRole</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回这个bean定义的人类可读描述。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回这个bean定义来源的资源的描述（为了在发生错误时显示上下文的目的）。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getResourceDescription</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回原始BeanDefinition，否则返回&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 * 允许检索被装饰的bean定义（如果有）。</div><div class="line">	 * 请注意，此方法返回直接鼻祖。 通过鼻祖链迭代，以查找用户定义的原始BeanDefinition。</div><div class="line">	 */</div><div class="line">	<span class="function">BeanDefinition <span class="title">getOriginatingBeanDefinition</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-4-AnnotatedBeanDefinition"><a href="#2-2-4-AnnotatedBeanDefinition" class="headerlink" title="2.2.4 AnnotatedBeanDefinition"></a>2.2.4 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AnnotatedBeanDefinition.java" target="_blank" rel="external">AnnotatedBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 扩展&#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanDefinition&#125;接口，暴露关于其bean类的&#123;<span class="doctag">@link</span> org.springframework.core.type.AnnotationMetadata&#125;，而可以不需要加载该类。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AnnotatedBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanDefinition</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 为此bean定义的bean类获取注释元数据（以及基本类元数据）。</div><div class="line">	 */</div><div class="line">	<span class="function">AnnotationMetadata <span class="title">getMetadata</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取此bean定义的工厂方法的元数据（如果有）。</div><div class="line">	 */</div><div class="line">	<span class="function">MethodMetadata <span class="title">getFactoryMethodMetadata</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-3-实现"><a href="#2-3-实现" class="headerlink" title="2.3 实现"></a>2.3 实现</h3><h5 id="2-3-1-AttributeAccessorSupport"><a href="#2-3-1-AttributeAccessorSupport" class="headerlink" title="2.3.1 AttributeAccessorSupport"></a>2.3.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/AttributeAccessorSupport.java" target="_blank" rel="external">AttributeAccessorSupport</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> AttributeAccessor AttributeAccessors&#125;的支持类，提供所有方法的基本实现。 被子类扩展。</div><div class="line"> * 如果子类和所有属性值都是&#123;<span class="doctag">@link</span> Serializable&#125;，则可以使用&#123;<span class="doctag">@link</span> Serializable&#125;。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AttributeAccessorSupport</span> <span class="keyword">implements</span> <span class="title">AttributeAccessor</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="comment">/** Map with String keys and Object values */</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; attributes = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">0</span>);</div></pre></td></tr></table></figure>
<h5 id="2-3-2-BeanMetadataAttributeAccessor"><a href="#2-3-2-BeanMetadataAttributeAccessor" class="headerlink" title="2.3.2 BeanMetadataAttributeAccessor"></a>2.3.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/BeanMetadataAttributeAccessor.java" target="_blank" rel="external">BeanMetadataAttributeAccessor</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 扩展&#123;<span class="doctag">@link</span> org.springframework.core.AttributeAccessorSupport&#125;，将属性保存为&#123;<span class="doctag">@link</span> BeanMetadataAttribute&#125;对象，以便跟踪定义源。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMetadataAttributeAccessor</span> <span class="keyword">extends</span> <span class="title">AttributeAccessorSupport</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Object source;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSource</span><span class="params">(Object source)</span> </span>&#123;</div><div class="line">		<span class="keyword">this</span>.source = source;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将给定的BeanMetadataAttribute添加到此访问器的一组属性中。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addMetadataAttribute</span><span class="params">(BeanMetadataAttribute attribute)</span> </span>&#123;</div><div class="line">		<span class="keyword">super</span>.setAttribute(attribute.getName(), attribute);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 在这个访问者的属性集中查找给定的BeanMetadataAttribute。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> BeanMetadataAttribute <span class="title">getMetadataAttribute</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> (BeanMetadataAttribute) <span class="keyword">super</span>.getAttribute(name);</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 持有键值样式属性，是bean定义的一部分。</div><div class="line"> * 保留键值对之外的跟踪定义源。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanMetadataAttribute</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object value;</div><div class="line">	<span class="keyword">private</span> Object source;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-3-AbstractBeanDefinition"><a href="#2-3-3-AbstractBeanDefinition" class="headerlink" title="2.3.3 AbstractBeanDefinition"></a>2.3.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanDefinition.java" target="_blank" rel="external">AbstractBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 具体的，完整的&#123;<span class="doctag">@link</span> BeanDefinition&#125;类的基类，分为&#123;<span class="doctag">@link</span> GenericBeanDefinition&#125;，&#123;<span class="doctag">@link</span> RootBeanDefinition&#125;和&#123;<span class="doctag">@link</span> ChildBeanDefinition&#125;的常用属性。</div><div class="line"> *</div><div class="line"> * autowire常量与&#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.AutowireCapableBeanFactory&#125;接口中定义的常量相匹配。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinition</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span></span></div><div class="line">		<span class="keyword">implements</span> <span class="title">BeanDefinition</span>, <span class="title">Cloneable</span> &#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 默认范围名称的常量：&#123;<span class="doctag">@code</span> ""&#125;，相当于单例状态，除非从父bean定义（如果适用）覆盖。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SCOPE_DEFAULT = <span class="string">""</span>;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_NO = AutowireCapableBeanFactory.AUTOWIRE_NO;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_BY_NAME = AutowireCapableBeanFactory.AUTOWIRE_BY_NAME;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_BY_TYPE = AutowireCapableBeanFactory.AUTOWIRE_BY_TYPE;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_CONSTRUCTOR = AutowireCapableBeanFactory.AUTOWIRE_CONSTRUCTOR;</div><div class="line">	<span class="meta">@Deprecated</span></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> AUTOWIRE_AUTODETECT = AutowireCapableBeanFactory.AUTOWIRE_AUTODETECT;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 根本没有依赖关系。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_NONE = <span class="number">0</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 对象引用的依赖关系检查。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_OBJECTS = <span class="number">1</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 依赖关系检查“简单”属性。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_SIMPLE = <span class="number">2</span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 所有属性的依赖关系检查</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEPENDENCY_CHECK_ALL = <span class="number">3</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 常量，表示容器应尝试推断出一个bean的 &#123;<span class="doctag">@link</span> #setDestroyMethodName destroy method name&#125;，而不是显式指定方法名称。 值&#123;<span class="doctag">@value</span>&#125;专门设计为在方法名称中包括非法的字符，确保不会与具有相同名称的合法命名方法发生冲突。</div><div class="line">	 * 目前，在destroy方法推断中检测到的方法名称是“close”和“shutdown”，如果存在于特定的bean类上。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String INFER_METHOD = <span class="string">"(inferred)"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> Object beanClass;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String scope = SCOPE_DEFAULT;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> abstractFlag = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> autowireMode = AUTOWIRE_NO;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> dependencyCheck = DEPENDENCY_CHECK_NONE;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">	 * 该bean依赖于初始化的bean的名称。 bean工厂将保证这些bean首先被初始化。</div><div class="line">     * 请注意，依赖关系通常通过bean属性或构造函数参数来表示。 对于其他类型的依赖关系（* ugh *）或启动时的数据库准备，此属性应该是必需的。</div><div class="line">     */</div><div class="line">	<span class="keyword">private</span> String[] dependsOn;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">	 * 设置这个bean是否是自动连线到其他bean的候选。</div><div class="line">	 * 请注意，此标志仅用于影响基于类型的自动装配。 它不会影响名称的显式引用，即使指定的bean未标记为自动连接候选，也将得到解析。 因此，如果名称匹配，则通过名称自动装配将会注入一个bean。</div><div class="line">     */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> autowireCandidate = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> primary = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">    * 限定符，用于自动装配候选解决，由限定的类型名称作为key 。</div><div class="line">    */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, AutowireCandidateQualifier&gt; qualifiers = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定用于创建bean实例的回调，作为声明性指定的工厂方法的替代方法。</div><div class="line">	 * 如果设置了这样的回调，它将覆盖任何其他构造函数或工厂方法元数据。</div><div class="line">	 * 然而，bean属性和潜在注释驱动的注射仍然照常使用。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Supplier&lt;?&gt; instanceSupplier;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">	 * 指定是否允许访问非公共构造函数和方法，对于指向这些的外部化元数据的情况。 默认值为&#123;<span class="doctag">@code</span> true&#125;; 将其切换到&#123;<span class="doctag">@code</span> false&#125;以允许进行公共访问。</div><div class="line">	 * 这适用于构造函数解析，工厂方法解析以及init / destroy方法。 </div><div class="line">	 * Bean属性访问器在任何情况下都必须公开，不受此设置的影响。</div><div class="line">	 * 请注意，注释驱动的配置仍将访问非公开成员，只要它们已被注释。 此设置仅适用于此bean定义中的外部化元数据。</div><div class="line">     */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> nonPublicAccessAllowed = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">	 * 指定是否以宽松模式（&#123;<span class="doctag">@code</span> true&#125;（默认值为））解析构造函数，或者切换到严格解析</div><div class="line">	 * （如果在转换参数时模糊匹配所有的构造函数时抛出异常，而宽大模式将使用 一个与“最接近”类型匹配）。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> lenientConstructorResolution = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String factoryBeanName;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定工厂方法（如果有）。 该方法将使用构造函数参数进行调用，如果没有指定，则不使用参数。</div><div class="line">	 * 该方法将在指定的工厂bean（如果有）否则在本地bean类上作为静态方法调用。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> String factoryMethodName;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ConstructorArgumentValues constructorArgumentValues;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> MutablePropertyValues propertyValues;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> MethodOverrides methodOverrides = <span class="keyword">new</span> MethodOverrides();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String initMethodName;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String destroyMethodName;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> enforceInitMethod = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> enforceDestroyMethod = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置此bean定义是否为“合成”，即不由应用程序本身定义（例如，通过&#123;<span class="doctag">@code</span> &lt;aop：config&gt;&#125;创建的基础架构bean，例如自动代理的帮助器）。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> synthetic = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> role = BeanDefinition.ROLE_APPLICATION;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String description;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 这个bean定义来自的资源。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Resource resource;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 确定自动装配候选人的资格。 包含一个或多个此类限定符的bean定义可以对字段或参数上的注释进行精细匹配以进行自动装配。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowireCandidateQualifier</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span> </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 将value存在 key 是 VALUE_KEY 的 BeanMetadataAttributeAccessor抽象实现中</div><div class="line">     */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> String VALUE_KEY = <span class="string">"value"</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String typeName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  &#123;<span class="doctag">@link</span> org.springframework.beans.factory.config.BeanDefinition&#125;的描述性&#123;<span class="doctag">@link</span> org.springframework.core.io.Resource&#125;包装器。</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BeanDefinition beanDefinition;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 构造函数参数值的持有者，通常作为bean定义的一部分。</div><div class="line"> * 支持构造函数参数列表中特定索引的值以及类型中的泛型参数匹配。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorArgumentValues</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Integer, ValueHolder&gt; indexedArgumentValues = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">0</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;ValueHolder&gt; genericArgumentValues = <span class="keyword">new</span> LinkedList&lt;&gt;();</div><div class="line">	</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Holder for a constructor argument value, with an optional type</div><div class="line">	 * attribute indicating the target type of the actual constructor argument.</div><div class="line">	 * </div><div class="line">	 * 构造函数参数值的持有者，可选的type属性指示实际构造函数参数的目标类型。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueHolder</span> <span class="keyword">implements</span> <span class="title">BeanMetadataElement</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> Object value;</div><div class="line">		<span class="keyword">private</span> String type;</div><div class="line">		<span class="keyword">private</span> String name;</div><div class="line">		<span class="keyword">private</span> Object source;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">boolean</span> converted = <span class="keyword">false</span>;</div><div class="line">		<span class="keyword">private</span> Object convertedValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> PropertyValues&#125;接口的默认实现。</div><div class="line"> * 允许对属性进行简单的操作，并提供构造函数以支持从Map的深层复制和构造。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertyValues</span> <span class="keyword">implements</span> <span class="title">PropertyValues</span>, <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertyValue&gt; propertyValueList;</div><div class="line">	<span class="keyword">private</span> Set&lt;String&gt; processedProperties;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> converted = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 包含一个或多个&#123;<span class="doctag">@link</span> PropertyValue&#125;对象的Holder，通常包含特定目标bean的一个更新。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyValues</span> </span>&#123;</div><div class="line"></div><div class="line">	PropertyValue[] getPropertyValues();</div><div class="line">	<span class="function">PropertyValue <span class="title">getPropertyValue</span><span class="params">(String propertyName)</span></span>;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回自上一个PropertyValues之后的更改。 子类也应该覆盖&#123;<span class="doctag">@code</span> equals&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function">PropertyValues <span class="title">changesSince</span><span class="params">(PropertyValues old)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String propertyName)</span></span>;</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 对象保存单个bean属性的信息和值。 在这里使用一个对象，而不仅仅是将所有属性存储在按属性名称键入的 map 中，这样可以更有弹性，并以优化的方式处理索引属性等。</div><div class="line"> * 请注意，该值不需要是最终必需的类型：&#123;<span class="doctag">@link</span> BeanWrapper&#125;实现应该处理任何必要的转换，因为该对象不知道将要应用的对象的任何内容。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyValue</span> <span class="keyword">extends</span> <span class="title">BeanMetadataAttributeAccessor</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String name;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object value;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> optional = <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> converted = <span class="keyword">false</span>;</div><div class="line">	<span class="keyword">private</span> Object convertedValue;</div><div class="line">	<span class="comment">/** Package-visible field that indicates whether conversion is necessary */</span></div><div class="line">	<span class="keyword">volatile</span> Boolean conversionNecessary;</div><div class="line">	<span class="comment">/** Package-visible field for caching the resolved property path tokens */</span></div><div class="line">	<span class="keyword">transient</span> <span class="keyword">volatile</span> Object resolvedTokens;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@code</span> BeanDefinition&#125;属性的简单持有人默认。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinitionDefaults</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> dependencyCheck = AbstractBeanDefinition.DEPENDENCY_CHECK_NONE;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> autowireMode = AbstractBeanDefinition.AUTOWIRE_NO;</div><div class="line">	<span class="keyword">private</span> String initMethodName;</div><div class="line">	<span class="keyword">private</span> String destroyMethodName;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-4-RootBeanDefinition"><a href="#2-3-4-RootBeanDefinition" class="headerlink" title="2.3.4 RootBeanDefinition"></a>2.3.4 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java" target="_blank" rel="external">RootBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 根bean定义代表在运行时在Spring BeanFactory中备份特定bean的合并的bean定义。</div><div class="line"> * 它可能已经从多个相互继承原始bean定义创建，通常以&#123;<span class="doctag">@link</span> GenericBeanDefinition GenericBeanDefinitions&#125;的形式进行创建。</div><div class="line"> * 根bean定义本质上是运行时的“统一”bean定义视图。</div><div class="line"> *</div><div class="line"> * 根bean定义也可用于在配置阶段注册各个bean定义。</div><div class="line"> * 但是，从Spring 2.5，以编程方式注册bean定义的首选方式是&#123;<span class="doctag">@link</span> GenericBeanDefinition&#125;类。</div><div class="line"> * GenericBeanDefinition 的优点是允许动态定义父依赖关系，而不是将角色“硬编码”为根bean定义。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Rod Johnson</div><div class="line"> * <span class="doctag">@author</span> Juergen Hoeller</div><div class="line"> * <span class="doctag">@see</span> GenericBeanDefinition</div><div class="line"> * <span class="doctag">@see</span> ChildBeanDefinition</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootBeanDefinition</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinition</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> BeanDefinitionHolder decoratedDefinition;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定&#123;<span class="doctag">@link</span> AnnotatedElement&#125;定义限定符，而不是目标类或工厂方法。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> AnnotatedElement qualifiedElement;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> allowCaching = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> isFactoryMethodUnique = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果事先知道，请指定此bean定义的含有泛型的目标类型。</div><div class="line">	 */</div><div class="line">	<span class="keyword">volatile</span> ResolvableType targetType;</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field for caching the determined Class of a given bean definition</span></div><div class="line">	 * 缓存给定bean定义的确定类</div><div class="line">	 * */</div><div class="line">	<span class="keyword">volatile</span> Class&lt;?&gt; resolvedTargetType;</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field for caching the return type of a generically typed factory method</span></div><div class="line">	 * 缓存返回类型的一般类型的工厂方法</div><div class="line">	 * */</div><div class="line">	<span class="keyword">volatile</span> ResolvableType factoryMethodReturnType;</div><div class="line"></div><div class="line">	<span class="comment">/** Common lock for the four constructor fields below</span></div><div class="line">	 * 以下四个构造函数字段的通用锁</div><div class="line">	 * */</div><div class="line">	<span class="keyword">final</span> Object constructorArgumentLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field for caching the resolved constructor or factory method</span></div><div class="line">	 * 缓存已解决的构造函数或工厂方法</div><div class="line">	 * */</div><div class="line">	Executable resolvedConstructorOrFactoryMethod;</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field that marks the constructor arguments as resolved</span></div><div class="line">	 * 将构造函数的参数标记为已解决</div><div class="line">	 * */</div><div class="line">	<span class="keyword">boolean</span> constructorArgumentsResolved = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field for caching fully resolved constructor arguments</span></div><div class="line">	 * 缓存完全解析的构造函数参数</div><div class="line">	 * */</div><div class="line">	Object[] resolvedConstructorArguments;</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field for caching partly prepared constructor arguments</span></div><div class="line">	 * 缓存部分准备的构造函数参数</div><div class="line">	 * */</div><div class="line">	Object[] preparedConstructorArguments;</div><div class="line"></div><div class="line">	<span class="comment">/** Common lock for the two post-processing fields below</span></div><div class="line">	 * 以下两个后处理字段的通用锁</div><div class="line">	 * */</div><div class="line">	<span class="keyword">final</span> Object postProcessingLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field that indicates MergedBeanDefinitionPostProcessor having been applied</span></div><div class="line">	 * 表示已应用MergedBeanDefinitionPostProcessor</div><div class="line">	 * */</div><div class="line">	<span class="keyword">boolean</span> postProcessed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">/** Package-visible field that indicates a before-instantiation post-processor having kicked in</span></div><div class="line">	 * 表示已经一个实例化后处理器已经触发</div><div class="line">	 * */</div><div class="line">	<span class="keyword">volatile</span> Boolean beforeInstantiationResolved;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Set&lt;Member&gt; externallyManagedConfigMembers;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Set&lt;String&gt; externallyManagedInitMethods;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Set&lt;String&gt; externallyManagedDestroyMethods;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-5-RootBeanDefinition"><a href="#2-3-5-RootBeanDefinition" class="headerlink" title="2.3.5 RootBeanDefinition"></a>2.3.5 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/RootBeanDefinition.java" target="_blank" rel="external">RootBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 根bean定义代表融合的bean定义，运行时在Spring BeanFactory中备份特定bean的。</div><div class="line"> * 它可能已经从多个相互继承原始bean定义创建，通常以&#123;<span class="doctag">@link</span> GenericBeanDefinition GenericBeanDefinitions&#125;的形式进行创建。</div><div class="line"> * 根bean定义本质上是运行时的“统一”bean定义视图。</div><div class="line"> *</div><div class="line"> * 根bean定义也可用于在配置阶段注册各个bean定义。</div><div class="line"> * 但是，从Spring 2.5，以编程方式注册bean定义的首选方式是&#123;<span class="doctag">@link</span> GenericBeanDefinition&#125;类。</div><div class="line"> * GenericBeanDefinition 的优点是允许动态定义父依赖关系，而不是将角色“硬编码”为根bean定义。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootBeanDefinition</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinition</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> BeanDefinitionHolder decoratedDefinition;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定&#123;<span class="doctag">@link</span> AnnotatedElement&#125;定义限定符，而不是目标类或工厂方法。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> AnnotatedElement qualifiedElement;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> allowCaching = <span class="keyword">true</span>;</div><div class="line"></div><div class="line">	<span class="keyword">boolean</span> isFactoryMethodUnique = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果事先知道，请指定此bean定义的含有泛型的目标类型。</div><div class="line">	 */</div><div class="line">	<span class="keyword">volatile</span> ResolvableType targetType;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 缓存给定bean定义的确定类</div><div class="line">	 */</div><div class="line">	<span class="keyword">volatile</span> Class&lt;?&gt; resolvedTargetType;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 缓存返回类型的一般类型的工厂方法</div><div class="line">	 */</div><div class="line">	<span class="keyword">volatile</span> ResolvableType factoryMethodReturnType;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 以下四个构造函数字段的通用锁</div><div class="line">	 */</div><div class="line">	<span class="keyword">final</span> Object constructorArgumentLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 缓存已解析的构造函数或工厂方法</div><div class="line">	 */</div><div class="line">	Executable resolvedConstructorOrFactoryMethod;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将构造函数的参数标记为已解决</div><div class="line">	 */</div><div class="line">	<span class="keyword">boolean</span> constructorArgumentsResolved = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 缓存完全解析的构造函数参数</div><div class="line">	 */</div><div class="line">	Object[] resolvedConstructorArguments;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 缓存部分准备的构造函数参数</div><div class="line">	 */</div><div class="line">	Object[] preparedConstructorArguments;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 以下两个后处理字段的通用锁</div><div class="line">	 */</div><div class="line">	<span class="keyword">final</span> Object postProcessingLock = <span class="keyword">new</span> Object();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 表示已应用MergedBeanDefinitionPostProcessor</div><div class="line">	 */</div><div class="line">	<span class="keyword">boolean</span> postProcessed = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Package-visible field that indicates a before-instantiation post-processor having kicked in</div><div class="line">	 * 表示已经一个实例化后处理器已经触发</div><div class="line">	 */</div><div class="line">	<span class="keyword">volatile</span> Boolean beforeInstantiationResolved;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Set&lt;Member&gt; externallyManagedConfigMembers;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Set&lt;String&gt; externallyManagedInitMethods;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Set&lt;String&gt; externallyManagedDestroyMethods;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-6-GenericBeanDefinition"><a href="#2-3-6-GenericBeanDefinition" class="headerlink" title="2.3.6 GenericBeanDefinition"></a>2.3.6 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/GenericBeanDefinition.java" target="_blank" rel="external">GenericBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * GenericBeanDefinition is a one-stop shop for standard bean definition purposes.</div><div class="line"> * Like any bean definition, it allows for specifying a class plus optionally</div><div class="line"> * constructor argument values and property values. Additionally, deriving from a</div><div class="line"> * parent bean definition can be flexibly configured through the "parentName" property.</div><div class="line"> *</div><div class="line"> * &lt;p&gt;In general, use this &#123;<span class="doctag">@code</span> GenericBeanDefinition&#125; class for the purpose of</div><div class="line"> * registering user-visible bean definitions (which a post-processor might operate on,</div><div class="line"> * potentially even reconfiguring the parent name). Use &#123;<span class="doctag">@code</span> RootBeanDefinition&#125; /</div><div class="line"> * &#123;<span class="doctag">@code</span> ChildBeanDefinition&#125; where parent/child relationships happen to be pre-determined.</div><div class="line"> *</div><div class="line"> * GenericBeanDefinition是标准bean定义的一站式服务。</div><div class="line"> * 像任何bean定义一样，它允许指定一个类加上可选的构造函数参数值和属性值。</div><div class="line"> * 另外，可以通过“parentName”属性灵活地配置从父bean定义的派生。</div><div class="line"> *</div><div class="line"> * 一般来说，使用这个&#123;<span class="doctag">@code</span> GenericBeanDefinition&#125;类用于注册用户可见bean定义（后处理器可能操作bean定义，甚至可能重新配置父名称）。</div><div class="line"> * 使用&#123;<span class="doctag">@code</span> RootBeanDefinition&#125; / &#123;<span class="doctag">@code</span> ChildBeanDefinition&#125;，其中父/子关系恰好是预先确定的。</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> Juergen Hoeller</div><div class="line"> * <span class="doctag">@since</span> 2.5</div><div class="line"> * <span class="doctag">@see</span> #setParentName</div><div class="line"> * <span class="doctag">@see</span> RootBeanDefinition</div><div class="line"> * <span class="doctag">@see</span> ChildBeanDefinition</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinition</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String parentName;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-7-ChildBeanDefinition"><a href="#2-3-7-ChildBeanDefinition" class="headerlink" title="2.3.7 ChildBeanDefinition"></a>2.3.7 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/ChildBeanDefinition.java" target="_blank" rel="external">ChildBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 继承自父项设置的Bean的Bean定义。 子bean定义与父bean定义有固定的依赖关系。</div><div class="line"> *</div><div class="line"> * 子bean定义将从父级继承构造函数参数值，属性值和方法覆盖，并添加新值。</div><div class="line"> * 如果指定了init方法，destroy方法和/或静态工厂方法，它们将覆盖相应的父设置。</div><div class="line"> * 剩余的设置将始终从子定义中取出：depends on, autowire mode, dependency check, singleton, lazy init。</div><div class="line"> *</div><div class="line"> * 注意： 由于Spring 2.5，以编程方式注册bean定义的首选方式是&#123;<span class="doctag">@link</span> GenericBeanDefinition&#125;类，它允许通过&#123;<span class="doctag">@link</span> GenericBeanDefinition＃setParentName&#125;动态定义父依赖关系， 方法。</div><div class="line"> * 这有效地取代了大多数用例中的ChildBeanDefinition类。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildBeanDefinition</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinition</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> String parentName;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-8-ScannedGenericBeanDefinition"><a href="#2-3-8-ScannedGenericBeanDefinition" class="headerlink" title="2.3.8 ScannedGenericBeanDefinition"></a>2.3.8 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/ScannedGenericBeanDefinition.java" target="_blank" rel="external">ScannedGenericBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 扩展&#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.GenericBeanDefinition&#125;类，基于ASM ClassReader，支持通过&#123;<span class="doctag">@link</span> AnnotatedBeanDefinition&#125;接口暴露注释元数据。</div><div class="line"> * 此类不提早加载bean &#123;<span class="doctag">@code</span> Class&#125;。 它相当于从“.class”文件本身检索所有相关的元数据，并与ASM ClassReader解析。 它在功能上等同于&#123;<span class="doctag">@link</span> AnnotatedGenericBeanDefinition#AnnotatedGenericBeanDefinition(AnnotationMetadata)&#125;，但是区分已被扫描的类型bean与以其他方式注册或检测到的那些类型。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScannedGenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">implements</span> <span class="title">AnnotatedBeanDefinition</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata metadata;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-3-9-AnnotatedGenericBeanDefinition"><a href="#2-3-9-AnnotatedGenericBeanDefinition" class="headerlink" title="2.3.9 AnnotatedGenericBeanDefinition"></a>2.3.9 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/annotation/AnnotatedGenericBeanDefinition.java" target="_blank" rel="external">AnnotatedGenericBeanDefinition</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 扩展&#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.GenericBeanDefinition&#125;类，添加了通过&#123;<span class="doctag">@link</span> AnnotatedBeanDefinition&#125;接口暴露注释元数据的支持。</div><div class="line"> * </div><div class="line"> * 此GenericBeanDefinition变体主要用于测试期望在AnnotatedBeanDefinition上操作的代码，例如Spring组件扫描支持中的策略实现（默认定义类为&#123;<span class="doctag">@link</span> org.springframework.context.annotation.ScannedGenericBeanDefinition&#125; ，它还实现了AnnotatedBeanDefinition接口）。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedGenericBeanDefinition</span> <span class="keyword">extends</span> <span class="title">GenericBeanDefinition</span> <span class="keyword">implements</span> <span class="title">AnnotatedBeanDefinition</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotationMetadata metadata;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> MethodMetadata factoryMethodMetadata;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-BeanDefinitionReader"><a href="#3-BeanDefinitionReader" class="headerlink" title="3.BeanDefinitionReader"></a>3.BeanDefinitionReader</h2><h3 id="3-1-类图"><a href="#3-1-类图" class="headerlink" title="3.1 类图"></a>3.1 类图</h3><h3 id="3-2-接口"><a href="#3-2-接口" class="headerlink" title="3.2 接口"></a>3.2 接口</h3><h5 id="3-2-1-BeanDefinitionReader"><a href="#3-2-1-BeanDefinitionReader" class="headerlink" title="3.2.1 BeanDefinitionReader"></a>3.2.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/BeanDefinitionReader.java" target="_blank" rel="external">BeanDefinitionReader</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于bean定义阅读器的简单接口。</div><div class="line"> * 指定具有 Resource 和 String 位置参数的加载方法。</div><div class="line"> *</div><div class="line"> * 具体的bean定义读取器当然可以为bean定义添加额外的加载和注册方法，特定于它们的bean定义格式。</div><div class="line">  *</div><div class="line">   请注意，bean定义阅读器不必实现此接口。 它仅作为要遵循标准命名约定的bean定义阅读器的建议。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionReader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 返回bean工厂注册bean定义。</div><div class="line">     * 工厂通过BeanDefinitionRegistry接口暴露，封装了与bean定义处理相关的方法。</div><div class="line">	 */</div><div class="line">	<span class="function">BeanDefinitionRegistry <span class="title">getRegistry</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="function">ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 返回类加载器以用于bean类。</div><div class="line">     * &#123;<span class="doctag">@code</span> null&#125;建议不要热切地加载bean类，而是仅仅使用类名注册bean定义，相应的类将在稍后（或从不）解析。</div><div class="line">	 */</div><div class="line">	<span class="function">ClassLoader <span class="title">getBeanClassLoader</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 返回BeanNameGenerator用于匿名bean（未指定明确的bean名称）。</div><div class="line">	 */</div><div class="line">	<span class="function">BeanNameGenerator <span class="title">getBeanNameGenerator</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 从指定的资源中加载bean定义。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource... resources)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 从指定的资源位置加载bean定义。</div><div class="line">     * 该位置也可以是一个位置模式，前提是该bean定义阅读器的ResourceLoader是ResourcePatternResolver。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String location)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(String... locations)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-2-2-AbstractBeanDefinitionReader"><a href="#3-2-2-AbstractBeanDefinitionReader" class="headerlink" title="3.2.2 AbstractBeanDefinitionReader"></a>3.2.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/support/AbstractBeanDefinitionReader.java" target="_blank" rel="external">AbstractBeanDefinitionReader</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 实现&#123;<span class="doctag">@link</span> BeanDefinitionReader&#125;接口的bean定义阅读器的抽象基类。</div><div class="line"> * 提供常见的属性，如bean工厂工作，类加载器用于加载bean类。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBeanDefinitionReader</span> <span class="keyword">implements</span> <span class="title">EnvironmentCapable</span>, <span class="title">BeanDefinitionReader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/** Logger available to subclasses */</span></div><div class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> BeanDefinitionRegistry registry;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ResourceLoader resourceLoader;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ClassLoader beanClassLoader;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Environment environment;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> BeanNameGenerator beanNameGenerator = <span class="keyword">new</span> DefaultBeanNameGenerator();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于保存bean定义的注册表的接口，例如RootBeanDefinition和ChildBeanDefinition实例。 通常由BeanFactories实现，内部使用AbstractBeanDefinition层次结构。</div><div class="line"> * 这是Spring的bean工厂包中唯一封装Bean定义注册的接口。 标准BeanFactory接口仅涵盖对完全配置的工厂实例的访问。</div><div class="line"> * Spring的bean定义阅读器期望在此接口的实现上工作。 Spring内核中的已知实现者是DefaultListableBeanFactory和GenericApplicationContext。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionRegistry</span> <span class="keyword">extends</span> <span class="title">AliasRegistry</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 使用此注册表注册新的bean定义。</div><div class="line">	 * 必须支持RootBeanDefinition和ChildBeanDefinition。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinition</span><span class="params">(String beanName, BeanDefinition beanDefinition)</span> <span class="keyword">throws</span> BeanDefinitionStoreException</span>;</div><div class="line">	</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">	<span class="function">BeanDefinition <span class="title">getBeanDefinition</span><span class="params">(String beanName)</span> <span class="keyword">throws</span> NoSuchBeanDefinitionException</span>;</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsBeanDefinition</span><span class="params">(String beanName)</span></span>;</div><div class="line">	String[] getBeanDefinitionNames();</div><div class="line">	<span class="function"><span class="keyword">int</span> <span class="title">getBeanDefinitionCount</span><span class="params">()</span></span>;</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">isBeanNameInUse</span><span class="params">(String beanName)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-2-3-BeanDefinitionDocumentReader"><a href="#3-2-3-BeanDefinitionDocumentReader" class="headerlink" title="3.2.3 BeanDefinitionDocumentReader"></a>3.2.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/xml/BeanDefinitionDocumentReader.java" target="_blank" rel="external">BeanDefinitionDocumentReader</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * SPI用于解析包含Spring bean定义的XML文档。 由&#123;<span class="doctag">@link</span> XmlBeanDefinitionReader&#125;用于实际解析DOM文档。</div><div class="line"> *</div><div class="line"> * 为每个文档实例化来解析：在执行&#123;<span class="doctag">@code</span> registerBeanDefinitions&#125;方法时，实现可以在实例变量中保留状态; 例如，为文档中的所有bean定义定义的全局设置。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanDefinitionDocumentReader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 从给定的DOM文档中读取bean定义，并在给定的阅读器上下文中注册它们。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, XmlReaderContext readerContext)</span></span></div><div class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-3-实现"><a href="#3-3-实现" class="headerlink" title="3.3 实现"></a>3.3 实现</h3><h5 id="3-3-1-XmlBeanDefinitionReader"><a href="#3-3-1-XmlBeanDefinitionReader" class="headerlink" title="3.3.1 XmlBeanDefinitionReader"></a>3.3.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-beans/src/main/java/org/springframework/beans/factory/xml/XmlBeanDefinitionReader.java" target="_blank" rel="external">XmlBeanDefinitionReader</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div><div class="line">119</div><div class="line">120</div><div class="line">121</div><div class="line">122</div><div class="line">123</div><div class="line">124</div><div class="line">125</div><div class="line">126</div><div class="line">127</div><div class="line">128</div><div class="line">129</div><div class="line">130</div><div class="line">131</div><div class="line">132</div><div class="line">133</div><div class="line">134</div><div class="line">135</div><div class="line">136</div><div class="line">137</div><div class="line">138</div><div class="line">139</div><div class="line">140</div><div class="line">141</div><div class="line">142</div><div class="line">143</div><div class="line">144</div><div class="line">145</div><div class="line">146</div><div class="line">147</div><div class="line">148</div><div class="line">149</div><div class="line">150</div><div class="line">151</div><div class="line">152</div><div class="line">153</div><div class="line">154</div><div class="line">155</div><div class="line">156</div><div class="line">157</div><div class="line">158</div><div class="line">159</div><div class="line">160</div><div class="line">161</div><div class="line">162</div><div class="line">163</div><div class="line">164</div><div class="line">165</div><div class="line">166</div><div class="line">167</div><div class="line">168</div><div class="line">169</div><div class="line">170</div><div class="line">171</div><div class="line">172</div><div class="line">173</div><div class="line">174</div><div class="line">175</div><div class="line">176</div><div class="line">177</div><div class="line">178</div><div class="line">179</div><div class="line">180</div><div class="line">181</div><div class="line">182</div><div class="line">183</div><div class="line">184</div><div class="line">185</div><div class="line">186</div><div class="line">187</div><div class="line">188</div><div class="line">189</div><div class="line">190</div><div class="line">191</div><div class="line">192</div><div class="line">193</div><div class="line">194</div><div class="line">195</div><div class="line">196</div><div class="line">197</div><div class="line">198</div><div class="line">199</div><div class="line">200</div><div class="line">201</div><div class="line">202</div><div class="line">203</div><div class="line">204</div><div class="line">205</div><div class="line">206</div><div class="line">207</div><div class="line">208</div><div class="line">209</div><div class="line">210</div><div class="line">211</div><div class="line">212</div><div class="line">213</div><div class="line">214</div><div class="line">215</div><div class="line">216</div><div class="line">217</div><div class="line">218</div><div class="line">219</div><div class="line">220</div><div class="line">221</div><div class="line">222</div><div class="line">223</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于XML bean定义的Bean定义阅读器。</div><div class="line"> * 将实际的XML文档读取委托给&#123;<span class="doctag">@link</span> BeanDefinitionDocumentReader&#125;接口的实现。</div><div class="line"> *</div><div class="line"> * 通常应用于&#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.DefaultListableBeanFactory&#125;或&#123;<span class="doctag">@link</span> org.springframework.context.support.GenericApplicationContext&#125;。</div><div class="line"> *</div><div class="line"> * 此类加载DOM文档并将BeanDefinitionDocumentReader应用于该文档。 文档读取器将向给定的bean工厂注册每个bean定义，并与后者的&#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.BeanDefinitionRegistry&#125;接口的实现进行交互。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanDefinitionReader</span> <span class="keyword">extends</span> <span class="title">AbstractBeanDefinitionReader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_NONE = XmlValidationModeDetector.VALIDATION_NONE;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_AUTO = XmlValidationModeDetector.VALIDATION_AUTO;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_DTD = XmlValidationModeDetector.VALIDATION_DTD;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> VALIDATION_XSD = XmlValidationModeDetector.VALIDATION_XSD;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Constants instance for this class</div><div class="line">	 * 此类可用于解析其他类包含定义的 public static final 成员常量</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Constants constants = <span class="keyword">new</span> Constants(XmlBeanDefinitionReader.class);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">int</span> validationMode = VALIDATION_AUTO;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> namespaceAware = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 负责实际阅读XML bean定义文档的类。</div><div class="line">	 * 为每个文档实例化来解析</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> Class&lt;?&gt; documentReaderClass = DefaultBeanDefinitionDocumentReader.class;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 默认实现是&#123;<span class="doctag">@link</span> org.springframework.beans.factory.parsing.FailFastProblemReporter&#125;，表现出快速行为的失败。 外部工具可以提供一个替代实现，整理错误和警告以在工具UI中显示。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> ProblemReporter problemReporter = <span class="keyword">new</span> FailFastProblemReporter();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * EmptyReaderEventListener它丢弃每个事件通知。 外部工具可以提供一个替代实现来监视在BeanFactory中注册的组件。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> ReaderEventListener eventListener = <span class="keyword">new</span> EmptyReaderEventListener();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 默认实现是&#123;<span class="doctag">@link</span> NullSourceExtractor&#125;，它只返回&#123;<span class="doctag">@code</span> null&#125;作为源对象。 这意味着 - 在正常运行时执行期间 - 没有额外的源元数据附加到bean配置元数据。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> SourceExtractor sourceExtractor = <span class="keyword">new</span> NullSourceExtractor();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果没有指定，将通过 &#123;<span class="doctag">@link</span> #createDefaultNamespaceHandlerResolver()&#125; 创建一个 DefaultNamespaceHandlerResolver 默认实例。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> NamespaceHandlerResolver namespaceHandlerResolver;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 使用JAXP加载&#123;<span class="doctag">@link</span> Document&#125;实例的&#123;<span class="doctag">@link</span> DefaultDocumentLoader&#125;。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> DocumentLoader documentLoader = <span class="keyword">new</span> DefaultDocumentLoader();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 默认情况下，将使用&#123;<span class="doctag">@link</span> ResourceEntityResolver&#125;。 可以被自定义实体解析覆盖，例如相对于某些特定的基本路径。</div><div class="line">	 * 用于解决 xsd dtd 资源的网络加载问题</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> EntityResolver entityResolver;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * &#123;<span class="doctag">@code</span> org.xml.sax.ErrorHandler&#125;接口的实现，以便自定义处理XML解析错误和警告。</div><div class="line">	 * 如果未设置，则使用默认的SimpleSaxErrorHandler，它仅使用视图类的记录器实例记录警告，并重新创建错误以停止XML转换。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> ErrorHandler errorHandler = <span class="keyword">new</span> SimpleSaxErrorHandler(logger);</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 检测XML流是否使用基于DTD或XSD的验证。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> XmlValidationModeDetector validationModeDetector = <span class="keyword">new</span> XmlValidationModeDetector();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;Set&lt;EncodedResource&gt;&gt; resourcesCurrentlyBeingLoaded =</div><div class="line">			<span class="keyword">new</span> NamedThreadLocal&lt;&gt;(<span class="string">"XML bean definition resources currently being loaded"</span>);</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		<span class="keyword">return</span> loadBeanDefinitions(<span class="keyword">new</span> EncodedResource(resource));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(EncodedResource encodedResource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		Assert.notNull(encodedResource, <span class="string">"EncodedResource must not be null"</span>);</div><div class="line">		<span class="keyword">if</span> (logger.isInfoEnabled()) &#123;</div><div class="line">			logger.info(<span class="string">"Loading XML bean definitions from "</span> + encodedResource.getResource());</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		Set&lt;EncodedResource&gt; currentResources = <span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.get();</div><div class="line">		<span class="keyword">if</span> (currentResources == <span class="keyword">null</span>) &#123;</div><div class="line">			currentResources = <span class="keyword">new</span> HashSet&lt;&gt;(<span class="number">4</span>);</div><div class="line">			<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.set(currentResources);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">if</span> (!currentResources.add(encodedResource)) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">					<span class="string">"Detected cyclic loading of "</span> + encodedResource + <span class="string">" - check your import definitions!"</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			InputStream inputStream = encodedResource.getResource().getInputStream();</div><div class="line">			<span class="keyword">try</span> &#123;</div><div class="line">				InputSource inputSource = <span class="keyword">new</span> InputSource(inputStream);</div><div class="line">				<span class="keyword">if</span> (encodedResource.getEncoding() != <span class="keyword">null</span>) &#123;</div><div class="line">					inputSource.setEncoding(encodedResource.getEncoding());</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, encodedResource.getResource());</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">finally</span> &#123;</div><div class="line">				inputStream.close();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(</div><div class="line">					<span class="string">"IOException parsing XML document from "</span> + encodedResource.getResource(), ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">			currentResources.remove(encodedResource);</div><div class="line">			<span class="keyword">if</span> (currentResources.isEmpty()) &#123;</div><div class="line">				<span class="keyword">this</span>.resourcesCurrentlyBeingLoaded.remove();</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(InputSource inputSource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		<span class="keyword">return</span> loadBeanDefinitions(inputSource, <span class="string">"resource loaded through SAX InputSource"</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadBeanDefinitions</span><span class="params">(InputSource inputSource, String resourceDescription)</span></span></div><div class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line">		<span class="keyword">return</span> doLoadBeanDefinitions(inputSource, <span class="keyword">new</span> DescriptiveResource(resourceDescription));</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Actually load bean definitions from the specified XML file.</div><div class="line">	 * <span class="doctag">@param</span> inputSource the SAX InputSource to read from</div><div class="line">	 * <span class="doctag">@param</span> resource the resource descriptor for the XML file</div><div class="line">	 * <span class="doctag">@return</span> the number of bean definitions found</div><div class="line">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of loading or parsing errors</div><div class="line">	 * <span class="doctag">@see</span> #doLoadDocument</div><div class="line">	 * <span class="doctag">@see</span> #registerBeanDefinitions</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doLoadBeanDefinitions</span><span class="params">(InputSource inputSource, Resource resource)</span></span></div><div class="line">			<span class="keyword">throws</span> BeanDefinitionStoreException &#123;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			Document doc = doLoadDocument(inputSource, resource);</div><div class="line">			<span class="keyword">return</span> registerBeanDefinitions(doc, resource);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (BeanDefinitionStoreException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> ex;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (SAXParseException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					<span class="string">"Line "</span> + ex.getLineNumber() + <span class="string">" in XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (SAXException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> XmlBeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					<span class="string">"XML document from "</span> + resource + <span class="string">" is invalid"</span>, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (ParserConfigurationException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					<span class="string">"Parser configuration exception parsing XML from "</span> + resource, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					<span class="string">"IOException parsing XML document from "</span> + resource, ex);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> BeanDefinitionStoreException(resource.getDescription(),</div><div class="line">					<span class="string">"Unexpected exception parsing XML document from "</span> + resource, ex);</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Actually load the specified document using the configured DocumentLoader.</div><div class="line">	 * 实际上使用配置的DocumentLoader加载指定的文档</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> Document <span class="title">doLoadDocument</span><span class="params">(InputSource inputSource, Resource resource)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>.documentLoader.loadDocument(inputSource, getEntityResolver(), <span class="keyword">this</span>.errorHandler,</div><div class="line">				getValidationModeForResource(resource), isNamespaceAware());</div><div class="line">	&#125;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Register the bean definitions contained in the given DOM document.</div><div class="line">	 * Called by &#123;<span class="doctag">@code</span> loadBeanDefinitions&#125;.</div><div class="line">	 * &lt;p&gt;Creates a new instance of the parser class and invokes</div><div class="line">	 * &#123;<span class="doctag">@code</span> registerBeanDefinitions&#125; on it.</div><div class="line">	 *</div><div class="line">	 * 注册给定的DOM文档中包含的bean定义。 由&#123;<span class="doctag">@code</span> loadBeanDefinitions&#125;调用。</div><div class="line">	 * 创建解析器类的新实例，并调用&#123;<span class="doctag">@code</span> registerBeanDefinitions&#125;。</div><div class="line">	 *</div><div class="line">	 * <span class="doctag">@param</span> doc the DOM document</div><div class="line">	 * <span class="doctag">@param</span> resource the resource descriptor (for context information)</div><div class="line">	 * <span class="doctag">@return</span> the number of bean definitions found</div><div class="line">	 * <span class="doctag">@throws</span> BeanDefinitionStoreException in case of parsing errors</div><div class="line">	 * <span class="doctag">@see</span> #loadBeanDefinitions</div><div class="line">	 * <span class="doctag">@see</span> #setDocumentReaderClass</div><div class="line">	 * <span class="doctag">@see</span> BeanDefinitionDocumentReader#registerBeanDefinitions</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">registerBeanDefinitions</span><span class="params">(Document doc, Resource resource)</span> <span class="keyword">throws</span> BeanDefinitionStoreException </span>&#123;</div><div class="line">		BeanDefinitionDocumentReader documentReader = createBeanDefinitionDocumentReader();</div><div class="line">		<span class="keyword">int</span> countBefore = getRegistry().getBeanDefinitionCount();</div><div class="line">		documentReader.registerBeanDefinitions(doc, createReaderContext(resource));</div><div class="line">		<span class="keyword">return</span> getRegistry().getBeanDefinitionCount() - countBefore;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Create the &#123;<span class="doctag">@link</span> BeanDefinitionDocumentReader&#125; to use for actually</div><div class="line">	 * reading bean definitions from an XML document.</div><div class="line">	 * &lt;p&gt;The default implementation instantiates the specified "documentReaderClass".</div><div class="line">	 * <span class="doctag">@see</span> #setDocumentReaderClass</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> BeanDefinitionDocumentReader <span class="title">createBeanDefinitionDocumentReader</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> BeanDefinitionDocumentReader.class.cast(BeanUtils.instantiateClass(<span class="keyword">this</span>.documentReaderClass));</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Create the &#123;<span class="doctag">@link</span> XmlReaderContext&#125; to pass over to the document reader.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> XmlReaderContext <span class="title">createReaderContext</span><span class="params">(Resource resource)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> XmlReaderContext(resource, <span class="keyword">this</span>.problemReporter, <span class="keyword">this</span>.eventListener,</div><div class="line">				<span class="keyword">this</span>.sourceExtractor, <span class="keyword">this</span>, getNamespaceHandlerResolver());</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-3-2-DefaultBeanDefinitionDocumentReader"><a href="#3-3-2-DefaultBeanDefinitionDocumentReader" class="headerlink" title="3.3.2 DefaultBeanDefinitionDocumentReader"></a>3.3.2 <a href="">DefaultBeanDefinitionDocumentReader</a></h5>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1. 概述&quot;&gt;&lt;/a&gt;1. 概述&lt;/h2&gt;&lt;p&gt;BeanFactory为Spring的IoC功能提供了基础，但它直接用于与其他第三方框架的集成，现在大部分Spring用
    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码解析 4.环境与属性解析</title>
    <link href="http://leerenbo.cn/2017/05/18/spring-code-propertyresolver/"/>
    <id>http://leerenbo.cn/2017/05/18/spring-code-propertyresolver/</id>
    <published>2017-05-18T02:26:12.000Z</published>
    <updated>2017-05-22T03:14:58.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Environment 是集成在容器中的抽象，用于模拟应用程序环境的两个关键方面：配置文件和属性。</p>
<p>只有给定的配置文件处于活动状态，配置文件才是要向容器注册的一个命名逻辑组的bean定义。 Bean 可以被分配到不管是以XML定义还是通过注释的配置文件。 环境对象与配置文件的关系在于确定哪些配置文件（如果有）当前处于活动状态，哪些配置文件（如果有的话）默认情况下应该处于活动状态。</p>
<p>属性在几乎所有应用程序中起着重要作用，可能来自各种来源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc属性对象，Maps等。 环境对象与属性关系的作用是为用户提供方便的服务接口，用于配置属性源并从中解析属性。</p>
<h2 id="2-PropertyResolver"><a href="#2-PropertyResolver" class="headerlink" title="2. PropertyResolver"></a>2. PropertyResolver</h2><p><img src="/assets/img/spring/springEnvPropertyResolver.png" alt="右侧部分"></p>
<h3 id="2-1-属性解析接口"><a href="#2-1-属性解析接口" class="headerlink" title="2.1 属性解析接口"></a>2.1 属性解析接口</h3><h5 id="2-1-1-PropertyResolver"><a href="#2-1-1-PropertyResolver" class="headerlink" title="2.1.1 PropertyResolver"></a>2.1.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/PropertyResolver.java" target="_blank" rel="external">PropertyResolver</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于解析任何基础源的属性的接口。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertyResolver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回给定的属性键是否可用于解析，即如果给定键的值不是&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">containsProperty</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回与给定 key 相关联的属性值，如果 key 无法解析，则返回&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getProperty</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回与给定键相关联的属性值，如果键无法解析，则返回&#123;<span class="doctag">@code</span> defaultValue&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getProperty</span><span class="params">(String key, String defaultValue)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回与给定键相关联的属性值，如果键无法解析，则返回&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回与给定键相关联的属性值，如果键无法解析，则返回&#123;<span class="doctag">@code</span> defaultValue&#125;。</div><div class="line">	 */</div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">getProperty</span><span class="params">(String key, Class&lt;T&gt; targetType, T defaultValue)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回与给定键相关联的属性值（从不&#123;<span class="doctag">@code</span> null&#125;）。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getRequiredProperty</span><span class="params">(String key)</span> <span class="keyword">throws</span> IllegalStateException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回与给定键相关联的属性值，转换为给定的targetType（从不&#123;<span class="doctag">@code</span> null&#125;）。</div><div class="line">	 */</div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">getRequiredProperty</span><span class="params">(String key, Class&lt;T&gt; targetType)</span> <span class="keyword">throws</span> IllegalStateException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 解析给定文本中的 $&#123;...&#125; 占位符，用&#123;<span class="doctag">@link</span> #getProperty&#125;解析的相应属性值替换它们。</div><div class="line">	 * 没有默认值的未解决的占位符将被忽略并通过不变。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">resolvePlaceholders</span><span class="params">(String text)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 解析给定文本中的 $&#123;...&#125; 占位符，用&#123;<span class="doctag">@link</span> #getProperty&#125;解析的相应属性值替换它们。没有默认值的不可解决的占位符将导致抛出IllegalArgumentException。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">resolveRequiredPlaceholders</span><span class="params">(String text)</span> <span class="keyword">throws</span> IllegalArgumentException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-1-2ConfigurablePropertyResolver"><a href="#2-1-2ConfigurablePropertyResolver" class="headerlink" title="2.1.2ConfigurablePropertyResolver"></a>2.1.2<a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/ConfigurablePropertyResolver.java" target="_blank" rel="external">ConfigurablePropertyResolver</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置接口大多数（如果不是全部）由 &#123;<span class="doctag">@link</span> PropertyResolver&#125; 类型实现。</div><div class="line"> * 提供访问和自定义将属性值从一种类型转换为另一种时使用的&#123;<span class="doctag">@link</span> org.springframework.core.convert.ConversionService ConversionService&#125;的功能。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurablePropertyResolver</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回在属性上执行类型转换时使用的&#123;<span class="doctag">@link</span> ConfigurableConversionService&#125;。</div><div class="line">	 * 返回的转换服务的可配置性质允许方便地添加和删除单个&#123;<span class="doctag">@code</span> Converter&#125;实例：</div><div class="line">	 *</div><div class="line">	 * ConfigurableConversionService cs = env.getConversionService();</div><div class="line">	 * cs.addConverter(new FooConverter());</div><div class="line">	 */</div><div class="line">	<span class="function">ConfigurableConversionService <span class="title">getConversionService</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置在属性上执行类型转换时使用的&#123;<span class="doctag">@link</span> ConfigurableConversionService&#125;。</div><div class="line">	 * 注意：与其完全替换&#123;<span class="doctag">@code</span> ConversionService&#125;的替代方法，不如考虑通过获取 &#123;<span class="doctag">@link</span> #getConversionService()&#125; ，并调用方法，如&#123;<span class="doctag">@code</span> #addConverter&#125;，添加或删除单个 &#123;<span class="doctag">@code</span> Converter&#125; 实例。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setConversionService</span><span class="params">(ConfigurableConversionService conversionService)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置由此解析器替换的占位符的前缀必须以它开头。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setPlaceholderPrefix</span><span class="params">(String placeholderPrefix)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置此解析器替换的占位符的后缀必须以其结尾。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setPlaceholderSuffix</span><span class="params">(String placeholderSuffix)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定由此解析器替换的占位符与其关联的默认值之间的分隔符，或者，如果没有此类特殊字符作为值分隔符处理，则为&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setValueSeparator</span><span class="params">(String valueSeparator)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 设置是否在遇到嵌套在给定属性的值中的未解析占位符时抛出异常。 &#123;<span class="doctag">@code</span> false&#125;值表示严格的不，即将抛出异常。 &#123;<span class="doctag">@code</span> true&#125;值表示无法解析的嵌套占位符应以未解析的 $&#123;...&#125; 形式传递。</div><div class="line">	 * &#123;<span class="doctag">@link</span> #getProperty(String)&#125; 及其变体的实现必须检查此处设置的值，以在属性值包含不可解析占位符时确定正确的行为。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setIgnoreUnresolvableNestedPlaceholders</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvableNestedPlaceholders)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指定哪些属性必须存在，由 &#123;<span class="doctag">@link</span> #validateRequiredProperties()&#125; 验证。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setRequiredProperties</span><span class="params">(String... requiredProperties)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 验证 &#123;<span class="doctag">@link</span> #setRequiredProperties&#125; 指定的每个属性是否存在，并解析为 非&#123;<span class="doctag">@code</span> null&#125; 值。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">validateRequiredProperties</span><span class="params">()</span> <span class="keyword">throws</span> MissingRequiredPropertiesException</span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-属性解析实现与抽象类"><a href="#2-2-属性解析实现与抽象类" class="headerlink" title="2.2 属性解析实现与抽象类"></a>2.2 属性解析实现与抽象类</h3><h5 id="2-2-1-PropertyPlaceholderHelper"><a href="#2-2-1-PropertyPlaceholderHelper" class="headerlink" title="2.2.1 PropertyPlaceholderHelper"></a>2.2.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/util/PropertyPlaceholderHelper.java" target="_blank" rel="external">PropertyPlaceholderHelper</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 使用具有占位符值的Strings的实用程序类。 占位符采用 &#123;<span class="doctag">@code</span> $&#123;name&#125;&#125; 的形式。 使用 &#123;<span class="doctag">@code</span> PropertyPlaceholderHelper&#125; 这些占位符可以替代用户提供的值。</div><div class="line"> * 可以使用 &#123;<span class="doctag">@link</span> Properties&#125; 实例或使用 &#123;<span class="doctag">@link</span> PlaceholderResolver&#125; 提供替换值。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertyPlaceholderHelper</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(PropertyPlaceholderHelper.class);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, String&gt; wellKnownSimplePrefixes = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">4</span>);</div><div class="line"></div><div class="line">	<span class="keyword">static</span> &#123;</div><div class="line">		wellKnownSimplePrefixes.put(<span class="string">"&#125;"</span>, <span class="string">"&#123;"</span>);</div><div class="line">		wellKnownSimplePrefixes.put(<span class="string">"]"</span>, <span class="string">"["</span>);</div><div class="line">		wellKnownSimplePrefixes.put(<span class="string">")"</span>, <span class="string">"("</span>);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String placeholderPrefix;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String placeholderSuffix;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String simplePrefix;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String valueSeparator;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> ignoreUnresolvablePlaceholders;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">replacePlaceholders</span><span class="params">(String value, PlaceholderResolver placeholderResolver)</span> </span>&#123;</div><div class="line">		Assert.notNull(value, <span class="string">"'value' must not be null"</span>);</div><div class="line">		<span class="keyword">return</span> parseStringValue(value, placeholderResolver, <span class="keyword">new</span> HashSet&lt;&gt;());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">protected</span> String <span class="title">parseStringValue</span><span class="params">(</span></span></div><div class="line">			String value, PlaceholderResolver placeholderResolver, Set&lt;String&gt; visitedPlaceholders) &#123;</div><div class="line"></div><div class="line">		StringBuilder result = <span class="keyword">new</span> StringBuilder(value);</div><div class="line"></div><div class="line">		<span class="keyword">int</span> startIndex = value.indexOf(<span class="keyword">this</span>.placeholderPrefix);</div><div class="line">		<span class="keyword">while</span> (startIndex != -<span class="number">1</span>) &#123;</div><div class="line">			<span class="keyword">int</span> endIndex = findPlaceholderEndIndex(result, startIndex);</div><div class="line">			<span class="keyword">if</span> (endIndex != -<span class="number">1</span>) &#123;</div><div class="line">				String placeholder = result.substring(startIndex + <span class="keyword">this</span>.placeholderPrefix.length(), endIndex);</div><div class="line">				String originalPlaceholder = placeholder;</div><div class="line">				<span class="keyword">if</span> (!visitedPlaceholders.add(originalPlaceholder)) &#123;</div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</div><div class="line">							<span class="string">"Circular placeholder reference '"</span> + originalPlaceholder + <span class="string">"' in property definitions"</span>);</div><div class="line">				&#125;</div><div class="line">				<span class="comment">// Recursive invocation, parsing placeholders contained in the placeholder key.</span></div><div class="line">				<span class="comment">// 递归调用，解析包含在占位符键中的占位符。</span></div><div class="line">				placeholder = parseStringValue(placeholder, placeholderResolver, visitedPlaceholders);</div><div class="line">				<span class="comment">// Now obtain the value for the fully resolved key...</span></div><div class="line">				<span class="comment">// 现在获取完全解析key的值...</span></div><div class="line">				String propVal = placeholderResolver.resolvePlaceholder(placeholder);</div><div class="line">				<span class="keyword">if</span> (propVal == <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.valueSeparator != <span class="keyword">null</span>) &#123;</div><div class="line">					<span class="keyword">int</span> separatorIndex = placeholder.indexOf(<span class="keyword">this</span>.valueSeparator);</div><div class="line">					<span class="keyword">if</span> (separatorIndex != -<span class="number">1</span>) &#123;</div><div class="line">						String actualPlaceholder = placeholder.substring(<span class="number">0</span>, separatorIndex);</div><div class="line">						String defaultValue = placeholder.substring(separatorIndex + <span class="keyword">this</span>.valueSeparator.length());</div><div class="line">						propVal = placeholderResolver.resolvePlaceholder(actualPlaceholder);</div><div class="line">						<span class="keyword">if</span> (propVal == <span class="keyword">null</span>) &#123;</div><div class="line">							propVal = defaultValue;</div><div class="line">						&#125;</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">if</span> (propVal != <span class="keyword">null</span>) &#123;</div><div class="line">					<span class="comment">// Recursive invocation, parsing placeholders contained in the</span></div><div class="line">					<span class="comment">// previously resolved placeholder value.</span></div><div class="line">					<span class="comment">// 递归调用，解析先前解析的占位符值中包含的占位符。</span></div><div class="line">					propVal = parseStringValue(propVal, placeholderResolver, visitedPlaceholders);</div><div class="line">					result.replace(startIndex, endIndex + <span class="keyword">this</span>.placeholderSuffix.length(), propVal);</div><div class="line">					<span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</div><div class="line">						logger.trace(<span class="string">"Resolved placeholder '"</span> + placeholder + <span class="string">"'"</span>);</div><div class="line">					&#125;</div><div class="line">					startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, startIndex + propVal.length());</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.ignoreUnresolvablePlaceholders) &#123;</div><div class="line">					<span class="comment">// Proceed with unprocessed value.</span></div><div class="line">					<span class="comment">// 继续处理未处理的值。</span></div><div class="line">					startIndex = result.indexOf(<span class="keyword">this</span>.placeholderPrefix, endIndex + <span class="keyword">this</span>.placeholderSuffix.length());</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					<span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Could not resolve placeholder '"</span> +</div><div class="line">							placeholder + <span class="string">"'"</span> + <span class="string">" in value \""</span> + value + <span class="string">"\""</span>);</div><div class="line">				&#125;</div><div class="line">				visitedPlaceholders.remove(originalPlaceholder);</div><div class="line">			&#125;</div><div class="line">			<span class="keyword">else</span> &#123;</div><div class="line">				startIndex = -<span class="number">1</span>;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">return</span> result.toString();</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 用于解决字符串中包含的占位符替换值的策略界面。</div><div class="line">	 */</div><div class="line">	<span class="meta">@FunctionalInterface</span></div><div class="line">	<span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlaceholderResolver</span> </span>&#123;</div><div class="line"></div><div class="line">		<span class="comment">/**</span></div><div class="line">		 * 将提供的占位符名称解析为替换值。</div><div class="line">		 */</div><div class="line">		<span class="function">String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span></span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-2-AbstractPropertyResolver"><a href="#2-2-2-AbstractPropertyResolver" class="headerlink" title="2.2.2 AbstractPropertyResolver"></a>2.2.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/AbstractPropertyResolver.java" target="_blank" rel="external">AbstractPropertyResolver</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于解析任何基础源的属性的抽象基类。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractPropertyResolver</span> <span class="keyword">implements</span> <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(getClass());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> ConfigurableConversionService conversionService;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> PropertyPlaceholderHelper nonStrictHelper;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> PropertyPlaceholderHelper strictHelper;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> ignoreUnresolvableNestedPlaceholders = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String placeholderPrefix = SystemPropertyUtils.PLACEHOLDER_PREFIX;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String placeholderSuffix = SystemPropertyUtils.PLACEHOLDER_SUFFIX;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> String valueSeparator = SystemPropertyUtils.VALUE_SEPARATOR;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; requiredProperties = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line"></div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholders</span><span class="params">(String text)</span> </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.nonStrictHelper == <span class="keyword">null</span>) &#123;</div><div class="line">			<span class="keyword">this</span>.nonStrictHelper = createPlaceholderHelper(<span class="keyword">true</span>);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> doResolvePlaceholders(text, <span class="keyword">this</span>.nonStrictHelper);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> PropertyPlaceholderHelper <span class="title">createPlaceholderHelper</span><span class="params">(<span class="keyword">boolean</span> ignoreUnresolvablePlaceholders)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> PropertyPlaceholderHelper(<span class="keyword">this</span>.placeholderPrefix, <span class="keyword">this</span>.placeholderSuffix,</div><div class="line">				<span class="keyword">this</span>.valueSeparator, ignoreUnresolvablePlaceholders);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">private</span> String <span class="title">doResolvePlaceholders</span><span class="params">(String text, PropertyPlaceholderHelper helper)</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> helper.replacePlaceholders(text, <span class="keyword">new</span> PropertyPlaceholderHelper.PlaceholderResolver() &#123;</div><div class="line">			<span class="meta">@Override</span></div><div class="line">			<span class="function"><span class="keyword">public</span> String <span class="title">resolvePlaceholder</span><span class="params">(String placeholderName)</span> </span>&#123;</div><div class="line">				<span class="keyword">return</span> getPropertyAsRawString(placeholderName);</div><div class="line">			&#125;</div><div class="line">		&#125;);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Retrieve the specified property as a raw String,</div><div class="line">	 * i.e. without resolution of nested placeholders.</div><div class="line">	 * <span class="doctag">@param</span> key the property name to resolve</div><div class="line">	 * <span class="doctag">@return</span> the property value or &#123;<span class="doctag">@code</span> null&#125; if none found</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> String <span class="title">getPropertyAsRawString</span><span class="params">(String key)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-3-PropertySourcesPropertyResolver"><a href="#2-2-3-PropertySourcesPropertyResolver" class="headerlink" title="2.2.3 PropertySourcesPropertyResolver"></a>2.2.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/PropertySourcesPropertyResolver.java" target="_blank" rel="external">PropertySourcesPropertyResolver</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> PropertyResolver&#125; 实现，它根据&#123;<span class="doctag">@link</span> PropertySources&#125;的底层解析属性值。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySourcesPropertyResolver</span> <span class="keyword">extends</span> <span class="title">AbstractPropertyResolver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> PropertySougggtirces propertySources;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="3-PropertySource"><a href="#3-PropertySource" class="headerlink" title="3. PropertySource"></a>3. PropertySource</h2><h3 id="3-1-PropertySource抽象与实现"><a href="#3-1-PropertySource抽象与实现" class="headerlink" title="3.1 PropertySource抽象与实现"></a>3.1 PropertySource抽象与实现</h3><h5 id="3-1-1-PropertySource"><a href="#3-1-1-PropertySource" class="headerlink" title="3.1.1 PropertySource"></a>3.1.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/PropertySource.java" target="_blank" rel="external">PropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 表示 name/value 属性对的来源的抽象基类。底层的 &#123;<span class="doctag">@linkplain</span> #getSource（）source object&#125; 可以任何 &#123;<span class="doctag">@code</span> T&#125; 类型的封装属性。示例包括 &#123;<span class="doctag">@link</span> java.util.Properties&#125; 对象，&#123;<span class="doctag">@link</span> java.util.Map&#125;对象，&#123;<span class="doctag">@code</span> ServletContext&#125; 和 &#123;<span class="doctag">@code</span> ServletConfig&#125; 对象（用于访问init参数）。浏览 &#123;<span class="doctag">@code</span> PropertySource&#125; 类型层次结构以查看提供的实现。</div><div class="line"> *</div><div class="line"> * 通常不会孤立地使用 &#123;<span class="doctag">@code</span> PropertySources&#125; 对象，而是通过 &#123;<span class="doctag">@link</span> PropertySources&#125; 对象来集成属性源，并结合使用 &#123;<span class="doctag">@link</span> PropertyResolver&#125; 。实现跨越 &#123;<span class="doctag">@code</span> PropertySources&#125; 集合的基于优先级搜索。</div><div class="line"> *</div><div class="line"> * &#123;<span class="doctag">@code</span> PropertySource&#125; 标识不是基于封装属性的内容而是基于 &#123;<span class="doctag">@code</span> PropertySource&#125; 的 &#123;<span class="doctag">@link</span> #getName() name&#125;。这对于在集合上下文中操作 &#123;<span class="doctag">@code</span> PropertySource&#125; 对象很有用。有关详细信息，请参阅 &#123;<span class="doctag">@link</span> MutablePropertySources&#125; 中的操作以及 &#123;<span class="doctag">@link</span> #named(String)&#125; 和 &#123;<span class="doctag">@link</span> #toString()&#125; 方法。</div><div class="line"> *</div><div class="line"> * 请注意，使用 @&#123;<span class="doctag">@link</span></div><div class="line"> * org.springframework.context.annotation.Configuration Configuration&#125; 类时，@&#123;<span class="doctag">@link</span> org.springframework.context.annotation.PropertySource PropertySource&#125; 注释提供了一种方便和声明性的方式向封闭的 &#123;<span class="doctag">@code</span> Environment&#125; 添加属性源。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertySource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> String name;</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">final</span> T source;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-2-EnumerablePropertySource"><a href="#3-1-2-EnumerablePropertySource" class="headerlink" title="3.1.2 EnumerablePropertySource"></a>3.1.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/EnumerablePropertySource.java" target="_blank" rel="external">EnumerablePropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 可询问其底层源对象，来枚举所有可能的属性 name/value对 的&#123;<span class="doctag">@link</span> PropertySource&#125;抽象类。暴露 &#123;<span class="doctag">@link</span> #getPropertyNames()&#125; 方法，以允许调用者内省自己的可用属性，而不必访问底层的源对象。这也有助于更有效地实现 &#123;<span class="doctag">@link</span> #containsProperty(String)&#125;，因为它可以调用 &#123;<span class="doctag">@link</span> #getPropertyNames()&#125; 并遍历返回的数组，而不是尝试调用  &#123;<span class="doctag">@link</span> #getProperty(String)&#125;，这可能更昂贵。实现可能会考虑缓存 &#123;<span class="doctag">@link</span> #getPropertyNames()&#125; 的结果，以充分利用此性能机会。</div><div class="line"> *</div><div class="line"> * 大多数框架提供的&#123;<span class="doctag">@code</span> PropertySource&#125;实现是可枚举的;一个反例是&#123;<span class="doctag">@code</span> JndiPropertySource&#125;，由于JNDI的性质，在任何给定时间都不可能确定所有可能的属性名称;而只能尝试访问一个属性（通过&#123;<span class="doctag">@link</span> #getProperty（String）&#125;）来评估它是否存在。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">EnumerablePropertySource</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">PropertySource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> String[] getPropertyNames();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-3-MapPropertySource"><a href="#3-1-3-MapPropertySource" class="headerlink" title="3.1.3 MapPropertySource"></a>3.1.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/MapPropertySource.java" target="_blank" rel="external">MapPropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> PropertySource&#125;从&#123;<span class="doctag">@code</span> Map&#125;对象读取 keys 和 values 。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapPropertySource</span> <span class="keyword">extends</span> <span class="title">EnumerablePropertySource</span>&lt;<span class="title">Map</span>&lt;<span class="title">String</span>, <span class="title">Object</span>&gt;&gt; </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-4-SystemEnvironmentPropertySource"><a href="#3-1-4-SystemEnvironmentPropertySource" class="headerlink" title="3.1.4 SystemEnvironmentPropertySource"></a>3.1.4 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/SystemEnvironmentPropertySource.java" target="_blank" rel="external">SystemEnvironmentPropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 专为 &#123;<span class="doctag">@linkplain</span> AbstractEnvironment#getSystemEnvironment() system environment variables&#125; 使用而设计的特殊&#123;<span class="doctag">@link</span> MapPropertySource&#125; 。补偿Bash和其他shell中的约束，不允许包含句点字符和/或连字符的变量;同样允许shell更常用的使用的大写属性名称变体。</div><div class="line"> *</div><div class="line"> * 例如，调用 &#123;<span class="doctag">@code</span> getProperty("foo.bar")&#125; 将尝试找到原始属性或任何“等效”属性的值，返回首次找到的值：</div><div class="line"> * &#123;<span class="doctag">@code</span> foo.bar&#125; - 原始名称</div><div class="line"> * &#123;<span class="doctag">@code</span> foo_bar&#125; - 句点转下划线（如果有）</div><div class="line"> * &#123;<span class="doctag">@code</span> FOO.BAR&#125; - 原件，大写</div><div class="line"> * &#123;<span class="doctag">@code</span> FOO_BAR&#125; - 带下划线和大写</div><div class="line"> * 上述任何连字符变体也可以工作，甚至混合点/连字符变体。</div><div class="line"> *</div><div class="line"> * 同样适用于 &#123;<span class="doctag">@link</span> #containsProperty(String)&#125; 的调用，如果存在任何上述属性，则返回&#123;<span class="doctag">@code</span> true&#125;，否则&#123;<span class="doctag">@code</span> false&#125;。</div><div class="line"> *</div><div class="line"> * 将活动或默认配置文件指定为环境变量时，此功能特别有用。 Bash下是不允许的：</div><div class="line"> * spring.profiles.active=p1 java -classpath ... MyApp</div><div class="line"> *</div><div class="line"> * 但是，以下语法是允许的，也是更常规的：</div><div class="line"> * SPRING_PROFILES_ACTIVE=p1 java -classpath ... MyApp</div><div class="line"> *</div><div class="line"> * 为此类（或包）启用调试或跟踪级别日志记录，以解释何时发生这些“属性名称解析”。</div><div class="line"> *</div><div class="line"> * 此属性源默认包含在 &#123;<span class="doctag">@link</span> StandardEnvironment&#125; 及其所有子类中。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemEnvironmentPropertySource</span> <span class="keyword">extends</span> <span class="title">MapPropertySource</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-5-PropertiesPropertySource"><a href="#3-1-5-PropertiesPropertySource" class="headerlink" title="3.1.5 PropertiesPropertySource"></a>3.1.5 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/PropertiesPropertySource.java" target="_blank" rel="external">PropertiesPropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> PropertySource&#125; 实现，从 &#123;<span class="doctag">@link</span> java.util.Properties&#125; 对象中提取属性。</div><div class="line"> * 请注意，由于 &#123;<span class="doctag">@code</span> Properties&#125; 对象在技术上是 &#123;<span class="doctag">@code</span> &lt;Object，Object&gt;&#125; &#123;<span class="doctag">@link</span> java.util.Hashtable Hashtable&#125;，可能包含非&#123;<span class="doctag">@code</span> String&#125;键或值。 然而，这种实现仅限于访问 &#123;<span class="doctag">@code</span> String&#125; 的键和值，与&#123;<span class="doctag">@link</span> Properties＃getProperty&#125;和&#123;<span class="doctag">@link</span> Properties＃setProperty&#125;的方式相同。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesPropertySource</span> <span class="keyword">extends</span> <span class="title">MapPropertySource</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-6-CommandLinePropertySource"><a href="#3-1-6-CommandLinePropertySource" class="headerlink" title="3.1.6 CommandLinePropertySource"></a>3.1.6 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/CommandLinePropertySource.java" target="_blank" rel="external">CommandLinePropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 由命令行参数支持的&#123;<span class="doctag">@link</span> PropertySource&#125;实现的抽象基类。 参数化类型&#123;<span class="doctag">@code</span> T&#125;表示命令行选项的基础源。 在&#123;<span class="doctag">@link</span> SimpleCommandLinePropertySource&#125;的情况下，这可能与String数组一样简单，或者在&#123;<span class="doctag">@link</span> JOptCommandLinePropertySource&#125;的情况下特定于特定的API，例如JOpt的&#123;<span class="doctag">@code</span> OptionSet&#125;。</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * 目的和一般用法</div><div class="line"> * 用于独立的基于Spring的应用程序，即通过传统&#123;<span class="doctag">@code</span> main&#125;方法从命令行接受参数的 &#123;<span class="doctag">@code</span> String[]&#125; 引导的应用程序。 在许多情况下，直接在&#123;<span class="doctag">@code</span> main&#125;方法中处理命令行参数可能就足够了，但在其他情况下，可能需要将参数作为值注入Spring bean。 这是后一种情况，&#123;<span class="doctag">@code</span> CommandLinePropertySource&#125;变得有用。 通常将 &#123;<span class="doctag">@code</span> CommandLinePropertySource&#125; 添加到Spring &#123;<span class="doctag">@code</span> ApplicationContext&#125; 的 &#123;<span class="doctag">@link</span> Environment&#125; 中，此时所有命令行参数可通过 &#123;<span class="doctag">@link</span> Environment#getProperty(String)&#125; 方法获得。 例如：</div><div class="line"> *</div><div class="line"> * public static void main(String[] args) &#123;</div><div class="line"> *     CommandLinePropertySource clps = ...;</div><div class="line"> *     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</div><div class="line"> *     ctx.getEnvironment().getPropertySources().addFirst(clps);</div><div class="line"> *     ctx.register(AppConfig.class);</div><div class="line"> *     ctx.refresh();</div><div class="line"> * &#125;</div><div class="line"> *</div><div class="line"> * 通过上面的引导逻辑，&#123;<span class="doctag">@code</span> AppConfig&#125; 类可以 &#123;<span class="doctag">@code</span> <span class="doctag">@Inject</span>&#125; Spring &#123;<span class="doctag">@code</span> Environment&#125;并直接查询属性：</div><div class="line"> *</div><div class="line"> * <span class="doctag">@Configuration</span></div><div class="line"> * public class AppConfig &#123;</div><div class="line"> *</div><div class="line"> *     <span class="doctag">@Inject</span> Environment env;</div><div class="line"> *</div><div class="line"> *     <span class="doctag">@Bean</span></div><div class="line"> *     public void DataSource dataSource() &#123;</div><div class="line"> *         MyVendorDataSource dataSource = new MyVendorDataSource();</div><div class="line"> *         dataSource.setHostname(env.getProperty("db.hostname", "localhost"));</div><div class="line"> *         dataSource.setUsername(env.getRequiredProperty("db.username"));</div><div class="line"> *         dataSource.setPassword(env.getRequiredProperty("db.password"));</div><div class="line"> *         // ...</div><div class="line"> *         return dataSource;</div><div class="line"> *     &#125;</div><div class="line"> * &#125;</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 由于 &#123;<span class="doctag">@code</span> CommandLinePropertySource&#125; 已使用 &#123;<span class="doctag">@code</span> #addFirst&#125; 方法添加到 &#123;<span class="doctag">@code</span> Environment&#125; 的 &#123;<span class="doctag">@link</span> MutablePropertySources&#125; 集合中，因此具有最高的搜索优先级，这意味着 “db.hostname” 或可能存在于其他属性源（如系统环境变量）的属性中，它将首先从命令行属性源中选择。 这是一个合理的方法，因为在命令行上指定的参数自然比指定为环境变量的参数更具体。</div><div class="line"> * 作为注入 &#123;<span class="doctag">@code</span> Environment&#125; 的替代方法，Spring的 &#123;<span class="doctag">@code</span> <span class="doctag">@Value</span>&#125; 注释可以用于注入这些属性，因为已经注册了 &#123;<span class="doctag">@link</span> PropertySourcesPropertyResolver&#125; bean，直接或通过使用 &#123;<span class="doctag">@code</span> &lt;context：property-placeholder&gt;&#125; 元素。 例如：</div><div class="line"> * <span class="doctag">@Component</span></div><div class="line"> * public class MyComponent &#123;</div><div class="line"> *</div><div class="line"> *     <span class="doctag">@Value</span>("my.property:defaultVal")</div><div class="line"> *     private String myProperty;</div><div class="line"> *</div><div class="line"> *     public void getMyProperty() &#123;</div><div class="line"> *         return this.myProperty;</div><div class="line"> *     &#125;</div><div class="line"> *</div><div class="line"> *     // ...</div><div class="line"> * &#125;</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 使用选项参数</div><div class="line"> * 单个命令行参数通过通常的 &#123;<span class="doctag">@link</span> PropertySource#getProperty(String)&#125; 和 &#123;<span class="doctag">@link</span> PropertySource#containsProperty(String)&#125; 方法表示为属性。 例如，给出以下命令行:</div><div class="line"> * --o1=v1 --o2</div><div class="line"> * 'o1' 和 'o2' 被视为“选项参数”，并且以下断言将评估为true：</div><div class="line"> *</div><div class="line"> * CommandLinePropertySource&lt;?&gt; ps = ...</div><div class="line"> * assert ps.containsProperty("o1") == true;</div><div class="line"> * assert ps.containsProperty("o2") == true;</div><div class="line"> * assert ps.containsProperty("o3") == false;</div><div class="line"> * assert ps.getProperty("o1").equals("v1");</div><div class="line"> * assert ps.getProperty("o2").equals("");</div><div class="line"> * assert ps.getProperty("o3") == null;</div><div class="line"> *</div><div class="line"> * 请注意，'o2'选项没有参数，但&#123;<span class="doctag">@code</span> getProperty（“o2”）&#125;解析为空字符串 (&#123;<span class="doctag">@code</span> ""&#125;) 而不是&#123;<span class="doctag">@code</span> null&#125;，而&#123;<span class="doctag">@code</span> getProperty “o3”）&#125;解析为&#123;<span class="doctag">@code</span> null&#125;，因为没有指定。 此行为与所有&#123;<span class="doctag">@code</span> PropertySource&#125;实现所遵循的一般约定一致。</div><div class="line"> *</div><div class="line"> * 另请注意，虽然在上述示例中使用 "--" 来表示一个选项参数，但是这种语法可能会在单独的命令行参数库中有所不同。 例如，基于JOpt或Commons CLI的实现可能允许单个破折号 ("-") “短”选项参数等。</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 使用非选项参数</div><div class="line"> *</div><div class="line"> * 这种抽象也支持非选项参数。 任何没有选项样式前缀（如 "-" 或 "--" ）提供的参数都被视为“非选项参数”，通过特殊的 &#123;<span class="doctag">@linkplain</span></div><div class="line"> * #DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME "nonOptionArgs"&#125; 属性可以使用。 如果指定了多个非选项参数，则此属性的值将是包含所有参数的以逗号分隔的字符串。 这种方法确保来自 &#123;<span class="doctag">@code</span></div><div class="line"> * CommandLinePropertySource&#125; 的所有属性的简单且一致的返回类型（String），同时适用于与Spring &#123;<span class="doctag">@link</span> Environment&#125; 及其内置 &#123;<span class="doctag">@code</span> ConversionService&#125;。 请考虑以下示例：</div><div class="line"> *</div><div class="line"> * --o1=v1 --o2=v2 /path/to/file1 /path/to/file2</div><div class="line"> *</div><div class="line"> * 在本示例中，“o1”和“o2”将被视为“选项参数”，而两个文件系统路径将被视为“非选项参数”。 因此，以下断言将评估为真：</div><div class="line"> *</div><div class="line"> * CommandLinePropertySource&lt;?&gt; ps = ...</div><div class="line"> * assert ps.containsProperty("o1") == true;</div><div class="line"> * assert ps.containsProperty("o2") == true;</div><div class="line"> * assert ps.containsProperty("nonOptionArgs") == true;</div><div class="line"> * assert ps.getProperty("o1").equals("v1");</div><div class="line"> * assert ps.getProperty("o2").equals("v2");</div><div class="line"> * assert ps.getProperty("nonOptionArgs").equals("/path/to/file1,/path/to/file2");</div><div class="line"> *</div><div class="line"> * 如上所述，当与Spring &#123;<span class="doctag">@code</span> Environment&#125;抽象结合使用时，逗号分隔的字符串可能很容易转换为String数组或列表：</div><div class="line"> *</div><div class="line"> * Environment env = applicationContext.getEnvironment();</div><div class="line"> * String[] nonOptionArgs = env.getProperty("nonOptionArgs", String[].class);</div><div class="line"> * assert nonOptionArgs[0].equals("/path/to/file1");</div><div class="line"> * assert nonOptionArgs[1].equals("/path/to/file2");</div><div class="line"> *</div><div class="line"> * 可以通过 &#123;<span class="doctag">@link</span> #setNonOptionArgsPropertyName(String)&#125; 方法定制特殊“非选项参数”属性的名称。 建议这样做，因为它为非选项参数赋予正确的语义值。 例如，如果将文件系统路径指定为非选项参数，则可能将其称为“file.locations”类似于“nonOptionArgs”的默认值：</div><div class="line"> *</div><div class="line"> * public static void main(String[] args) &#123;</div><div class="line"> *     CommandLinePropertySource clps = ...;</div><div class="line"> *     clps.setNonOptionArgsPropertyName("file.locations");</div><div class="line"> *</div><div class="line"> *     AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext();</div><div class="line"> *     ctx.getEnvironment().getPropertySources().addFirst(clps);</div><div class="line"> *     ctx.register(AppConfig.class);</div><div class="line"> *     ctx.refresh();</div><div class="line"> * &#125;</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 限制</div><div class="line"> * 这种抽象不是为了暴露基础命令行解析API（如JOpt或Commons CLI）的全部功能。 它的意图恰恰相反：提供最简单的可能的抽象，以便在命令行参数解析之后访问。  解析主方法中的参数的&#123;<span class="doctag">@code</span> String []&#125;，然后简单地将解析结果提供给&#123;<span class="doctag">@code</span> CommandLinePropertySource&#125;的实现。 在这一点上，所有参数都可以被认为是“选项”或“非选项”参数，如上所述可以通过普通的&#123;<span class="doctag">@code</span> PropertySource&#125;和&#123;<span class="doctag">@code</span> Environment&#125; API来访问。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommandLinePropertySource</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">EnumerablePropertySource</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String COMMAND_LINE_PROPERTY_SOURCE_NAME = <span class="string">"commandLineArgs"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME = <span class="string">"nonOptionArgs"</span>;</div><div class="line">	<span class="keyword">private</span> String nonOptionArgsPropertyName = DEFAULT_NON_OPTION_ARGS_PROPERTY_NAME;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-7-SimpleCommandLinePropertySource"><a href="#3-1-7-SimpleCommandLinePropertySource" class="headerlink" title="3.1.7 SimpleCommandLinePropertySource"></a>3.1.7 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/SimpleCommandLinePropertySource.java" target="_blank" rel="external">SimpleCommandLinePropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> CommandLinePropertySource&#125;实现，由一个简单的String数组支持</div><div class="line"> *</div><div class="line"> * </div><div class="line"> * 目的</div><div class="line"> * 此&#123;<span class="doctag">@code</span> CommandLinePropertySource&#125;实现旨在提供解析命令行参数的最简单的方法。 与所有 &#123;<span class="doctag">@code</span> CommandLinePropertySource&#125; 实现一样，命令行参数分为两个不同的组： 选项参数 和 非选项参数 ，如下所述 从Javadoc为&#123;<span class="doctag">@link</span> SimpleCommandLineArgsParser&#125;复制的部分） ：</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 使用选项参数</div><div class="line"> * 选项参数必须遵守确切的语法：</div><div class="line"> * --optName[=optValue]</div><div class="line"> * 也就是说，选项必须以"&#123;<span class="doctag">@code</span> --&#125;"为前缀，并且可以指定或不指定值。 如果指定了一个值，则必须使用等号（“=”）分隔不带空格的名称和值。</div><div class="line"> * 选项参数的有效示例</div><div class="line"> * --foo</div><div class="line"> * --foo=bar</div><div class="line"> * --foo="bar then baz"</div><div class="line"> * --foo=bar,baz,biz</div><div class="line"> * 无效的选项参数示例</div><div class="line"> * -foo</div><div class="line"> * --foo bar</div><div class="line"> * --foo = bar</div><div class="line"> * --foo=bar --foo=baz --foo=biz</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 使用非选项参数</div><div class="line"> * 在没有 "&#123;<span class="doctag">@code</span> --&#125;" 选项前缀的命令行中指定的任何和所有参数将被视为“非选项参数”，并通过 &#123;<span class="doctag">@link</span> #getNonOptionArgs()&#125; 方法提供。</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 典型用法</div><div class="line"> * public static void main(String[] args) &#123;</div><div class="line"> *     PropertySource&lt;?&gt; ps = new SimpleCommandLinePropertySource(args);</div><div class="line"> *     // ...</div><div class="line"> * &#125;</div><div class="line"> * 有关完整的一般用法示例，请参阅&#123;<span class="doctag">@link</span> CommandLinePropertySource&#125;。</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * 基础以外</div><div class="line"> * 当需要更全面的命令行解析时，请考虑使用提供的&#123;<span class="doctag">@link</span> JOptCommandLinePropertySource&#125;，或者根据您选择的命令行解析库实现您自己的&#123;<span class="doctag">@code</span> CommandLinePropertySource&#125;</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleCommandLinePropertySource</span> <span class="keyword">extends</span> <span class="title">CommandLinePropertySource</span>&lt;<span class="title">CommandLineArgs</span>&gt; </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommandLineArgs</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, List&lt;String&gt;&gt; optionArgs = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;String&gt; nonOptionArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-8-CompositePropertySource"><a href="#3-1-8-CompositePropertySource" class="headerlink" title="3.1.8 CompositePropertySource"></a>3.1.8 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/CompositePropertySource.java" target="_blank" rel="external">CompositePropertySource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 复合 &#123;<span class="doctag">@link</span> PropertySource&#125; 实现，迭代一组&#123;<span class="doctag">@link</span> PropertySource&#125;实例。在多个资源共享同一个名称的情况下，是必要的。例如当 &#123;<span class="doctag">@code</span> <span class="doctag">@PropertySource</span>&#125; 提供多个值时。</div><div class="line"> *</div><div class="line"> * 从Spring 4.1.2开始，该类扩展了&#123;<span class="doctag">@link</span> EnumerablePropertySource&#125;，而不是纯&#123;<span class="doctag">@link</span> PropertySource&#125;，根据所有包含的源的累积属性名称展开 &#123;<span class="doctag">@link</span> #getPropertyNames()&#125; （尽最大可能） ）。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CompositePropertySource</span> <span class="keyword">extends</span> <span class="title">EnumerablePropertySource</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;PropertySource&lt;?&gt;&gt; propertySources = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-PropertySource集合"><a href="#3-2-PropertySource集合" class="headerlink" title="3.2 PropertySource集合"></a>3.2 PropertySource集合</h3><h5 id="3-2-1-PropertySources"><a href="#3-2-1-PropertySources" class="headerlink" title="3.2.1 PropertySources"></a>3.2.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/PropertySources.java" target="_blank" rel="external">PropertySources</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PropertySources</span> <span class="keyword">extends</span> <span class="title">Iterable</span>&lt;<span class="title">PropertySource</span>&lt;?&gt;&gt; </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(String name)</span></span>;</div><div class="line">	PropertySource&lt;?&gt; get(String name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-2-2-MutablePropertySources"><a href="#3-2-2-MutablePropertySources" class="headerlink" title="3.2.2 MutablePropertySources"></a>3.2.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/MutablePropertySources.java" target="_blank" rel="external">MutablePropertySources</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> PropertySources&#125;接口的默认实现。 允许处理包含的多属性源，并提供一个构造函数来复制现有的&#123;<span class="doctag">@code</span> PropertySources&#125;实例。</div><div class="line"> * 在 &#123;<span class="doctag">@link</span> #addFirst&#125; 和 &#123;<span class="doctag">@link</span> #addLast&#125; 等方法中提及 优先级 的地方，这是关于在使用&#123;<span class="doctag">@link</span> PropertyResolver&#125;解析给定属性时，搜索属性源的顺序。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MutablePropertySources</span> <span class="keyword">implements</span> <span class="title">PropertySources</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> List&lt;PropertySource&lt;?&gt;&gt; propertySourceList = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-Environment"><a href="#4-Environment" class="headerlink" title="4. Environment"></a>4. Environment</h2><p><img src="/assets/img/spring/springEnvPropertyResolver.png" alt=""></p>
<h3 id="4-1-接口"><a href="#4-1-接口" class="headerlink" title="4.1 接口"></a>4.1 接口</h3><h5 id="4-1-1-Environment"><a href="#4-1-1-Environment" class="headerlink" title="4.1.1 Environment"></a>4.1.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/Environment.java" target="_blank" rel="external">Environment</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 表示当前应用程序正在运行的环境的接口。 模拟应用程序环境的两个关键方面：profiles 和 properties 。 与属性访问相关的方法通过 &#123;<span class="doctag">@link</span> PropertyResolver&#125; 父接口暴露。</div><div class="line"> * 只有在给定的 profile 活动时，profile才是一个有名字的、注册在容器上的bean定义逻辑组。 bean可以被分配到不管是以XML定义还是以注释的profile; 有关语法详细信息，请参阅spring-beans 3.1 schema 或 &#123;<span class="doctag">@link</span> org.springframework.context.annotation.Profile <span class="doctag">@Profile</span>&#125;注释。 &#123;<span class="doctag">@code</span> Environment&#125;对象与 profiles 的关系在于确定当前中哪些配置文件（如果有的话）&#123;<span class="doctag">@linkplain</span> #getActiveProfiles active&#125; 活动 ，哪些配置文件（如果有的话）应该是&#123;<span class="doctag">@linkplain</span> #getDefaultProfiles 在默认情况下处于活动状态&#125;。</div><div class="line"> * Properties 在几乎所有的应用程序中起着重要的作用，可能来自各种来源：属性文件，JVM系统属性，系统环境变量，JNDI，servlet上下文参数，ad-hoc 属性对象，地图等。 环境对象与属性关系的作用是为用户提供方便的服务接口，用于配置属性源并从中解析属性。</div><div class="line"> * 在&#123;<span class="doctag">@code</span> ApplicationContext&#125;中管理的Bean可以注册为 &#123;<span class="doctag">@link</span> org.springframework.context.EnvironmentAware EnvironmentAware&#125; 或 &#123;<span class="doctag">@code</span> <span class="doctag">@Inject</span>&#125; &#123;<span class="doctag">@code</span> Environment&#125;，以便直接查询配置文件状态或解析属性。</div><div class="line"> * 然而，在大多数情况下，应用级别的bean不需要直接与&#123;<span class="doctag">@code</span> Environment&#125;进行交互，而是可能必须将 &#123;<span class="doctag">@code</span> $&#123;...&#125;&#125; 属性值替换为属性占位符配置。例如，&#123;<span class="doctag">@link</span> org.springframework.context.support.PropertySourcesPlaceholderConfigurer PropertySourcesPlaceholderConfigurer&#125;）本身就是&#123;<span class="doctag">@code</span> EnvironmentAware&#125;，并且在Spring 3.1之前，使用 &#123;<span class="doctag">@code</span> getEnvironment()&#125; 时，默认被注册。</div><div class="line"> * 环境对象的配置必须通过从 &#123;<span class="doctag">@code</span> AbstractApplicationContext&#125; 子类 &#123;<span class="doctag">@code</span> getEnvironment()&#125; 方法返回的&#123;<span class="doctag">@code</span> ConfigurableEnvironment&#125;接口完成。有关使用示例的示例，请参阅&#123;<span class="doctag">@link</span> ConfigurableEnvironment&#125; Javadoc，演示在应用程序上下文&#123;<span class="doctag">@code</span> refresh()&#125;之前操纵属性源。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Environment</span> <span class="keyword">extends</span> <span class="title">PropertyResolver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回显示为此环境激活的配置文件集。 配置文件用于创建有条件注册的bean定义的逻辑分组，例如基于部署环境。 可以通过将&#123;<span class="doctag">@linkplain</span> AbstractEnvironment#ACTIVE_PROFILES_PROPERTY_NAME "spring.profiles.active"&#125; 设置为系统属性或调用 &#123;<span class="doctag">@link</span> ConfigurableEnvironment#setActiveProfiles(String...)&#125; 来激活配置文件。</div><div class="line">	 * 如果没有将配置文件明确指定为活动的，那么任何&#123;<span class="doctag">@linkplain</span> #getDefaultProfiles() 默认配置文件&#125;将自动被激活。</div><div class="line">	 */</div><div class="line">	String[] getActiveProfiles();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当没有显式设置活动的配置文件时，默认情况下返回一组配置文件。</div><div class="line">	 */</div><div class="line">	String[] getDefaultProfiles();</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回一个或多个给定的配置文件是否处于活动状态，或者在没有显式活动配置文件的情况下，是否将一个或多个给定配置文件包含在默认配置文件集中。</div><div class="line">	 * 如果配置文件以 '!' 开头 逻辑被反转，即如果给定的配置文件不是 活动，该方法将返回true。</div><div class="line">	 * 例如，如果配置文件“p1”处于活动状态或“p2”不活动，则</div><div class="line">	 * env.acceptsProfiles("p1", "!p2")</div><div class="line">	 * 将返回&#123;<span class="doctag">@code</span> true&#125;</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">acceptsProfiles</span><span class="params">(String... profiles)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-1-2-ConfigurableEnvironment"><a href="#5-1-2-ConfigurableEnvironment" class="headerlink" title="5.1.2 ConfigurableEnvironment"></a>5.1.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/ConfigurableEnvironment.java" target="_blank" rel="external">ConfigurableEnvironment</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置接口由大多数（如果不是全部）&#123;<span class="doctag">@link</span> Environment&#125;类型实现。</div><div class="line"> * 提供设置活动和默认配置文件以及操纵底层属性源的功能。</div><div class="line"> * 允许客户端通过&#123;<span class="doctag">@link</span> ConfigurablePropertyResolver&#125;父接口，来设置和验证所需的属性，自定义转换服务等等。</div><div class="line"> *</div><div class="line"> * 操纵属性来源</div><div class="line"> * 属性来源可被删除，重新排序或替换; 并且可以使用从 &#123;<span class="doctag">@link</span> #getPropertySources()&#125; 返回的 &#123;<span class="doctag">@link</span> MutablePropertySources&#125; 实例添加其他属性源。</div><div class="line"> * 以下示例针对&#123;<span class="doctag">@code</span> ConfigurableEnvironment&#125;的实现&#123;<span class="doctag">@link</span> StandardEnvironment&#125;，但通常适用于任何实现，尽管特定的默认属性来源可能不同。</div><div class="line"> *</div><div class="line"> * 示例：添加具有最高搜索优先级的新属性源</div><div class="line"> * ConfigurableEnvironment environment = new StandardEnvironment();</div><div class="line"> * MutablePropertySources propertySources = environment.getPropertySources();</div><div class="line"> * Map&lt;String, String&gt; myMap = new HashMap&lt;String, String&gt;();</div><div class="line"> * myMap.put("xyz", "myValue");</div><div class="line"> * propertySources.addFirst(new MapPropertySource("MY_MAP", myMap));</div><div class="line"> *</div><div class="line"> * 示例：删除默认的系统属性属性源</div><div class="line"> * MutablePropertySources propertySources = environment.getPropertySources();</div><div class="line"> * propertySources.remove(StandardEnvironment.SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME)</div><div class="line"> *</div><div class="line"> * 示例：mock系统环境进行测试</div><div class="line"> * MutablePropertySources propertySources = environment.getPropertySources();</div><div class="line"> * MockPropertySource mockEnvVars = new MockPropertySource().withProperty("xyz", "myValue");</div><div class="line"> * propertySources.replace(StandardEnvironment.SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME, mockEnvVars);</div><div class="line"> *</div><div class="line"> * 当&#123;<span class="doctag">@code</span> ApplicationContext&#125;正在使用&#123;<span class="doctag">@link</span> Environment&#125;时，在上下文的&#123;<span class="doctag">@link</span></div><div class="line"> * org.springframework.context.support.AbstractApplicationContext#refresh() refresh()&#125;方法被调用之前执行任何这样的&#123;<span class="doctag">@code</span> PropertySource&#125;操作非常重要。</div><div class="line"> * 这确保了所有属性源在容器引导过程中可用，包括被&#123;<span class="doctag">@linkplain</span> org.springframework.context.support.PropertySourcesPlaceholderConfigurer property placeholder configurers&#125;使用。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableEnvironment</span> <span class="keyword">extends</span> <span class="title">Environment</span>, <span class="title">ConfigurablePropertyResolver</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 为 &#123;<span class="doctag">@code</span> Environment&#125; 指定一组活动的配置文件。在容器引导期间评估配置文件，以确定bean定义是否应该向容器注册。</div><div class="line">	 * 任何现有的活动配置文件将被替换为给定的参数; 零参数调用来清除活动配置文件的当前集合。</div><div class="line">	 * 使用&#123;<span class="doctag">@link</span> #addActiveProfile&#125;添加配置文件同时保留现有集。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setActiveProfiles</span><span class="params">(String... profiles)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将配置文件添加到当前活动配置文件集中。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addActiveProfile</span><span class="params">(String profile)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果没有其他配置文件通过&#123;<span class="doctag">@link</span> #setActiveProfiles&#125;显式生效，则默认指定要设置为活动的配置文件集。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setDefaultProfiles</span><span class="params">(String... profiles)</span></span>;</div><div class="line"></div><div class="line">	<span class="function">MutablePropertySources <span class="title">getPropertySources</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果当前&#123;<span class="doctag">@link</span> SecurityManager&#125;允许，返回 &#123;<span class="doctag">@link</span> System#getenv()&#125; 的值，否则返回一个map实现，它将尝试通过调用 &#123;<span class="doctag">@link</span> System#getenv(String)&#125; 访问各个键。</div><div class="line">	 * 请注意，大多数&#123;<span class="doctag">@link</span> Environment&#125;实现将将此系统环境映射作为默认&#123;<span class="doctag">@link</span> PropertySource&#125;进行搜索。 因此，建议不要直接使用此方法，除非明确地意图绕过其他属性来源。</div><div class="line">	 * 在返回的Map上调用 &#123;<span class="doctag">@link</span> Map#get(Object)&#125; 将永远不会抛出&#123;<span class="doctag">@link</span> IllegalAccessException&#125;; 在SecurityManager禁止访问属性的情况下，将返回&#123;<span class="doctag">@code</span> null&#125;，并将发出INFO级日志消息，注明异常。</div><div class="line">	 */</div><div class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getSystemEnvironment</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果当前的 &#123;<span class="doctag">@link</span> SecurityManager&#125; 允许，返回 &#123;<span class="doctag">@link</span> System#getProperties()&#125; 的值，否则返回一个映射实现，它将尝试使用对 &#123;<span class="doctag">@link</span> System#getProperty(String)&#125; 的调用访问各个键。</div><div class="line">	 * 请注意，大多数&#123;<span class="doctag">@code</span> Environment&#125;实现将将此系统属性映射作为默认&#123;<span class="doctag">@link</span> PropertySource&#125;进行搜索。 因此，建议不要直接使用此方法，除非明确地意图绕过其他属性来源。</div><div class="line">	 * 在返回的Map上调用 &#123;<span class="doctag">@link</span> Map#get(Object)&#125; 将永远不会抛出&#123;<span class="doctag">@link</span> IllegalAccessException&#125;; 在SecurityManager禁止访问属性的情况下，将返回&#123;<span class="doctag">@code</span> null&#125;，并将发出INFO级日志消息，注明异常。</div><div class="line">	 */</div><div class="line">	<span class="function">Map&lt;String, Object&gt; <span class="title">getSystemProperties</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 追加给定的父环境的活动配置文件，默认配置文件和属性源附加到此（子）环境各自的集合中。</div><div class="line">	 * 对于存在于父项和子节点的任何同名命名的&#123;<span class="doctag">@code</span> PropertySource&#125;实例，子实例将被保留并且父实例被丢弃。 这具有允许子级覆盖属性源的作用，并且避免通过公共属性源类型的冗余搜索，</div><div class="line">	 * 例如 系统环境和系统属性。</div><div class="line">	 * 活动和默认配置文件名称也被重复过滤，以避免混淆和冗余存储。</div><div class="line">	 * 在任何情况下，父环境都未修改。 请注意，调用&#123;<span class="doctag">@code</span> merge&#125;之后发生的父环境的任何更改都不会反映在该子环境中。 因此，在调用&#123;<span class="doctag">@code</span> merge&#125;之前，应该小心配置父属性源和配置文件信息。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(ConfigurableEnvironment parent)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="5-2-抽象与实现"><a href="#5-2-抽象与实现" class="headerlink" title="5.2 抽象与实现"></a>5.2 抽象与实现</h3><h5 id="5-2-1-AbstractEnvironment"><a href="#5-2-1-AbstractEnvironment" class="headerlink" title="5.2.1 AbstractEnvironment"></a>5.2.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/AbstractEnvironment.java" target="_blank" rel="external">AbstractEnvironment</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> Environment&#125; 实现的抽象基类。 支持保留默认配置文件名称的概念，并通过 &#123;<span class="doctag">@link</span> #ACTIVE_PROFILES_PROPERTY_NAME&#125; 和 &#123;<span class="doctag">@link</span> #DEFAULT_PROFILES_PROPERTY_NAME&#125; 属性开启指定活动和默认配置文件。</div><div class="line"> *</div><div class="line"> * 具体的子类区别主要在于默认添加的 &#123;<span class="doctag">@link</span> PropertySource&#125; 对象。 &#123;<span class="doctag">@code</span> AbstractEnvironment&#125; 没有添加。 子类应通过受保护的&#123;<span class="doctag">@link</span> #customizePropertySources（MutablePropertySources）&#125;钩子来提供属性源，而客户端应使用&#123;<span class="doctag">@link</span> ConfigurableEnvironment#getPropertySources()&#125;进行自定义，并使用&#123;<span class="doctag">@link</span> MutablePropertySources&#125; API。 有关使用示例，请参阅&#123;<span class="doctag">@link</span> ConfigurableEnvironment&#125; javadoc。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractEnvironment</span> <span class="keyword">implements</span> <span class="title">ConfigurableEnvironment</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 系统属性指示Spring忽略系统环境变量，即永远不 会通过&#123;<span class="doctag">@link</span> System#getenv()&#125;检索这样一个变量。</div><div class="line">	 * 默认值为“false”，返回到系统环境变量，检查Spring环境属性（例如，配置字符串中的占位符）是否不可解析。 如果您遇到来自Spring的&#123;<span class="doctag">@code</span> getenv&#125;呼叫的日志警告，请考虑将此标志切换为“true”，例如。 在WebSphere上使用严格的SecurityManager设置和AccessControlExceptions警告。...</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String IGNORE_GETENV_PROPERTY_NAME = <span class="string">"spring.getenv.ignore"</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 要设置为指定活动配置文件的属性名称：&#123;<span class="doctag">@value</span>&#125;。 值可以以逗号分隔。</div><div class="line">	 * 请注意，某些shell环境（如Bash）不允许在变量名称中使用句点字符。 假设Spring的&#123;<span class="doctag">@link</span> SystemEnvironmentPropertySource&#125;正在使用中，此属性可能被指定为环境变量&#123;<span class="doctag">@code</span> SPRING_PROFILES_ACTIVE&#125;。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String ACTIVE_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.active"</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 要设置的属性名称，以指定默认情况下活动的配置文件：&#123;<span class="doctag">@value</span>&#125;。 值可以以逗号分隔。</div><div class="line">	 * 请注意，某些shell环境（如Bash）不允许在变量名称中使用句点字符。 假设Spring的&#123;<span class="doctag">@link</span> SystemEnvironmentPropertySource&#125;正在使用，该属性可能被指定为环境变量&#123;<span class="doctag">@code</span> SPRING_PROFILES_DEFAULT&#125;。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_PROFILES_PROPERTY_NAME = <span class="string">"spring.profiles.default"</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 保留的默认配置文件名称名称：&#123;<span class="doctag">@value</span>&#125;。 如果没有明确的默认配置文件名称，并且没有显式设置活动配置文件名称，默认情况下将自动激活此配置文件。</div><div class="line">	 */</div><div class="line">	<span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESERVED_DEFAULT_PROFILE_NAME = <span class="string">"default"</span>;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; activeProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;String&gt; defaultProfiles = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(getReservedDefaultProfiles());</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> MutablePropertySources propertySources = <span class="keyword">new</span> MutablePropertySources(<span class="keyword">this</span>.logger);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ConfigurablePropertyResolver propertyResolver =</div><div class="line">			<span class="keyword">new</span> PropertySourcesPropertyResolver(<span class="keyword">this</span>.propertySources);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-2-2-StandardEnvironment"><a href="#5-2-2-StandardEnvironment" class="headerlink" title="5.2.2 StandardEnvironment"></a>5.2.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/env/StandardEnvironment.java" target="_blank" rel="external">StandardEnvironment</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> Environment&#125; 实现适用于“标准”（即非Web）应用程序。</div><div class="line"> * 除了属性解析和配置文件相关操作之类的&#123;<span class="doctag">@link</span> ConfigurableEnvironment&#125;的常规功能外，此实现还将配置两个默认属性源，以下列顺序进行搜索：</div><div class="line"> * &#123;<span class="doctag">@linkplain</span> AbstractEnvironment#getSystemProperties() system properties&#125;</div><div class="line"> * &#123;<span class="doctag">@linkplain</span> AbstractEnvironment#getSystemEnvironment() system environment variables&#125;</div><div class="line"></div><div class="line"> * 也就是说，如果JVM系统属性和当前进程的一组环境变量中都存在密钥“xyz”，系统属性中的“xyz”键值将从一个调用返回到 &#123;<span class="doctag">@code</span> environment.getProperty("xyz")&#125;。 默认情况下选择此排序，因为系统属性是每个JVM，而给定系统上的许多JVM的环境变量可能相同。 给予系统属性优先级允许在每个JVM的基础上覆盖环境变量。</div><div class="line"> * 这些默认属性源可能会被删除，重新排序或替换; 并且可以使用 &#123;<span class="doctag">@link</span> #getPropertySources()&#125; 中提供的 &#123;<span class="doctag">@link</span> MutablePropertySources&#125; 实例添加其他属性来源。 有关使用示例，请参阅&#123;<span class="doctag">@link</span> ConfigurableEnvironment&#125; Javadoc。</div><div class="line"> *</div><div class="line"> * 请参阅&#123;<span class="doctag">@link</span> SystemEnvironmentPropertySource&#125; javadoc，了解在shell环境（例如Bash）中特殊处理属性名称的详细信息，该属性名称不允许变量名称中的句点字符。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StandardEnvironment</span> <span class="keyword">extends</span> <span class="title">AbstractEnvironment</span> </span>&#123;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_ENVIRONMENT_PROPERTY_SOURCE_NAME = <span class="string">"systemEnvironment"</span>;</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String SYSTEM_PROPERTIES_PROPERTY_SOURCE_NAME = <span class="string">"systemProperties"</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;p&gt;Environment 是集成在容器中的抽象，用于模拟应用程序环境的两个关键方面：配置文件和属性。&lt;/p&gt;
&lt;p&gt;只有给定的
    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码解析 3.类型体系</title>
    <link href="http://leerenbo.cn/2017/05/14/spring-code-type/"/>
    <id>http://leerenbo.cn/2017/05/14/spring-code-type/</id>
    <published>2017-05-14T07:01:48.000Z</published>
    <updated>2017-05-17T11:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Java反射，类型"><a href="#1-Java反射，类型" class="headerlink" title="1.Java反射，类型"></a>1.Java反射，类型</h2><p><img src="/assets/img/spring/javaType.png" alt=""></p>
<h2 id="2-Spring类型解析"><a href="#2-Spring类型解析" class="headerlink" title="2.Spring类型解析"></a>2.Spring类型解析</h2><p><img src="/assets/img/spring/springConvertType.png" alt=""></p>
<h3 id="2-1ResolvableType"><a href="#2-1ResolvableType" class="headerlink" title="2.1ResolvableType"></a>2.1<a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/ResolvableType.java" target="_blank" rel="external">ResolvableType</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 封装Java &#123;<span class="doctag">@link</span> java.lang.reflect.Type&#125;，提供访问&#123;<span class="doctag">@link</span> #getSuperType() supertypes&#125;，&#123;<span class="doctag">@link</span> #getInterfaces() interfaces&#125; 和 &#123;<span class="doctag">@link</span> #getGeneric(int...) generic parameters&#125; 以及最终&#123;<span class="doctag">@link</span> #resolve() resolve&#125; 到 &#123;<span class="doctag">@link</span> java.lang.Class&#125;的能力。</div><div class="line"> * 可以从 &#123;<span class="doctag">@link</span> #forField(Field) fields&#125; ，&#123;<span class="doctag">@link</span> #forMethodParameter(Method, int) method parameters&#125; ，&#123;<span class="doctag">@link</span> #forMethodReturnType(Method) method returns&#125; 或 &#123;<span class="doctag">@link</span> #forClass(Class) classes&#125; 中获取 &#123;<span class="doctag">@code</span> ResolvableTypes&#125;。</div><div class="line"> * 这个类上的大多数方法都将返回&#123;<span class="doctag">@link</span> ResolvableType&#125;，方便导航。 例如：</div><div class="line"> * </div><div class="line"> * </div><div class="line"> * private HashMap&lt;Integer, List&lt;String&gt;&gt; myMap;</div><div class="line"> *</div><div class="line"> * public void example() &#123;</div><div class="line"> *     ResolvableType t = ResolvableType.forField(getClass().getDeclaredField("myMap"));</div><div class="line"> *     t.getSuperType(); // AbstractMap&lt;Integer, List&lt;String&gt;&gt;</div><div class="line"> *     t.asMap(); // Map&lt;Integer, List&lt;String&gt;&gt;</div><div class="line"> *     t.getGeneric(0).resolve(); // Integer</div><div class="line"> *     t.getGeneric(1).resolve(); // List</div><div class="line"> *     t.getGeneric(1); // List&lt;String&gt;</div><div class="line"> *     t.resolveGeneric(1, 0); // String</div><div class="line"> * &#125;</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResolvableType</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 没有值可用时返回&#123;<span class="doctag">@code</span> ResolvableType&#125;。 &#123;<span class="doctag">@code</span> NONE&#125;优先于&#123;<span class="doctag">@code</span> null&#125;，以便可以安全地链接多个方法调用。</div><div class="line">	 */</div><div class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ResolvableType NONE = <span class="keyword">new</span> ResolvableType(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ResolvableType[] EMPTY_TYPES_ARRAY = <span class="keyword">new</span> ResolvableType[<span class="number">0</span>];</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentReferenceHashMap&lt;ResolvableType, ResolvableType&gt; cache =</div><div class="line">			<span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(<span class="number">256</span>);</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 正在管理的底层Java类型（只有&#123;<span class="doctag">@code</span> null&#125;，转化为&#123;<span class="doctag">@link</span> #NONE&#125;）。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Type type;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 该类型的可选提供程序。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> TypeProvider typeProvider;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 如果没有解析器可用，则使用&#123;<span class="doctag">@code</span> VariableResolver&#125;或&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> VariableResolver variableResolver;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">     * 数组的组件类型或&#123;<span class="doctag">@code</span> null&#125;，如果该类型应被推导出来。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ResolvableType componentType;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * Copy of the resolved value.</div><div class="line">     * 解析值的复制</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; resolved;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Integer hash;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ResolvableType superType;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ResolvableType[] interfaces;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> ResolvableType[] generics;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="TypeDescriptor"><a href="#TypeDescriptor" class="headerlink" title="TypeDescriptor"></a><a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/TypeDescriptor.javaOrderService" target="_blank" rel="external">TypeDescriptor</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 关于要转换的类型的上下文。</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"serial"</span>)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TypeDescriptor</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">static</span> <span class="keyword">final</span> Annotation[] EMPTY_ANNOTATION_ARRAY = <span class="keyword">new</span> Annotation[<span class="number">0</span>];</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, TypeDescriptor&gt; commonTypesCache = <span class="keyword">new</span> HashMap&lt;&gt;(<span class="number">18</span>);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Class&lt;?&gt;[] CACHED_COMMON_TYPES = &#123;</div><div class="line">			<span class="keyword">boolean</span>.class, Boolean.class, <span class="keyword">byte</span>.class, Byte.class, <span class="keyword">char</span>.class, Character.class,</div><div class="line">			<span class="keyword">double</span>.class, Double.class, <span class="keyword">int</span>.class, Integer.class, <span class="keyword">long</span>.class, Long.class,</div><div class="line">			<span class="keyword">float</span>.class, Float.class, <span class="keyword">short</span>.class, Short.class, String.class, Object.class&#125;;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ResolvableType resolvableType;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> AnnotatedElementAdapter annotatedElement;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-Java反射，类型&quot;&gt;&lt;a href=&quot;#1-Java反射，类型&quot; class=&quot;headerlink&quot; title=&quot;1.Java反射，类型&quot;&gt;&lt;/a&gt;1.Java反射，类型&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/assets/img/spring/javaT
    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码解析 4.类型转换Convert</title>
    <link href="http://leerenbo.cn/2017/05/12/spring-code-convert/"/>
    <id>http://leerenbo.cn/2017/05/12/spring-code-convert/</id>
    <published>2017-05-11T16:32:09.000Z</published>
    <updated>2017-05-17T11:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Spring 3引入了一个提供通用类型转换系统的core.convert包。 该系统定义了一个SPI来实现类型转换逻辑，以及一个在运行时执行类型转换的API。 在Spring容器中，该系统可以用作PropertyEditor的替代方法，将外部化的bean属性值字符串转换为必需的属性类型。 公共API也可以在需要类型转换的应用程序的任何地方使用。</p>
<h2 id="2-类图"><a href="#2-类图" class="headerlink" title="2.类图"></a>2.类图</h2><p><img src="/assets/img/spring/springConvert.png" alt=""></p>
<h2 id="3-convertor"><a href="#3-convertor" class="headerlink" title="3.convertor"></a>3.convertor</h2><h3 id="3-1-接口"><a href="#3-1-接口" class="headerlink" title="3.1 接口"></a>3.1 接口</h3><h5 id="3-1-1-ConditionalConverter"><a href="#3-1-1-ConditionalConverter" class="headerlink" title="3.1.1 ConditionalConverter"></a>3.1.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/converter/ConditionalConverter.java" target="_blank" rel="external">ConditionalConverter</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 允许 &#123;<span class="doctag">@link</span> Converter&#125;，&#123;<span class="doctag">@link</span> GenericConverter&#125;或&#123;<span class="doctag">@link</span> ConverterFactory&#125;根据&#123;<span class="doctag">@code</span> source&#125;和&#123;<span class="doctag">@code</span> target&#125; &#123;<span class="doctag">@link</span> TypeDescriptor&#125;的属性有条件地执行。</div><div class="line"> * 通常用于根据字段或类级特征（如注释或方法）的存在选择性地匹配自定义转换逻辑。 例如，当从String字段转换为Date字段时，如果目标字段也已使用&#123;<span class="doctag">@code</span> <span class="doctag">@DateTimeFormat</span>&#125;注释，则实现可能返回&#123;<span class="doctag">@code</span> true&#125;。</div><div class="line"> * 另一个例子是，当从String字段转换为&#123;<span class="doctag">@code</span> Account&#125;字段时，如果目标Account类定义了&#123;<span class="doctag">@code</span> public static findAccount（String）&#125;方法，那么实现可能返回&#123;<span class="doctag">@code</span> true&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConditionalConverter</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当前&#123;<span class="doctag">@code</span> sourceType&#125;到&#123;<span class="doctag">@code</span> targetType&#125;的转换是否应当选择被选中？</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">matches</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-2-Converter"><a href="#3-1-2-Converter" class="headerlink" title="3.1.2 Converter"></a>3.1.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/converter/Converter.java" target="_blank" rel="external">Converter<s, t=""></s,></a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 转换器将类型为&#123;<span class="doctag">@code</span> S&#125;的 source 对象转换为类型为&#123;<span class="doctag">@code</span> T&#125;的 target。</div><div class="line"> * 此接口的实现是线程安全的，可以共享。</div><div class="line"> * 实现可以同时实现&#123;<span class="doctag">@link</span> ConditionalConverter&#125;。</div><div class="line"> */</div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Converter</span>&lt;<span class="title">S</span>, <span class="title">T</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将类型为&#123;<span class="doctag">@code</span> S&#125;的 source 对象转换为类型&#123;<span class="doctag">@code</span> T&#125; target。</div><div class="line">	 */</div><div class="line">	<span class="function">T <span class="title">convert</span><span class="params">(S source)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-3-ConverterFactory"><a href="#3-1-3-ConverterFactory" class="headerlink" title="3.1.3 ConverterFactory"></a>3.1.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/converter/ConverterFactory.java" target="_blank" rel="external">ConverterFactory<s, r=""></s,></a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个可以将对象从 S 转换成 R 的子类型的“范围”转换器的工厂。</div><div class="line"> * 实现可以同时实现&#123;<span class="doctag">@link</span> ConditionalConverter&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterFactory</span>&lt;<span class="title">S</span>, <span class="title">R</span>&gt; </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 获取转换器从S转换为目标类型T，其中T也是R的实例。</div><div class="line">	 */</div><div class="line">	&lt;T extends R&gt; <span class="function">Converter&lt;S, T&gt; <span class="title">getConverter</span><span class="params">(Class&lt;T&gt; targetType)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-4-GenericConverter"><a href="#3-1-4-GenericConverter" class="headerlink" title="3.1.4 GenericConverter"></a>3.1.4 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/converter/GenericConverter.java" target="_blank" rel="external">GenericConverter</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于在两种或多种类型之间转换的通用转换器接口。</div><div class="line"> * 这是转换器SPI接口中最灵活的，也是最复杂的。 它是灵活的，因为GenericConverter可以支持在多个 source/target 类型对之间进行转换（参见&#123;<span class="doctag">@link</span> #getConvertibleTypes()&#125;）。此外，GenericConverter实现在类型转换期间可以访问 source / target &#123;<span class="doctag">@link</span> TypeDescriptor field context&#125; 这可以解决 source 和 target 字段元数据，如 annotations 和泛型信息，可用于影响转换逻辑。</div><div class="line"> * 当简单的&#123;<span class="doctag">@link</span> Converter&#125;或&#123;<span class="doctag">@link</span> ConverterFactory&#125;接口就足够时，通常不会使用该接口。</div><div class="line"> * 实现可以同时实现&#123;<span class="doctag">@link</span> ConditionalConverter&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GenericConverter</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回 source 和 target 的类型对，用于此转换器在类型之间转换。</div><div class="line">	 * 每个条目都是可转换的源到目标类型对。</div><div class="line">	 * 对于&#123;<span class="doctag">@link</span> ConditionalConverter conditional converters&#125;，此方法可能会返回&#123;<span class="doctag">@code</span> null&#125;以指示应考虑所有源对目标对。</div><div class="line">	 */</div><div class="line">	<span class="function">Set&lt;ConvertiblePair&gt; <span class="title">getConvertibleTypes</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将源对象转换为&#123;<span class="doctag">@code</span> TypeDescriptor&#125;描述的targetType。</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConvertiblePair</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; sourceType;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; targetType;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-5-ConverterAdapter"><a href="#3-1-5-ConverterAdapter" class="headerlink" title="3.1.5 ConverterAdapter"></a>3.1.5 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java" target="_blank" rel="external">ConverterAdapter</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将 &#123;<span class="doctag">@link</span> Converter&#125; 适配到 &#123;<span class="doctag">@link</span> GenericConverter&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterAdapter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Converter&lt;Object, Object&gt; converter;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConvertiblePair typeInfo;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ResolvableType targetType;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-6-ConverterFactoryAdapter"><a href="#3-1-6-ConverterFactoryAdapter" class="headerlink" title="3.1.6 ConverterFactoryAdapter"></a>3.1.6 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java" target="_blank" rel="external">ConverterFactoryAdapter</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 将 &#123;<span class="doctag">@link</span> ConverterFactory&#125; 适配到 &#123;<span class="doctag">@link</span> GenericConverter&#125; 。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConverterFactoryAdapter</span> <span class="keyword">implements</span> <span class="title">ConditionalGenericConverter</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConverterFactory&lt;Object, Object&gt; converterFactory;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ConvertiblePair typeInfo;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="3-1-7-Converters"><a href="#3-1-7-Converters" class="headerlink" title="3.1.7 Converters"></a>3.1.7 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java" target="_blank" rel="external">Converters</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 管理注册服务的所有转换器。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Converters</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Set&lt;GenericConverter&gt; globalConverters = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConvertiblePair, ConvertersForPair&gt; converters = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">36</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-Service"><a href="#4-Service" class="headerlink" title="4. Service"></a>4. Service</h2><h3 id="4-1-接口"><a href="#4-1-接口" class="headerlink" title="4.1 接口"></a>4.1 接口</h3><h5 id="4-1-1-ConversionService"><a href="#4-1-1-ConversionService" class="headerlink" title="4.1.1 ConversionService"></a>4.1.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/ConversionService.java" target="_blank" rel="external">ConversionService</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于类型转换的服务接口。这是转换系统的切入点。</div><div class="line"> * 调用 &#123;<span class="doctag">@link</span> #convert(Object, Class)&#125; 以使用此系统执行线程安全类型转换。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConversionService</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果 &#123;<span class="doctag">@code</span> sourceType&#125; 的对象可以转换为 &#123;<span class="doctag">@code</span> targetType&#125; ，返回 &#123;<span class="doctag">@code</span> true&#125;。</div><div class="line">	 * 如果此方法返回&#123;<span class="doctag">@code</span> true&#125;，则表示 &#123;<span class="doctag">@link</span> #convert(Object, Class)&#125; 能够将 &#123;<span class="doctag">@code</span> sourceType&#125; 的实例转换为 &#123;<span class="doctag">@code</span> targetType&#125;。</div><div class="line">	 * collections，arrays 和 map 类型的特别说明：</div><div class="line">	 * 对于collections，arrays 和 map类型之间的转换，即使转换调用此方法将返回&#123;<span class="doctag">@code</span> true&#125;，如果基础元素不可转换，仍然可能会生成&#123;<span class="doctag">@link</span> ConversionException&#125;。 在使用 collections 和 maps 时，调用方应该处理这种特殊情况。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果&#123;<span class="doctag">@code</span> sourceType&#125;的对象可以转换为&#123;<span class="doctag">@code</span> targetType&#125;，返回&#123;<span class="doctag">@code</span> true&#125;。</div><div class="line">	 * TypeDescriptors提供了关于 source 和 target 转换发生的位置的附加上下文，通常是对象字段或属性位置。</div><div class="line">	 * 如果此方法返回&#123;<span class="doctag">@code</span> true&#125;，则表示 &#123;<span class="doctag">@link</span> #convert(Object, TypeDescriptor, TypeDescriptor)&#125; 能够将 &#123;<span class="doctag">@code</span> sourceType&#125; 的实例转换为&#123;<span class="doctag">@code</span> targetType&#125;。</div><div class="line">	 * collections，arrays 和 map 类型的特别说明：</div><div class="line">	 * 对于collections，arrays 和 map类型之间的转换，即使转换调用此方法将返回&#123;<span class="doctag">@code</span> true&#125;，如果基础元素不可转换，仍然可能会生成&#123;<span class="doctag">@link</span> ConversionException&#125;。 在使用 collections 和 maps 时，调用方应该处理这种特殊情况。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">canConvert</span><span class="params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将给定的&#123;<span class="doctag">@code</span> source&#125;转换为指定的&#123;<span class="doctag">@code</span> targetType&#125;。</div><div class="line">	 */</div><div class="line">	&lt;T&gt; <span class="function">T <span class="title">convert</span><span class="params">(Object source, Class&lt;T&gt; targetType)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将给定的&#123;<span class="doctag">@code</span> source&#125;转换为指定的&#123;<span class="doctag">@code</span> targetType&#125;。</div><div class="line">	 * TypeDescriptors提供了关于 source 和 target 转换发生的位置的附加上下文，通常是对象字段或属性位置。</div><div class="line">	 */</div><div class="line">	<span class="function">Object <span class="title">convert</span><span class="params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-1-2-ConverterRegistry"><a href="#4-1-2-ConverterRegistry" class="headerlink" title="4.1.2 ConverterRegistry"></a>4.1.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/converter/ConverterRegistry.java" target="_blank" rel="external">ConverterRegistry</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于注册类型转换系统的转换器</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConverterRegistry</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将一个普通转换器添加到此注册表。</div><div class="line">	 * 可转换的 source/target 类型对，派生自转 Converter 的参数化类型。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Converter&lt;?, ?&gt; converter)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将一个普通转换器添加到此注册表。</div><div class="line">	 * 明确指定可转换 source/target 类型对。</div><div class="line">	 * 允许将转换器重用于多个不同的对，而无需为每对创建一个Converter类。</div><div class="line">	 */</div><div class="line">	&lt;S, T&gt; <span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(Class&lt;S&gt; sourceType, Class&lt;T&gt; targetType, Converter&lt;? <span class="keyword">super</span> S, ? extends T&gt; converter)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将通用转换器添加到此注册表。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addConverter</span><span class="params">(GenericConverter converter)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 向此注册表添加一个远程转换器工厂。</div><div class="line">	 * 可转换 source/target 类型对，派生自ConverterFactory的参数化类型。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">addConverterFactory</span><span class="params">(ConverterFactory&lt;?, ?&gt; factory)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将任何从&#123;<span class="doctag">@code</span> sourceType&#125;到&#123;<span class="doctag">@code</span> targetType&#125;转换器移除</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">removeConvertible</span><span class="params">(Class&lt;?&gt; sourceType, Class&lt;?&gt; targetType)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-1-3-ConfigurableConversionService"><a href="#4-1-3-ConfigurableConversionService" class="headerlink" title="4.1.3 ConfigurableConversionService"></a>4.1.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/support/ConfigurableConversionService.java" target="_blank" rel="external">ConfigurableConversionService</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 配置接口大多数（如果不是全部）由&#123;<span class="doctag">@link</span> ConversionService&#125;类型实现。 整合&#123;<span class="doctag">@link</span> ConversionService&#125;公开的只读操作以及&#123;<span class="doctag">@link</span> ConverterRegistry&#125;的变异操作，以便于方便的点对点添加和删除&#123;<span class="doctag">@link</span> org.springframework.core.convert.converter.Converter Converters&#125;。 后者在ApplicationContext引导代码中的&#123;<span class="doctag">@link</span> org.springframework.core.env.ConfigurableEnvironment ConfigurableEnvironment&#125;实例时特别有用。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ConfigurableConversionService</span> <span class="keyword">extends</span> <span class="title">ConversionService</span>, <span class="title">ConverterRegistry</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-2-实现"><a href="#4-2-实现" class="headerlink" title="4.2 实现"></a>4.2 实现</h3><h5 id="4-2-1GenericConversionService"><a href="#4-2-1GenericConversionService" class="headerlink" title="4.2.1GenericConversionService"></a>4.2.1<a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/convert/support/GenericConversionService.java" target="_blank" rel="external">GenericConversionService</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基于 &#123;<span class="doctag">@link</span> ConversionService&#125; 的实现，适用于大多数环境。</div><div class="line"> * 通过 &#123;<span class="doctag">@link</span> ConfigurableConversionService&#125; 接口间接实现 &#123;<span class="doctag">@link</span> ConverterRegistry&#125; 作为注册API。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericConversionService</span> <span class="keyword">implements</span> <span class="title">ConfigurableConversionService</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 不需要转换时使用的一般NO-OP转换器。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> GenericConverter NO_OP_CONVERTER = <span class="keyword">new</span> NoOpConverter(<span class="string">"NO_OP"</span>);</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 当没有转换器可用时用作缓存条目。</div><div class="line">	 * 此转换器从不返回。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> GenericConverter NO_MATCH = <span class="keyword">new</span> NoOpConverter(<span class="string">"NO_MATCH"</span>);</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Converters converters = <span class="keyword">new</span> Converters();</div><div class="line"></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;ConverterCacheKey, GenericConverter&gt; converterCache = <span class="keyword">new</span> ConcurrentReferenceHashMap&lt;&gt;(<span class="number">64</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;1-概述&quot;&gt;&lt;a href=&quot;#1-概述&quot; class=&quot;headerlink&quot; title=&quot;1.概述&quot;&gt;&lt;/a&gt;1.概述&lt;/h2&gt;&lt;p&gt;Spring 3引入了一个提供通用类型转换系统的core.convert包。 该系统定义了一个SPI来实现类型转换逻辑，以及
    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码解析 2.统一io ResourceLoader</title>
    <link href="http://leerenbo.cn/2017/05/06/spring-code-resourceloader/"/>
    <id>http://leerenbo.cn/2017/05/06/spring-code-resourceloader/</id>
    <published>2017-05-06T13:04:01.000Z</published>
    <updated>2017-05-17T11:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>ResourceLoader参考文档：<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources-resourceloader" target="_blank" rel="external">http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources-resourceloader</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>ResourceLoader接口的实现旨在返回（加载）Resource 实例。</p>
<h2 id="2-类图"><a href="#2-类图" class="headerlink" title="2.类图"></a>2.类图</h2><p><img src="/assets/img/spring/springResourceLoader.png" alt=""></p>
<h2 id="3-接口"><a href="#3-接口" class="headerlink" title="3.接口"></a>3.接口</h2><h3 id="3-1-ResourceLoader"><a href="#3-1-ResourceLoader" class="headerlink" title="3.1 ResourceLoader"></a>3.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/ResourceLoader.java" target="_blank" rel="external">ResourceLoader</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 加载资源的策略接口（e ..类路径或文件系统资源）。</div><div class="line"> * 需要一个&#123;<span class="doctag">@link</span> org.springframework.context.ApplicationContext&#125;来提供此功能，以及扩展的&#123;<span class="doctag">@link</span> org.springframework.core.io.support.ResourcePatternResolver&#125;支持。</div><div class="line"> * &#123;<span class="doctag">@link</span> DefaultResourceLoader&#125;是一个独立的实现，可以在ApplicationContext之外使用，也由&#123;<span class="doctag">@link</span> ResourceEditor&#125;使用。</div><div class="line"> * 在ApplicationContext中运行时，可以使用特定上下文的资源加载策略，从字符串填充Resource类型的Bean属性和Resource数组。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourceLoader</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 从类路径加载的伪URL前缀："classpath:"</div><div class="line">	 */</div><div class="line">	String CLASSPATH_URL_PREFIX = ResourceUtils.CLASSPATH_URL_PREFIX;</div><div class="line"></div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回指定资源位置的Resource句柄。</div><div class="line">	 * 句柄应该始终是可重用的资源描述符，允许多个&#123;<span class="doctag">@link</span> Resource#getInputStream()&#125;调用。</div><div class="line">	 * 必须支持完全限定的URLs，例如 "file:C:/test.dat"。</div><div class="line">	 * 必须支持类路径伪URL，例如 "classpath:test.dat"。</div><div class="line">	 * 应该支持相对文件路径，例如 "WEB-INF/test.dat"。</div><div class="line">	 *（这将是实现特定的，通常由ApplicationContext实现提供）</div><div class="line">	 * 请注意，Resource句柄并不表示资源存在; 您需要调用 &#123;<span class="doctag">@link</span> Resource#exists&#125; 来检查是否存在。</div><div class="line">	 */</div><div class="line">	<span class="function">Resource <span class="title">getResource</span><span class="params">(String location)</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 暴露此ResourceLoader使用的ClassLoader。</div><div class="line">	 * 需要直接访问ClassLoader的客户端可以使用ResourceLoader以统一的方式执行，而不是依赖线程上下文ClassLoader。</div><div class="line">	 */</div><div class="line">	<span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-2-ResourcePatternResolver"><a href="#3-2-ResourcePatternResolver" class="headerlink" title="3.2 ResourcePatternResolver"></a>3.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/support/ResourcePatternResolver.java" target="_blank" rel="external">ResourcePatternResolver</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于将位置格式（例如，Ant样式路径格式）解析为Resource对象的策略接口。</div><div class="line"> * 这是&#123;<span class="doctag">@link</span> org.springframework.core.io.ResourceLoader&#125;接口的扩展。可以检查传递的ResourceLoader是否实现此扩展接口（例如，在上下文中运行时通过&#123;<span class="doctag">@link</span> org.springframework.context.ResourceLoaderAware&#125;传递的&#123;<span class="doctag">@link</span> org.springframework.context.ApplicationContext&#125;）。</div><div class="line"> * &#123;<span class="doctag">@link</span> PathMatchingResourcePatternResolver&#125;是一个独立的实现，可在ApplicationContext外部使用，也由&#123;<span class="doctag">@link</span> ResourceArrayPropertyEditor&#125;用于填充资源阵列bean属性。</div><div class="line"> * 可以与任何种类的位置模板一起使用（例如“/WEB-INF/*-context.xml”）：输入模板必须与策略实现相匹配。该接口只是指定转换方法而不是特定的模板格式。</div><div class="line"> * 此接口还为类路径中的所有匹配资源建议一个新的资源前缀 "classpath*:"。</div><div class="line"> * 请注意，在这种情况下，资源位置预计是没有占位符的路径（例如“/beans.xml”）;JAR文件或类目录可以包含同名的多个文件。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResourcePatternResolver</span> <span class="keyword">extends</span> <span class="title">ResourceLoader</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 来自类路径的所有匹配资源的伪URL前缀："classpath*:"</div><div class="line">	 * 与ResourceLoader的类路径URL前缀不同之处在于它检索给定名称的所有匹配资源（例如“/beans.xml”），例如在所有已部署的JAR文件的根目录中。</div><div class="line">	 */</div><div class="line">	String CLASSPATH_ALL_URL_PREFIX = <span class="string">"classpath*:"</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 将给定的位置模板解析为资源对象。</div><div class="line">	 * 应尽可能避免重叠指向相同物理资源的资源条目。结果应该设置语义。</div><div class="line">	 */</div><div class="line">	Resource[] getResources(String locationPattern) <span class="keyword">throws</span> IOException;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="4-抽象类、实现"><a href="#4-抽象类、实现" class="headerlink" title="4. 抽象类、实现"></a>4. 抽象类、实现</h2><h3 id="4-1-DefaultResourceLoader"><a href="#4-1-DefaultResourceLoader" class="headerlink" title="4.1 DefaultResourceLoader"></a>4.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/DefaultResourceLoader.java" target="_blank" rel="external">DefaultResourceLoader</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> ResourceLoader&#125;接口的默认实现。</div><div class="line"> * 由&#123;<span class="doctag">@link</span> ResourceEditor&#125;使用，并作为&#123;<span class="doctag">@link</span> org.springframework.context.support.AbstractApplicationContext&#125;的基类。 也可以独立使用。</div><div class="line"> * 如果位置值是URL，则返回&#123;<span class="doctag">@link</span> UrlResource&#125;，如果它是非URL路径或 "classpath:" 伪URL，则返回&#123;<span class="doctag">@link</span> ClassPathResource&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultResourceLoader</span> <span class="keyword">implements</span> <span class="title">ResourceLoader</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> ClassLoader classLoader;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Set&lt;ProtocolResolver&gt; protocolResolvers = <span class="keyword">new</span> LinkedHashSet&lt;&gt;(<span class="number">4</span>);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Map&lt;Resource, ?&gt;&gt; resourceCaches = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="number">4</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 协议特定资源句柄的解析策略。</div><div class="line"> * 用作&#123;<span class="doctag">@link</span> DefaultResourceLoader&#125;的SPI，允许在不对载入程序实现（或应用程序上下文实现）创建子类的情况下处理自定义协议。</div><div class="line"> */</div><div class="line"><span class="meta">@FunctionalInterface</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ProtocolResolver</span> </span>&#123;</div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果此实现的协议匹配，则针对给定的资源加载器解析给定位置。</div><div class="line">	 */</div><div class="line">	<span class="function">Resource <span class="title">resolve</span><span class="params">(String location, ResourceLoader resourceLoader)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-2-ClassRelativeResourceLoader"><a href="#4-2-ClassRelativeResourceLoader" class="headerlink" title="4.2 ClassRelativeResourceLoader"></a>4.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/ClassRelativeResourceLoader.java" target="_blank" rel="external">ClassRelativeResourceLoader</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> ResourceLoader&#125;实现，将普通资源路径解释为相对于给定的&#123;<span class="doctag">@code</span> java.lang.Class&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRelativeResourceLoader</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; clazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-3-FileSystemResourceLoader"><a href="#4-3-FileSystemResourceLoader" class="headerlink" title="4.3 FileSystemResourceLoader"></a>4.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/FileSystemResourceLoader.java" target="_blank" rel="external">FileSystemResourceLoader</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> ResourceLoader&#125;实现，它将简单路径解析为文件系统资源，而不是类路径资源（后者是&#123;<span class="doctag">@link</span> DefaultResourceLoader&#125;的默认策略））。</div><div class="line"> * 注意： 即使以斜线开始，平滑路径将始终被解释为相对于当前VM工作目录。 （这与Servlet容器中的语义一致。）</div><div class="line"> * 使用显式的"file:"前缀强制执行绝对文件路径。</div><div class="line"> * &#123;<span class="doctag">@link</span> org.springframework.context.support.FileSystemXmlApplicationContext&#125;是一个完整的ApplicationContext实现，提供相同的资源路径解析策略。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemResourceLoader</span> <span class="keyword">extends</span> <span class="title">DefaultResourceLoader</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="4-4-PathMatchingResourcePatternResolver"><a href="#4-4-PathMatchingResourcePatternResolver" class="headerlink" title="4.4 PathMatchingResourcePatternResolver"></a>4.4 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/support/PathMatchingResourcePatternResolver.java" target="_blank" rel="external">PathMatchingResourcePatternResolver</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个&#123;<span class="doctag">@link</span> ResourcePatternResolver&#125;实现，能够将指定的资源位置路径解析为一个或多个匹配的资源。</div><div class="line"> * 源路径可以是一个简单的路径，它具有与目标&#123;<span class="doctag">@link</span> org.springframework.core.io.Resource&#125;的一对一映射，或者可以包含特殊的"&#123;<span class="doctag">@code</span> classpath*:&#125;"前缀 和/或 内部Ant风格的正则表达式（使用Spring的&#123;<span class="doctag">@link</span> org.springframework.util.AntPathMatcher&#125;实用程序进行匹配）。后两者都是有效的通配符。</div><div class="line"> *</div><div class="line"> * 没有通配符：</div><div class="line"> * 在简单的情况下，如果指定的位置路径不以&#123;<span class="doctag">@code</span> "classpath*:&#125;"前缀开头，并且不包含PathMatcher模式，则此解析器将简单地通过&#123;<span class="doctag">@code</span> getResource()&#125;调用底层的&#123;<span class="doctag">@code</span> ResourceLoader&#125;。</div><div class="line"> * 示例：真实的URL，例如"&#123;<span class="doctag">@code</span> file:C:/context.xml&#125;"，伪URL（例如"&#123;<span class="doctag">@code</span> classpath:/context.xml&#125;"）和简单的无前缀路径，如"&#123;<span class="doctag">@code</span> /WEB-INF/context.xml&#125;"。</div><div class="line"> * 后者将以针对&#123;<span class="doctag">@code</span> ResourceLoader&#125;的特定方式解析（例如&#123;<span class="doctag">@code</span> WebApplicationContext&#125;的&#123;<span class="doctag">@code</span> ServletContextResource&#125;）。</div><div class="line"> *</div><div class="line"> * Ant风格模式：</div><div class="line"> * 当路径位置包含Ant样式模式时，例如：</div><div class="line"> * /WEB-INF/*-context.xml</div><div class="line"> * com/mycompany/** /applicationContext.xml</div><div class="line"> * file:C:/some/path/*-context.xml</div><div class="line"> * classpath:com/mycompany/** /applicationContext.xml</div><div class="line"> * 解析器遵循更复杂但定义的过程来尝试解决通配符。 它为最后一个非通配符段的路径生成一个&#123;<span class="doctag">@code</span> Resource&#125; ，并从中获取一个&#123;<span class="doctag">@code</span> URL&#125;。 如果此URL不“&#123;<span class="doctag">@code</span> jar：&#125;”URL或容器中的特定变体（例如：WebLogic中的&#123;<span class="doctag">@code</span> zip：&#125;，WebSphere中的&#123;<span class="doctag">@code</span> wsjar&#125;等），则从它获取&#123;<span class="doctag">@code</span> java.io.File&#125;，并用于通过走文件系统来解析通配符。</div><div class="line"> * 在一个jar URL的情况下，解析器从它获取一个&#123;<span class="doctag">@code</span> java.net.JarURLConnection&#125; 或手动解析jar URL，然后遍历jar文件的内容，以解决通配符。</div><div class="line"> *</div><div class="line"> * 对可移植性的影响：</div><div class="line"> * 如果指定的路径已经是文件URL（明确地或隐含地），因为基本的&#123;<span class="doctag">@code</span> ResourceLoader&#125;是一个文件系统的路径，那么通配符将保证以完全可移植的方式工作。</div><div class="line"> * 如果指定的路径是类路径位置，则解析器必须通过&#123;<span class="doctag">@code</span> Classloader.getResource()&#125;调用获取最后一个非通配符路径段URL。由于这只是路径的一个节点（而不是最后的文件），在这种情况下，它实际上是未定义的（在ClassLoader Javadocs中）返回的是什么样的URL。实际上，它通常是一个&#123;<span class="doctag">@code</span> java.io.File&#125;，表示类路径资源解析为文件系统位置的目录，或某个类别的jar URL其中类路径资源解析为一个jar位置。尽管如此，这种操作仍然存在可移植性问题。</div><div class="line"> * 如果为最后一个非通配符段获取了一个jar URL，解析器必须能够从中获取一个&#123;<span class="doctag">@code</span> java.net.JarURLConnection&#125;，或者手动解析jar URL，以便能够便利该jar的内容，并解决通配符。这将在大多数环境中工作，但在其他环境中将会失败，并且强烈建议您在依赖它之前，彻底地在您的特定环境中彻底测试来自jar的资源的通配符解析。</div><div class="line"> *</div><div class="line"> *</div><div class="line"> * &#123;<span class="doctag">@code</span> classpath*:&#125;前缀：</div><div class="line"> * 通过"&#123;<span class="doctag">@code</span> classpath*:&#125;"前缀，可以检索具有相同名称的多个类路径资源。</div><div class="line"> * 例如，“&#123;<span class="doctag">@code</span> classpath *：META-INF / beans.xml&#125;”将在类路径中找到所有“beans.xml”文件，无论是在“classes”目录还是在JAR文件中。这对于在每个jar文件中的同一位置自动检测同名的配置文件特别有用。在内部，这是通过&#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125;调用发生的，并且是完全可移植的。</div><div class="line"> * "classpath*:"前缀也可以与其他位置路径中的PathMatcher模式相结合，例如"classpath*:META-INF/*-beans.xml"。在这种情况下，分辨率策略相当简单：在最后一个非通配符路径段上使用&#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125;调用，以获取类加载器层次结构中的所有匹配资源，然后便利每个资源上面描述的相同的PathMatcher分辨率策略用于通配符子路径。</div><div class="line"> *</div><div class="line"> * 其他注意：</div><div class="line"> * 警告：请注意，与匹配模式启动相结合时，"&#123;<span class="doctag">@code</span> classpath*:&#125;" 只能与模式启动前的至少一个根目录一起工作，除非实际的目标 文件驻留在文件系统中。 这意味着像 "&#123;<span class="doctag">@code</span> classpath*:*.xml&#125;" 这样的模式将不会从jar文件的根目录中检索文件，而只能从扩展目录的根目录中获取文件。 这源于JDK的&#123;<span class="doctag">@code</span> ClassLoader.getResources()&#125;方法中的限制，该方法传入的空String仅返回文件系统位置（指示潜在的搜索根）。此&#123;<span class="doctag">@code</span> ResourcePatternResolver&#125;实现是通过&#123;<span class="doctag">@link</span> URLClassLoader&#125;内省和“java.class.path”清单评估来减轻jar根查找限制; 然而，没有可移植性的保证。</div><div class="line"> *</div><div class="line"> * 警告： 如果要搜索的根包存在多个类路径位置，则不能保证具有 "classpath:" 资源的Ant样式模式可以找到匹配的资源。</div><div class="line"> * 这是因为一个资源，如com/mycompany/package1/service-context.xml 可能只在一个位置，但是当一个路径如 classpath:com/mycompany/** /service-context.xml</div><div class="line"> * 用于尝试解决它，解析器将解决 &#123;<span class="doctag">@code</span> getResource("com/mycompany");&#125; 返回的（第一个）URL。 如果此基本包节点存在于多个类加载器位置中，则实际的最终资源可能不在下面。</div><div class="line"> * 因此，在这种情况下，最好使用具有相同Ant样式模式的“&#123;<span class="doctag">@code</span> classpath *：&#125;”，这将搜索包含根包的所有类路径位置。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathMatchingResourcePatternResolver</span> <span class="keyword">implements</span> <span class="title">ResourcePatternResolver</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Log logger = LogFactory.getLog(PathMatchingResourcePatternResolver.class);</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> ResourceLoader resourceLoader;</div><div class="line">	<span class="keyword">private</span> PathMatcher pathMatcher = <span class="keyword">new</span> AntPathMatcher();</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ResourceLoader参考文档：&lt;a href=&quot;http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources-resourceloader&quot; t
    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码解析 2.统一io Resource</title>
    <link href="http://leerenbo.cn/2017/04/30/spring-code-resource/"/>
    <id>http://leerenbo.cn/2017/04/30/spring-code-resource/</id>
    <published>2017-04-30T06:05:40.000Z</published>
    <updated>2017-05-17T11:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Resource参考文档：<a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources" target="_blank" rel="external">http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources</a></p>
<h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>Java的标准java.net.URL类和各种URL前缀的标准处理程序不足以满足对低级资源的所有访问。 例如，没有可用于访问需要从类路径或相对于ServletContext获取的资源的标准化URL实现。 虽然可以为专门的URL前缀注册新的处理程序（类似于前缀如http :)的现有处理程序，但这通常是相当复杂的，并且URL接口仍然缺少一些所需的功能，例如检查存在的方法 的资源。</p>
<p>基于以上原因，spring 提供了 ：</p>
<ul>
<li>Resource - 统一资源，规范化操作</li>
<li>ResourceLoader - 统一资源加载操作，屏蔽加载具体实现</li>
</ul>
<h2 id="2-Resource"><a href="#2-Resource" class="headerlink" title="2.Resource"></a>2.Resource</h2><p><img src="/assets/img/spring/springResource.png" alt=""></p>
<h3 id="2-1-接口"><a href="#2-1-接口" class="headerlink" title="2.1 接口"></a>2.1 接口</h3><ul>
<li>InputStreamSource - 用于获取InputStream，每次都是新的InputStream</li>
<li>Resource - 用于获取资源描述，判断资源状态</li>
<li>WritableResource - 可写入资源，用于获取 OutputStream</li>
<li>ContextResource - 用于获取封闭上下文的相对路径</li>
</ul>
<h5 id="2-1-1-InputStreamSource"><a href="#2-1-1-InputStreamSource" class="headerlink" title="2.1.1 InputStreamSource"></a>2.1.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/InputStreamSource.java" target="_blank" rel="external">InputStreamSource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.io;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 获取 &#123;<span class="doctag">@link</span> InputStream&#125; 对象的简单接口。</div><div class="line"> * 是 &#123;<span class="doctag">@link</span> Resource&#125; 的父接口。</div><div class="line"> * 对于一次性流，可以使用 &#123;<span class="doctag">@link</span> InputStreamResource&#125; 提供任何给定的 &#123;<span class="doctag">@code</span> InputStream&#125; 。</div><div class="line"> * &#123;<span class="doctag">@link</span> ByteArrayResource&#125; 或任何基于 &#123;<span class="doctag">@code</span> Resource&#125; 的实现可以当做实体化的实例使用，允许人们多次读取底层内容流。</div><div class="line"> * 这使得该接口可用作，例如：邮件附件的抽象内容源。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InputStreamSource</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回一个 InputStream 。预期每个调用都会创建一个新的流。</div><div class="line">	 * 当您考虑如JavaMail等的API，在创建邮件附件时，需要多次读取流时，这一需求尤为重要。</div><div class="line">	 * 对于这种用例，需要每个getInputStream（）调用返回一个新的流。</div><div class="line">	 */</div><div class="line">	<span class="function">InputStream <span class="title">getInputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-1-2-Resource"><a href="#2-1-2-Resource" class="headerlink" title="2.1.2 Resource"></a>2.1.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/Resource.java" target="_blank" rel="external">Resource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.io;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.File;</div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.InputStream;</div><div class="line"><span class="keyword">import</span> java.net.URI;</div><div class="line"><span class="keyword">import</span> java.net.URL;</div><div class="line"><span class="keyword">import</span> java.nio.channels.Channels;</div><div class="line"><span class="keyword">import</span> java.nio.channels.ReadableByteChannel;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 资源描述符的接口，从基础资源的实际类型（例如文件或类路径资源）抽象。 </div><div class="line"> * 如果每个资源以物理形式存在，则可以打开InputStream。</div><div class="line"> * 但只能为某些资源返回URL或File句柄。 实际行为是根据具体实现。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Resource</span> <span class="keyword">extends</span> <span class="title">InputStreamSource</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	* 判断此资源是否以物理形式存在。</div><div class="line">	* 该方法执行确定的存在检查。</div><div class="line">	* 而Resource句柄的存在仅保证有效的描述符句柄。</div><div class="line">	*/</div><div class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指示是否可以通过 getInputStream() 读取此资源的内容。 </div><div class="line">	 * 典型资源描述符将为  true ; </div><div class="line">	 * 请注意，尝试时实际内容读取可能仍然失败。</div><div class="line">	 * 但是， false 的值是无法读取资源内容的明确指示。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadable</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指示此资源是否表示具有开放流的句柄。 </div><div class="line">	 * 如果 true ，InputStream不能被多次读取，并且必须读取和关闭以避免资源泄漏。</div><div class="line">	 * 对于典型的资源描述符，将是 false 。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 确定此资源是否表示文件系统中的文件。</div><div class="line">	 * 值&#123;<span class="doctag">@code</span> true&#125;强烈建议（但不能保证）&#123;<span class="doctag">@link</span> #getFile（）&#125;调用将成功。</div><div class="line">	 * 默认情况下，是保守的&#123;<span class="doctag">@code</span> false&#125;。</div><div class="line">	 * <span class="doctag">@since</span> 5.0</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此资源的URL句柄。</div><div class="line">	 */</div><div class="line">	<span class="function">URL <span class="title">getURL</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此资源的URI句柄.</div><div class="line">	 */</div><div class="line">	<span class="function">URI <span class="title">getURI</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此资源的文件句柄.</div><div class="line">	 */</div><div class="line">	<span class="function">File <span class="title">getFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回&#123;<span class="doctag">@link</span> ReadableByteChannel&#125;。</div><div class="line">	 * 预计每个调用都会创建一个新的channel。</div><div class="line">	 * 默认实现返回&#123;<span class="doctag">@link</span> Channels＃newChannel(InputStream)&#125;，使用&#123;<span class="doctag">@link</span> #getInputStream()&#125;的结果&#125;）。</div><div class="line">	 * <span class="doctag">@since</span> 5.0</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> ReadableByteChannel <span class="title">readableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="keyword">return</span> Channels.newChannel(getInputStream());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 确定此资源的内容长度</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">long</span> <span class="title">contentLength</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 确定此资源的最后修改的时间戳.</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">long</span> <span class="title">lastModified</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 创建相对于此资源的资源</div><div class="line">	 */</div><div class="line">	<span class="function">Resource <span class="title">createRelative</span><span class="params">(String relativePath)</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 确定此资源的文件名，即通常是路径的最后一部分：例如“myfile.txt”。</div><div class="line">	 * 如果这种类型的资源没有文件名，返回&#123;<span class="doctag">@code</span> null&#125;。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getFilename</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回此资源的描述，用于处理资源时的错误输出。</div><div class="line">	 * 还鼓励实现类的&#123;<span class="doctag">@code</span> toString&#125;方法返回此值。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getDescription</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-1-3-WritableResource"><a href="#2-1-3-WritableResource" class="headerlink" title="2.1.3 WritableResource"></a>2.1.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/WritableResource.java" target="_blank" rel="external">WritableResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.io;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"><span class="keyword">import</span> java.io.OutputStream;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于支持写入的扩展资源的接口。</div><div class="line"> * 提供&#123;<span class="doctag">@link</span> #getOutputStream（）OutputStream 访问方法&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WritableResource</span> <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 指示此资源的内容是否可以通过&#123;<span class="doctag">@link</span> #getOutputStream（）&#125;写入。</div><div class="line">	 * 对于典型的资源描述符，将是&#123;<span class="doctag">@code</span> true&#125;; </div><div class="line">	 * 请注意，尝试时实际的内容写入可能仍然失败。</div><div class="line">	 * 但是，值&#123;<span class="doctag">@code</span> false&#125;是资源内容无法修改的明确指示。</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isWritable</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回底层资源的&#123;<span class="doctag">@link</span> OutputStream&#125;，允许（覆盖）写入内容。</div><div class="line">	 */</div><div class="line">	<span class="function">OutputStream <span class="title">getOutputStream</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回一个&#123;<span class="doctag">@link</span> WritableByteChannel&#125;。</div><div class="line">	 * 预计每次调用都会创建一个新鲜的 channel。</div><div class="line">	 * 默认实现返回&#123;<span class="doctag">@link</span> Channels#newChannel(OutputStream)&#125;，使用&#123;<span class="doctag">@link</span> #getOutputStream()&#125;的结果）。</div><div class="line">	 * <span class="doctag">@since</span> 5.0</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">default</span> WritableByteChannel <span class="title">writableChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">		<span class="keyword">return</span> Channels.newChannel(getOutputStream());</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-1-4-ContextResource"><a href="#2-1-4-ContextResource" class="headerlink" title="2.1.4 ContextResource"></a>2.1.4 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/ContextResource.java" target="_blank" rel="external">ContextResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> org.springframework.core.io;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从封闭的“上下文”加载的资源的扩展接口，</div><div class="line"> * 例如 来自&#123;<span class="doctag">@link</span> javax.servlet.ServletContext&#125;，但也可以使用纯类路径路径或相对文件系统路径（没有明确的前缀指定，因此适用于相对于本地&#123;<span class="doctag">@link</span> ResourceLoader&#125;的上下文）。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ContextResource</span> <span class="keyword">extends</span> <span class="title">Resource</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 返回包围的“上下文”中的路径。</div><div class="line">	 * 这通常是相对于上下文特定根目录的路径，例如。 一个ServletContext根或一个PortletContext根。</div><div class="line">	 */</div><div class="line">	<span class="function">String <span class="title">getPathWithinContext</span><span class="params">()</span></span>;</div><div class="line">	</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-2-抽象实现类"><a href="#2-2-抽象实现类" class="headerlink" title="2.2 抽象实现类"></a>2.2 抽象实现类</h3><h5 id="2-2-1-AbstractResource"><a href="#2-2-1-AbstractResource" class="headerlink" title="2.2.1 AbstractResource"></a>2.2.1 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/AbstractResource.java" target="_blank" rel="external">AbstractResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *  实现&#123;<span class="doctag">@link</span> Resource&#125;的便利基类，预先实现典型行为。</div><div class="line"> *  “存在”方法将检查是否可以打开File或InputStream;</div><div class="line"> *  “isOpen”将永远返回false;</div><div class="line"> *  “getURL”和“getFile”抛出异常;</div><div class="line"> *  “toString”将返回描述。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractResource</span> <span class="keyword">implements</span> <span class="title">Resource</span> </span>&#123;</div><div class="line">    </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-2-DescriptiveResource"><a href="#2-2-2-DescriptiveResource" class="headerlink" title="2.2.2 DescriptiveResource"></a>2.2.2 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/DescriptiveResource.java" target="_blank" rel="external">DescriptiveResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 简单的 &#123;<span class="doctag">@link</span> Resource&#125; 实现，保存资源描述，但不指向实际可读的资源。</div><div class="line"> * 如果API需要 &#123;<span class="doctag">@code</span> Resource&#125; 参数，但不一定用于实际读取时被用作占位符。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DescriptiveResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String description;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-3-VfsResource"><a href="#2-2-3-VfsResource" class="headerlink" title="2.2.3 VfsResource"></a>2.2.3 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/VfsResource.java" target="_blank" rel="external">VfsResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 基于JBoss VFS的&#123;<span class="doctag">@link</span> Resource&#125;实现。</div><div class="line"> * 从Spring 4.0开始，该类支持JBoss AS 6+上的VFS 3.x（软件包&#123;<span class="doctag">@code</span> org.jboss.vfs&#125;），特别兼容JBoss AS 7和WildFly 8。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VfsResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</div><div class="line">    	<span class="keyword">private</span> <span class="keyword">final</span> Object resource;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-4-InputStreamResource"><a href="#2-2-4-InputStreamResource" class="headerlink" title="2.2.4 InputStreamResource"></a>2.2.4 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/InputStreamResource.java" target="_blank" rel="external">InputStreamResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@link</span> Resource&#125;实现给定的&#123;<span class="doctag">@link</span> InputStream&#125;。</div><div class="line"> * 只有在没有其他特定的 &#123;<span class="doctag">@code</span> Resource&#125; 实现适用的情况下才使用。</div><div class="line"> * 特别是，尽可能选择&#123;<span class="doctag">@link</span> ByteArrayResource&#125;或任何基于文件的&#123;<span class="doctag">@code</span> Resource&#125;实现。</div><div class="line"> *</div><div class="line"> * 与其他&#123;<span class="doctag">@code</span> Resource&#125;实现相反，这是一个已经打开的资源的描述符，因此从&#123;<span class="doctag">@link</span> #isOpen()&#125;返回 &#123;<span class="doctag">@code</span> true&#125;。</div><div class="line"> * 如果您需要将资源描述符保留在某处，或者您需要多次读取数据流，请勿使用&#123;<span class="doctag">@code</span> InputStreamResource&#125;。</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStreamResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> InputStream inputStream;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String description;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">boolean</span> read = <span class="keyword">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-5-ByteArrayResource"><a href="#2-2-5-ByteArrayResource" class="headerlink" title="2.2.5 ByteArrayResource"></a>2.2.5 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/ByteArrayResource.java" target="_blank" rel="external">ByteArrayResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 一个给定的字节数组的 &#123;<span class="doctag">@link</span> Resource&#125;实现。</div><div class="line"> * 为给定的字节数组创建&#123;<span class="doctag">@link</span> ByteArrayInputStream&#125;。</div><div class="line"> * 用于从任何给定的字节数组加载内容，而无需使用单次使用的&#123;<span class="doctag">@link</span> InputStreamResource&#125;。</div><div class="line"> * 特别适用于从本地内容创建邮件附件，JavaMail需要能够多次读取流。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] byteArray;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String description;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-6-AbstractFileResolvingResource"><a href="#2-2-6-AbstractFileResolvingResource" class="headerlink" title="2.2.6 AbstractFileResolvingResource"></a>2.2.6 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/AbstractFileResolvingResource.java" target="_blank" rel="external">AbstractFileResolvingResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 用于将URL解析为文件引用的资源的抽象基类，例如&#123;<span class="doctag">@link</span> UrlResource&#125;或&#123;<span class="doctag">@link</span> ClassPathResource&#125;。</div><div class="line"> * 在URL中检测“文件”协议以及 JBoss“vfs”协议，相应地解析文件系统引用。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFileResolvingResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="2-2-7-UrlResource"><a href="#2-2-7-UrlResource" class="headerlink" title="2.2.7 UrlResource"></a>2.2.7 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/UrlResource.java" target="_blank" rel="external">UrlResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@code</span> java.net.URL&#125;定位器的&#123;<span class="doctag">@link</span> Resource&#125;实现。</div><div class="line"> * 在&#123;<span class="doctag">@code</span>“file：”&#125;协议的情况下支持解析为&#123;<span class="doctag">@code</span> URL&#125;，还可以作为&#123;<span class="doctag">@code</span> File&#125;。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrlResource</span> <span class="keyword">extends</span> <span class="title">AbstractFileResolvingResource</span> </span>&#123;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 如果有值，原始URI; 用于URI和文件访问。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> URI uri;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 原始URL，用于实际访问。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> URL url;</div><div class="line"></div><div class="line">	<span class="comment">/**</span></div><div class="line">	 * 已清理的URL（具有标准化路径），用于比较。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> URL cleanedUrl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所有URL都具有标准化的字符串表示形式，以便使用适当的标准化前缀来区分URL类型。<br>例如：文件系统路径 <code>file:</code>，HTTP协议<code>http:</code>，FTP<code>ftp:</code><br>除了几个已知前缀如<code>classpatch</code>会创建适当的Resource，不认识的前缀会作为标准 URL 串创。建UrlResource。</p>
<h5 id="2-2-8-ClassPathResource"><a href="#2-2-8-ClassPathResource" class="headerlink" title="2.2.8 ClassPathResource"></a>2.2.8 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/ClassPathResource.java" target="_blank" rel="external">ClassPathResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 路径资源的&#123;<span class="doctag">@link</span> Resource&#125;实现。 使用给定的&#123;<span class="doctag">@link</span> ClassLoader&#125;或给定的&#123;<span class="doctag">@link</span> Class&#125;来加载资源。</div><div class="line"> * 如果类路径资源驻留在文件系统中，则支持&#123;<span class="doctag">@code</span> java.io.File&#125;的解析。</div><div class="line"> * 但不支持JAR中的资源</div><div class="line"> * 始终支持解析为URL。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathResource</span> <span class="keyword">extends</span> <span class="title">AbstractFileResolvingResource</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String path;</div><div class="line">	<span class="keyword">private</span> ClassLoader classLoader;</div><div class="line">	<span class="keyword">private</span> Class&lt;?&gt; clazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>classpath:</code>创建ClassPathResource。<br>从classpath下加载的资源。不管是从线程classloader，给定classloader还是class。都可以使用此Resource。</p>
<h5 id="2-2-9-PathResource"><a href="#2-2-9-PathResource" class="headerlink" title="2.2.9 PathResource"></a>2.2.9 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/PathResource.java" target="_blank" rel="external">PathResource</a></h5><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@code</span> java.nio.file.Path&#125;句柄的&#123;<span class="doctag">@link</span> Resource&#125;实现。</div><div class="line"> * 支持分辨率为File，也可以作为URL。</div><div class="line"> * 实现扩展的&#123;<span class="doctag">@link</span> WritableResource&#125;接口。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PathResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> <span class="keyword">implements</span> <span class="title">WritableResource</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Path path;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-2-10-FileSystemResource"><a href="#2-2-10-FileSystemResource" class="headerlink" title="2.2.10 FileSystemResource"></a>2.2.10 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/FileSystemResource.java" target="_blank" rel="external">FileSystemResource</a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * &#123;<span class="doctag">@code</span> java.io.File&#125;句柄的&#123;<span class="doctag">@link</span> Resource&#125;实现。</div><div class="line"> * 支持作为&#123;<span class="doctag">@code</span> File&#125;和&#123;<span class="doctag">@code</span> URL&#125;的解析。</div><div class="line"> * 实现扩展的&#123;<span class="doctag">@link</span> WritableResource&#125;界面。</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemResource</span> <span class="keyword">extends</span> <span class="title">AbstractResource</span> <span class="keyword">implements</span> <span class="title">WritableResource</span> </span>&#123;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> File file;</div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> String path;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-2-10-FileSystemContextResource"><a href="#2-2-10-FileSystemContextResource" class="headerlink" title="2.2.10 FileSystemContextResource"></a>2.2.10 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/FileSystemResourceLoader.java" target="_blank" rel="external">FileSystemContextResource</a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * FileSystemResource，通过实现ContextResource接口显式表达上下文相对路径。</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemContextResource</span> <span class="keyword">extends</span> <span class="title">FileSystemResource</span> <span class="keyword">implements</span> <span class="title">ContextResource</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-2-11-ClassRelativeContextResource"><a href="#2-2-11-ClassRelativeContextResource" class="headerlink" title="2.2.11 ClassRelativeContextResource"></a>2.2.11 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/ClassRelativeResourceLoader.java" target="_blank" rel="external">ClassRelativeContextResource</a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">	<span class="comment">/**</span></div><div class="line">	 * ClassPathResource通过实现ContextResource接口显式表达上下文相对路径。</div><div class="line">	 */</div><div class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassRelativeContextResource</span> <span class="keyword">extends</span> <span class="title">ClassPathResource</span> <span class="keyword">implements</span> <span class="title">ContextResource</span> </span>&#123;</div><div class="line">		<span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; clazz;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h6 id="2-2-12-ClassPathContextResource"><a href="#2-2-12-ClassPathContextResource" class="headerlink" title="2.2.12 ClassPathContextResource"></a>2.2.12 <a href="https://github.com/LeeRenbo/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/DefaultResourceLoader.java" target="_blank" rel="external">ClassPathContextResource</a></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * ClassPathResource通过实现ContextResource接口显式表达上下文相对路径。</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathContextResource</span> <span class="keyword">extends</span> <span class="title">ClassPathResource</span> <span class="keyword">implements</span> <span class="title">ContextResource</span> </span>&#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Resource参考文档：&lt;a href=&quot;http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#resources&quot; target=&quot;_blank&quot; rel=&quot;e
    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
  <entry>
    <title>spring 源码解析 1.概述</title>
    <link href="http://leerenbo.cn/2017/04/30/spring-code-overview/"/>
    <id>http://leerenbo.cn/2017/04/30/spring-code-overview/</id>
    <published>2017-04-30T03:45:41.000Z</published>
    <updated>2017-05-17T11:38:33.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、干了这碗鸡汤"><a href="#一、干了这碗鸡汤" class="headerlink" title="一、干了这碗鸡汤"></a>一、干了这碗鸡汤</h2><p>阅读源码比较晦涩。读不懂，读了就忘，abandon 肯定会发生。届时请自行喝鸡汤。</p>
<ul>
<li>阅读前 - 必须要形成自己的阅读源码的动机，意识上做出决定。彻底拥抱spring，在所有 java 项目中使用 spring famework</li>
<li>阅读过程中 - 做有效阅读，一面要揣测作者意图；理解方法作用。一面分析设计模式；设想扩展场景。</li>
<li>阅读后 - 提炼精髓，提高编程修养，提升设计能力。<h3 id="1-阅读目标"><a href="#1-阅读目标" class="headerlink" title="1.阅读目标"></a>1.阅读目标</h3></li>
<li>了解使用 spring 提供的绝大部分功能，工具类。不重复造轮子。达到脱离 ApplicationContext 独立使用 spring 模块。</li>
<li>扩展，定制 ApplicationContext。<h3 id="2-阅读方法"><a href="#2-阅读方法" class="headerlink" title="2.阅读方法"></a>2.阅读方法</h3></li>
<li>正确的阅读方式：<ul>
<li>自下而上：根据包来绘制类图，从父类读到子类</li>
<li>自上而下：根据方法绘制时序图，从子类读到父类</li>
</ul>
</li>
<li><del>错误的阅读方式：debug跟踪</del></li>
<li>模块化集中阅读。</li>
</ul>
<h2 id="二、概述"><a href="#二、概述" class="headerlink" title="二、概述"></a>二、概述</h2><p>基于 spring 5.0.0.M5 版本阅读。</p>
<p>阅读本系列博客，默认你已经拥有：</p>
<ul>
<li>java 基础</li>
<li>uml 类图、时序图阅读能力</li>
<li><a href="http://docs.spring.io/spring/docs/5.0.0.M5/spring-framework-reference/htmlsingle/#core-convert-ConversionService-API" target="_blank" rel="external">spring 5.0.0.M5参考文档</a>阅读经验</li>
</ul>
<h3 id="1-模块"><a href="#1-模块" class="headerlink" title="1.模块"></a>1.模块</h3><p><img src="/assets/img/spring/springOverview.png" alt=""></p>
<h3 id="2-pom"><a href="#2-pom" class="headerlink" title="2.pom"></a>2.pom</h3><p><img src="/assets/img/spring/springContainerPom.png" alt=""></p>
<table>
<thead>
<tr>
<th style="text-align:left">ArtifactId</th>
<th style="text-align:left">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">spring-context</td>
<td style="text-align:left">应用程序，包括context组装，JMX，Jndi，缓存，定时调度，rmi，validation</td>
</tr>
<tr>
<td style="text-align:left">spring-core</td>
<td style="text-align:left">核心实用程序，asm，cglib，io，env，线程池</td>
</tr>
<tr>
<td style="text-align:left">spring-beans</td>
<td style="text-align:left">Beans支持，bean属性，BeanFactory，包括Groovy</td>
</tr>
<tr>
<td style="text-align:left">spring-expression</td>
<td style="text-align:left">Spring Expression Language (SpEL)</td>
</tr>
<tr>
<td style="text-align:left">spring-aop</td>
<td style="text-align:left">基于代理的AOP支持</td>
</tr>
</tbody>
</table>
<h3 id="3-ApplicationContext"><a href="#3-ApplicationContext" class="headerlink" title="3.ApplicationContext"></a>3.ApplicationContext</h3><p><img src="/assets/img/spring/ApplicationContextUML.png" alt=""><br>ApplicationContext提供的功能点：</p>
<ol>
<li>Resource、ResourceLoader、ResourcePatternResolver - 提供统一的 io 操作</li>
<li>Enviroment - 提供各种配置源的变量统一读取</li>
<li>*BeanFactory - 提供层级化，可罗列的BeanFactory获取Bean</li>
<li>ApplicationEventPublish - 提供发布订阅的监听者模式实现</li>
<li>MessageSource - 提供i18n</li>
</ol>
<p>本系列博客将按照 资源，加载环境，读取bean配置，生成Factory，处理事件，实例化Bean，aop的顺序(core,bean,context,aop)的顺序来阅读讲解</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;一、干了这碗鸡汤&quot;&gt;&lt;a href=&quot;#一、干了这碗鸡汤&quot; class=&quot;headerlink&quot; title=&quot;一、干了这碗鸡汤&quot;&gt;&lt;/a&gt;一、干了这碗鸡汤&lt;/h2&gt;&lt;p&gt;阅读源码比较晦涩。读不懂，读了就忘，abandon 肯定会发生。届时请自行喝鸡汤。&lt;/p&gt;

    
    </summary>
    
      <category term="spring" scheme="http://leerenbo.cn/categories/spring/"/>
    
      <category term="code" scheme="http://leerenbo.cn/categories/spring/code/"/>
    
    
      <category term="spring container" scheme="http://leerenbo.cn/tags/spring-container/"/>
    
  </entry>
  
</feed>
